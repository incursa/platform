// Copyright (c) Incursa
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using Dapper;
using Incursa.Platform.Inbox;
using Incursa.Platform.Metrics;
using Incursa.Platform.Outbox;
using Npgsql;

namespace Incursa.Platform.Tests;

/// <summary>
/// Tests for Dapper type handlers for strongly-typed ID types.
/// </summary>
[Collection(PostgresCollection.Name)]
public sealed class PostgresDapperTypeHandlerTests : PostgresTestBase
{
    public PostgresDapperTypeHandlerTests(ITestOutputHelper testOutputHelper, PostgresCollectionFixture sharedFixture)
        : base(testOutputHelper, sharedFixture)
    {
    }

    private async Task CreateTestTableAsync()
    {
        var connection = new NpgsqlConnection(ConnectionString);
        await using (connection.ConfigureAwait(false))
        {
            await connection.OpenAsync(TestContext.Current.CancellationToken).ConfigureAwait(false);

            await connection.ExecuteAsync(@"
            DROP TABLE IF EXISTS ""TestTable"";

            CREATE TABLE ""TestTable"" (
                ""Id"" integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                ""OwnerTokenColumn"" uuid,
                ""InboxMessageIdColumn"" uuid,
                ""OutboxMessageIdColumn"" uuid,
                ""OutboxWorkItemIdColumn"" uuid,
                ""JoinIdColumn"" uuid,
                ""InstanceIdColumn"" uuid,
                ""DatabaseIdColumn"" uuid,
                ""NullableOwnerTokenColumn"" uuid NULL
            );
        ", commandTimeout: 30).ConfigureAwait(false);
        }
    }

    /// <summary>When a row is inserted with an OwnerToken, then Dapper returns the same token.</summary>
    /// <intent>Confirm the OwnerToken handler maps UUID values losslessly.</intent>
    /// <scenario>Given handlers are registered and a row is inserted with OwnerTokenColumn plus other GUID fields.</scenario>
    /// <behavior>The OwnerToken query result matches the inserted token.</behavior>
    [Fact]
    public async Task OwnerToken_RoundTrip_WorksCorrectly()
    {
        await CreateTestTableAsync();
        PostgresDapperTypeHandlerRegistration.RegisterTypeHandlers();
        var ownerToken = OwnerToken.GenerateNew();

        await using var connection = new NpgsqlConnection(ConnectionString);

        await connection.ExecuteAsync(
            "INSERT INTO \"TestTable\" (\"OwnerTokenColumn\", \"InboxMessageIdColumn\", \"OutboxMessageIdColumn\", \"OutboxWorkItemIdColumn\", \"JoinIdColumn\", \"InstanceIdColumn\", \"DatabaseIdColumn\") VALUES (@OwnerToken, @Guid1, @Guid2, @Guid3, @Guid4, @Guid5, @Guid6)",
            new
            {
                OwnerToken = ownerToken,
                Guid1 = Guid.NewGuid(),
                Guid2 = Guid.NewGuid(),
                Guid3 = Guid.NewGuid(),
                Guid4 = Guid.NewGuid(),
                Guid5 = Guid.NewGuid(),
                Guid6 = Guid.NewGuid(),
            });

        var result = await connection.QuerySingleAsync<OwnerToken>(
            "SELECT \"OwnerTokenColumn\" FROM \"TestTable\" WHERE \"Id\" = 1");

        Assert.Equal(ownerToken, result);
    }

    /// <summary>When a nullable OwnerToken is stored in a nullable column, then it is read back intact.</summary>
    /// <intent>Confirm nullable OwnerToken values are materialized correctly.</intent>
    /// <scenario>Given handlers are registered and a row is inserted with NullableOwnerTokenColumn set.</scenario>
    /// <behavior>The nullable query result equals the inserted OwnerToken.</behavior>
    [Fact]
    public async Task NullableOwnerToken_RoundTrip_WorksCorrectly()
    {
        await CreateTestTableAsync();
        PostgresDapperTypeHandlerRegistration.RegisterTypeHandlers();
        var ownerToken = OwnerToken.GenerateNew();

        await using var connection = new NpgsqlConnection(ConnectionString);

        await connection.ExecuteAsync(
            "INSERT INTO \"TestTable\" (\"OwnerTokenColumn\", \"InboxMessageIdColumn\", \"OutboxMessageIdColumn\", \"OutboxWorkItemIdColumn\", \"JoinIdColumn\", \"InstanceIdColumn\", \"DatabaseIdColumn\", \"NullableOwnerTokenColumn\") VALUES (@Guid1, @Guid2, @Guid3, @Guid4, @Guid5, @Guid6, @Guid7, @OwnerToken)",
            new
            {
                Guid1 = Guid.NewGuid(),
                Guid2 = Guid.NewGuid(),
                Guid3 = Guid.NewGuid(),
                Guid4 = Guid.NewGuid(),
                Guid5 = Guid.NewGuid(),
                Guid6 = Guid.NewGuid(),
                Guid7 = Guid.NewGuid(),
                OwnerToken = ownerToken,
            });

        var result = await connection.QuerySingleAsync<OwnerToken?>(
            "SELECT \"NullableOwnerTokenColumn\" FROM \"TestTable\" WHERE \"Id\" = 1");

        Assert.Equal(ownerToken, result);
    }

    /// <summary>When an InboxMessageIdentifier is inserted, then Dapper reads the same identifier.</summary>
    /// <intent>Verify Dapper mapping for InboxMessageIdentifier UUIDs.</intent>
    /// <scenario>Given handlers are registered and a row is inserted with InboxMessageIdColumn set.</scenario>
    /// <behavior>The queried InboxMessageIdentifier matches the inserted value.</behavior>
    [Fact]
    public async Task InboxMessageIdentifier_RoundTrip_WorksCorrectly()
    {
        await CreateTestTableAsync();
        PostgresDapperTypeHandlerRegistration.RegisterTypeHandlers();
        var inboxMessageId = InboxMessageIdentifier.GenerateNew();

        await using var connection = new NpgsqlConnection(ConnectionString);

        await connection.ExecuteAsync(
            "INSERT INTO \"TestTable\" (\"OwnerTokenColumn\", \"InboxMessageIdColumn\", \"OutboxMessageIdColumn\", \"OutboxWorkItemIdColumn\", \"JoinIdColumn\", \"InstanceIdColumn\", \"DatabaseIdColumn\") VALUES (@Guid1, @InboxMessageId, @Guid2, @Guid3, @Guid4, @Guid5, @Guid6)",
            new
            {
                Guid1 = Guid.NewGuid(),
                InboxMessageId = inboxMessageId,
                Guid2 = Guid.NewGuid(),
                Guid3 = Guid.NewGuid(),
                Guid4 = Guid.NewGuid(),
                Guid5 = Guid.NewGuid(),
                Guid6 = Guid.NewGuid(),
            });

        var result = await connection.QuerySingleAsync<InboxMessageIdentifier>(
            "SELECT \"InboxMessageIdColumn\" FROM \"TestTable\" WHERE \"Id\" = 1");

        Assert.Equal(inboxMessageId, result);
    }

    /// <summary>When an OutboxMessageIdentifier is inserted, then Dapper returns the same identifier.</summary>
    /// <intent>Verify Dapper mapping for OutboxMessageIdentifier UUIDs.</intent>
    /// <scenario>Given handlers are registered and a row is inserted with OutboxMessageIdColumn set.</scenario>
    /// <behavior>The queried OutboxMessageIdentifier matches the inserted value.</behavior>
    [Fact]
    public async Task OutboxMessageIdentifier_RoundTrip_WorksCorrectly()
    {
        await CreateTestTableAsync();
        PostgresDapperTypeHandlerRegistration.RegisterTypeHandlers();
        var outboxMessageId = OutboxMessageIdentifier.GenerateNew();

        await using var connection = new NpgsqlConnection(ConnectionString);

        await connection.ExecuteAsync(
            "INSERT INTO \"TestTable\" (\"OwnerTokenColumn\", \"InboxMessageIdColumn\", \"OutboxMessageIdColumn\", \"OutboxWorkItemIdColumn\", \"JoinIdColumn\", \"InstanceIdColumn\", \"DatabaseIdColumn\") VALUES (@Guid1, @Guid2, @OutboxMessageId, @Guid3, @Guid4, @Guid5, @Guid6)",
            new
            {
                Guid1 = Guid.NewGuid(),
                Guid2 = Guid.NewGuid(),
                OutboxMessageId = outboxMessageId,
                Guid3 = Guid.NewGuid(),
                Guid4 = Guid.NewGuid(),
                Guid5 = Guid.NewGuid(),
                Guid6 = Guid.NewGuid(),
            });

        var result = await connection.QuerySingleAsync<OutboxMessageIdentifier>(
            "SELECT \"OutboxMessageIdColumn\" FROM \"TestTable\" WHERE \"Id\" = 1");

        Assert.Equal(outboxMessageId, result);
    }

    /// <summary>When an OutboxWorkItemIdentifier is stored, then Dapper reads it back unchanged.</summary>
    /// <intent>Verify Dapper mapping for OutboxWorkItemIdentifier UUIDs.</intent>
    /// <scenario>Given handlers are registered and a row is inserted with OutboxWorkItemIdColumn set.</scenario>
    /// <behavior>The queried OutboxWorkItemIdentifier matches the inserted value.</behavior>
    [Fact]
    public async Task OutboxWorkItemIdentifier_RoundTrip_WorksCorrectly()
    {
        await CreateTestTableAsync();
        PostgresDapperTypeHandlerRegistration.RegisterTypeHandlers();
        var outboxWorkItemId = OutboxWorkItemIdentifier.GenerateNew();

        await using var connection = new NpgsqlConnection(ConnectionString);

        await connection.ExecuteAsync(
            "INSERT INTO \"TestTable\" (\"OwnerTokenColumn\", \"InboxMessageIdColumn\", \"OutboxMessageIdColumn\", \"OutboxWorkItemIdColumn\", \"JoinIdColumn\", \"InstanceIdColumn\", \"DatabaseIdColumn\") VALUES (@Guid1, @Guid2, @Guid3, @OutboxWorkItemId, @Guid4, @Guid5, @Guid6)",
            new
            {
                Guid1 = Guid.NewGuid(),
                Guid2 = Guid.NewGuid(),
                Guid3 = Guid.NewGuid(),
                OutboxWorkItemId = outboxWorkItemId,
                Guid4 = Guid.NewGuid(),
                Guid5 = Guid.NewGuid(),
                Guid6 = Guid.NewGuid(),
            });

        var result = await connection.QuerySingleAsync<OutboxWorkItemIdentifier>(
            "SELECT \"OutboxWorkItemIdColumn\" FROM \"TestTable\" WHERE \"Id\" = 1");

        Assert.Equal(outboxWorkItemId, result);
    }

    /// <summary>When a JoinIdentifier is stored, then Dapper returns the same join id.</summary>
    /// <intent>Verify Dapper mapping for JoinIdentifier UUIDs.</intent>
    /// <scenario>Given handlers are registered and a row is inserted with JoinIdColumn set.</scenario>
    /// <behavior>The queried JoinIdentifier matches the inserted value.</behavior>
    [Fact]
    public async Task JoinIdentifier_RoundTrip_WorksCorrectly()
    {
        await CreateTestTableAsync();
        PostgresDapperTypeHandlerRegistration.RegisterTypeHandlers();
        var joinId = JoinIdentifier.GenerateNew();

        await using var connection = new NpgsqlConnection(ConnectionString);

        await connection.ExecuteAsync(
            "INSERT INTO \"TestTable\" (\"OwnerTokenColumn\", \"InboxMessageIdColumn\", \"OutboxMessageIdColumn\", \"OutboxWorkItemIdColumn\", \"JoinIdColumn\", \"InstanceIdColumn\", \"DatabaseIdColumn\") VALUES (@Guid1, @Guid2, @Guid3, @Guid4, @JoinId, @Guid5, @Guid6)",
            new
            {
                Guid1 = Guid.NewGuid(),
                Guid2 = Guid.NewGuid(),
                Guid3 = Guid.NewGuid(),
                Guid4 = Guid.NewGuid(),
                JoinId = joinId,
                Guid5 = Guid.NewGuid(),
                Guid6 = Guid.NewGuid(),
            });

        var result = await connection.QuerySingleAsync<JoinIdentifier>(
            "SELECT \"JoinIdColumn\" FROM \"TestTable\" WHERE \"Id\" = 1");

        Assert.Equal(joinId, result);
    }

    /// <summary>When an InstanceIdentifier is stored, then Dapper reads the same instance id.</summary>
    /// <intent>Verify Dapper mapping for InstanceIdentifier UUIDs.</intent>
    /// <scenario>Given handlers are registered and a row is inserted with InstanceIdColumn set.</scenario>
    /// <behavior>The queried InstanceIdentifier matches the inserted value.</behavior>
    [Fact]
    public async Task InstanceIdentifier_RoundTrip_WorksCorrectly()
    {
        await CreateTestTableAsync();
        PostgresDapperTypeHandlerRegistration.RegisterTypeHandlers();
        var instanceId = InstanceIdentifier.GenerateNew();

        await using var connection = new NpgsqlConnection(ConnectionString);

        await connection.ExecuteAsync(
            "INSERT INTO \"TestTable\" (\"OwnerTokenColumn\", \"InboxMessageIdColumn\", \"OutboxMessageIdColumn\", \"OutboxWorkItemIdColumn\", \"JoinIdColumn\", \"InstanceIdColumn\", \"DatabaseIdColumn\") VALUES (@Guid1, @Guid2, @Guid3, @Guid4, @Guid5, @InstanceId, @Guid6)",
            new
            {
                Guid1 = Guid.NewGuid(),
                Guid2 = Guid.NewGuid(),
                Guid3 = Guid.NewGuid(),
                Guid4 = Guid.NewGuid(),
                Guid5 = Guid.NewGuid(),
                InstanceId = instanceId,
                Guid6 = Guid.NewGuid(),
            });

        var result = await connection.QuerySingleAsync<InstanceIdentifier>(
            "SELECT \"InstanceIdColumn\" FROM \"TestTable\" WHERE \"Id\" = 1");

        Assert.Equal(instanceId, result);
    }

    /// <summary>When a DatabaseIdentifier is stored, then Dapper returns the same database id.</summary>
    /// <intent>Verify Dapper mapping for DatabaseIdentifier UUIDs.</intent>
    /// <scenario>Given handlers are registered and a row is inserted with DatabaseIdColumn set.</scenario>
    /// <behavior>The queried DatabaseIdentifier matches the inserted value.</behavior>
    [Fact]
    public async Task DatabaseIdentifier_RoundTrip_WorksCorrectly()
    {
        await CreateTestTableAsync();
        PostgresDapperTypeHandlerRegistration.RegisterTypeHandlers();
        var databaseId = DatabaseIdentifier.GenerateNew();

        await using var connection = new NpgsqlConnection(ConnectionString);

        await connection.ExecuteAsync(
            "INSERT INTO \"TestTable\" (\"OwnerTokenColumn\", \"InboxMessageIdColumn\", \"OutboxMessageIdColumn\", \"OutboxWorkItemIdColumn\", \"JoinIdColumn\", \"InstanceIdColumn\", \"DatabaseIdColumn\") VALUES (@Guid1, @Guid2, @Guid3, @Guid4, @Guid5, @Guid6, @DatabaseId)",
            new
            {
                Guid1 = Guid.NewGuid(),
                Guid2 = Guid.NewGuid(),
                Guid3 = Guid.NewGuid(),
                Guid4 = Guid.NewGuid(),
                Guid5 = Guid.NewGuid(),
                Guid6 = Guid.NewGuid(),
                DatabaseId = databaseId,
            });

        var result = await connection.QuerySingleAsync<DatabaseIdentifier>(
            "SELECT \"DatabaseIdColumn\" FROM \"TestTable\" WHERE \"Id\" = 1");

        Assert.Equal(databaseId, result);
    }

    /// <summary>When all identifier columns are queried together, then each property matches its inserted value.</summary>
    /// <intent>Confirm multi-column mapping across all identifier type handlers.</intent>
    /// <scenario>Given handlers are registered and one row contains each identifier value.</scenario>
    /// <behavior>The projected record returns every identifier unchanged.</behavior>
    [Fact]
    public async Task AllTypesInSingleQuery_RoundTrip_WorksCorrectly()
    {
        await CreateTestTableAsync();
        PostgresDapperTypeHandlerRegistration.RegisterTypeHandlers();
        var ownerToken = OwnerToken.GenerateNew();
        var inboxMessageId = InboxMessageIdentifier.GenerateNew();
        var outboxMessageId = OutboxMessageIdentifier.GenerateNew();
        var outboxWorkItemId = OutboxWorkItemIdentifier.GenerateNew();
        var joinId = JoinIdentifier.GenerateNew();
        var instanceId = InstanceIdentifier.GenerateNew();
        var databaseId = DatabaseIdentifier.GenerateNew();

        await using var connection = new NpgsqlConnection(ConnectionString);

        await connection.ExecuteAsync(
            "INSERT INTO \"TestTable\" (\"OwnerTokenColumn\", \"InboxMessageIdColumn\", \"OutboxMessageIdColumn\", \"OutboxWorkItemIdColumn\", \"JoinIdColumn\", \"InstanceIdColumn\", \"DatabaseIdColumn\") VALUES (@OwnerToken, @InboxMessageId, @OutboxMessageId, @OutboxWorkItemId, @JoinId, @InstanceId, @DatabaseId)",
            new
            {
                OwnerToken = ownerToken,
                InboxMessageId = inboxMessageId,
                OutboxMessageId = outboxMessageId,
                OutboxWorkItemId = outboxWorkItemId,
                JoinId = joinId,
                InstanceId = instanceId,
                DatabaseId = databaseId,
            });

        var result = await connection.QuerySingleAsync<AllTypesRow>(
            "SELECT \"OwnerTokenColumn\", \"InboxMessageIdColumn\", \"OutboxMessageIdColumn\", \"OutboxWorkItemIdColumn\", \"JoinIdColumn\", \"InstanceIdColumn\", \"DatabaseIdColumn\" FROM \"TestTable\" WHERE \"Id\" = 1");

        Assert.Equal(ownerToken, result.OwnerTokenColumn);
        Assert.Equal(inboxMessageId, result.InboxMessageIdColumn);
        Assert.Equal(outboxMessageId, result.OutboxMessageIdColumn);
        Assert.Equal(outboxWorkItemId, result.OutboxWorkItemIdColumn);
        Assert.Equal(joinId, result.JoinIdColumn);
        Assert.Equal(instanceId, result.InstanceIdColumn);
        Assert.Equal(databaseId, result.DatabaseIdColumn);
    }

    private sealed record AllTypesRow(
        OwnerToken OwnerTokenColumn,
        InboxMessageIdentifier InboxMessageIdColumn,
        OutboxMessageIdentifier OutboxMessageIdColumn,
        OutboxWorkItemIdentifier OutboxWorkItemIdColumn,
        JoinIdentifier JoinIdColumn,
        InstanceIdentifier InstanceIdColumn,
        DatabaseIdentifier DatabaseIdColumn);
}



