{
  "generatedAtUtc": "2026-02-01T05:28:34.4934903Z",
  "repo": {
    "defaultBranch": "main"
  },
  "summary": {
    "total": 725,
    "compliant": 0,
    "missingRequired": 0,
    "invalidFormat": 0
  },
  "byCategory": [
    {
      "category": "Incursa.Platform.Audit",
      "total": 4,
      "compliant": 4
    },
    {
      "category": "Incursa.Platform.Correlation",
      "total": 8,
      "compliant": 8
    },
    {
      "category": "Incursa.Platform.Email",
      "total": 20,
      "compliant": 20
    },
    {
      "category": "Incursa.Platform.HealthProbe",
      "total": 17,
      "compliant": 17
    },
    {
      "category": "Incursa.Platform.Observability",
      "total": 3,
      "compliant": 3
    },
    {
      "category": "Incursa.Platform.Operations",
      "total": 5,
      "compliant": 5
    },
    {
      "category": "Incursa.Platform.Postgres",
      "total": 1,
      "compliant": 1
    },
    {
      "category": "Incursa.Platform.Tests",
      "total": 626,
      "compliant": 626
    },
    {
      "category": "Incursa.Platform.Webhooks",
      "total": 14,
      "compliant": 14
    },
    {
      "category": "Modularity",
      "total": 13,
      "compliant": 13
    },
    {
      "category": "TestUtilities",
      "total": 14,
      "compliant": 14
    }
  ],
  "byTag": [],
  "byProject": [
    {
      "project": "Incursa.Platform.Audit.Tests",
      "total": 4,
      "compliant": 4
    },
    {
      "project": "Incursa.Platform.Correlation.Tests",
      "total": 8,
      "compliant": 8
    },
    {
      "project": "Incursa.Platform.Email.Tests",
      "total": 20,
      "compliant": 20
    },
    {
      "project": "Incursa.Platform.HealthProbe.Tests",
      "total": 17,
      "compliant": 17
    },
    {
      "project": "Incursa.Platform.InMemory.Tests",
      "total": 2,
      "compliant": 2
    },
    {
      "project": "Incursa.Platform.Observability.Tests",
      "total": 3,
      "compliant": 3
    },
    {
      "project": "Incursa.Platform.Operations.Tests",
      "total": 5,
      "compliant": 5
    },
    {
      "project": "Incursa.Platform.Postgres.Tests",
      "total": 200,
      "compliant": 200
    },
    {
      "project": "Incursa.Platform.SqlServer.Tests",
      "total": 300,
      "compliant": 300
    },
    {
      "project": "Incursa.Platform.TestUtilities",
      "total": 14,
      "compliant": 14
    },
    {
      "project": "Incursa.Platform.Tests",
      "total": 138,
      "compliant": 138
    },
    {
      "project": "Incursa.Platform.Webhooks.AspNetCore.Tests",
      "total": 4,
      "compliant": 4
    },
    {
      "project": "Incursa.Platform.Webhooks.Tests",
      "total": 10,
      "compliant": 10
    }
  ],
  "tests": [
    {
      "testId": "Incursa.Platform.Audit.Tests:Incursa.Platform.Audit.Tests.AuditModelTests.AnchorTrimsValues",
      "category": "Incursa.Platform.Audit",
      "tags": [],
      "summary": "When anchor Trims Values, then it behaves as expected.",
      "intent": "Document expected behavior for anchor Trims Values.",
      "scenario": "Given anchor Trims Values.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Audit.Tests/AuditModelTests.cs",
        "line": 27,
        "member": "Incursa.Platform.Audit.Tests.AuditModelTests.AnchorTrimsValues"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Audit.Tests"
    },
    {
      "testId": "Incursa.Platform.Audit.Tests:Incursa.Platform.Audit.Tests.AuditModelTests.ValidationAcceptsValidEvent",
      "category": "Incursa.Platform.Audit",
      "tags": [],
      "summary": "When validation Accepts Valid Event, then it behaves as expected.",
      "intent": "Document expected behavior for validation Accepts Valid Event.",
      "scenario": "Given validation Accepts Valid Event.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Audit.Tests/AuditModelTests.cs",
        "line": 87,
        "member": "Incursa.Platform.Audit.Tests.AuditModelTests.ValidationAcceptsValidEvent"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Audit.Tests"
    },
    {
      "testId": "Incursa.Platform.Audit.Tests:Incursa.Platform.Audit.Tests.AuditModelTests.ValidationEnforcesDataJsonLimit",
      "category": "Incursa.Platform.Audit",
      "tags": [],
      "summary": "When validation Enforces Data Json Limit, then it behaves as expected.",
      "intent": "Document expected behavior for validation Enforces Data Json Limit.",
      "scenario": "Given validation Enforces Data Json Limit.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Audit.Tests/AuditModelTests.cs",
        "line": 64,
        "member": "Incursa.Platform.Audit.Tests.AuditModelTests.ValidationEnforcesDataJsonLimit"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Audit.Tests"
    },
    {
      "testId": "Incursa.Platform.Audit.Tests:Incursa.Platform.Audit.Tests.AuditModelTests.ValidationRequiresNameMessageAndAnchor",
      "category": "Incursa.Platform.Audit",
      "tags": [],
      "summary": "When validation Requires Name Message And Anchor, then it behaves as expected.",
      "intent": "Document expected behavior for validation Requires Name Message And Anchor.",
      "scenario": "Given validation Requires Name Message And Anchor.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Audit.Tests/AuditModelTests.cs",
        "line": 41,
        "member": "Incursa.Platform.Audit.Tests.AuditModelTests.ValidationRequiresNameMessageAndAnchor"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Audit.Tests"
    },
    {
      "testId": "Incursa.Platform.Correlation.Tests:Incursa.Platform.Correlation.Tests.CorrelationModelTests.AmbientAccessorFlowsAcrossAsync",
      "category": "Incursa.Platform.Correlation",
      "tags": [],
      "summary": "When ambient Accessor Flows Across Async, then it behaves as expected.",
      "intent": "Document expected behavior for ambient Accessor Flows Across Async.",
      "scenario": "Given ambient Accessor Flows Across Async.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Correlation.Tests/CorrelationModelTests.cs",
        "line": 93,
        "member": "Incursa.Platform.Correlation.Tests.CorrelationModelTests.AmbientAccessorFlowsAcrossAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Correlation.Tests"
    },
    {
      "testId": "Incursa.Platform.Correlation.Tests:Incursa.Platform.Correlation.Tests.CorrelationModelTests.AmbientAccessorStoresContext",
      "category": "Incursa.Platform.Correlation",
      "tags": [],
      "summary": "When ambient Accessor Stores Context, then it behaves as expected.",
      "intent": "Document expected behavior for ambient Accessor Stores Context.",
      "scenario": "Given ambient Accessor Stores Context.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Correlation.Tests/CorrelationModelTests.cs",
        "line": 73,
        "member": "Incursa.Platform.Correlation.Tests.CorrelationModelTests.AmbientAccessorStoresContext"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Correlation.Tests"
    },
    {
      "testId": "Incursa.Platform.Correlation.Tests:Incursa.Platform.Correlation.Tests.CorrelationModelTests.CorrelationIdRequiresValue",
      "category": "Incursa.Platform.Correlation",
      "tags": [],
      "summary": "When correlation Id Requires Value, then it behaves as expected.",
      "intent": "Document expected behavior for correlation Id Requires Value.",
      "scenario": "Given correlation Id Requires Value.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Correlation.Tests/CorrelationModelTests.cs",
        "line": 26,
        "member": "Incursa.Platform.Correlation.Tests.CorrelationModelTests.CorrelationIdRequiresValue"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Correlation.Tests"
    },
    {
      "testId": "Incursa.Platform.Correlation.Tests:Incursa.Platform.Correlation.Tests.CorrelationModelTests.CorrelationIdTryParseRejectsEmpty",
      "category": "Incursa.Platform.Correlation",
      "tags": [],
      "summary": "When correlation Id Try Parse Rejects Empty, then it behaves as expected.",
      "intent": "Document expected behavior for correlation Id Try Parse Rejects Empty.",
      "scenario": "Given correlation Id Try Parse Rejects Empty.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Correlation.Tests/CorrelationModelTests.cs",
        "line": 36,
        "member": "Incursa.Platform.Correlation.Tests.CorrelationModelTests.CorrelationIdTryParseRejectsEmpty"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Correlation.Tests"
    },
    {
      "testId": "Incursa.Platform.Correlation.Tests:Incursa.Platform.Correlation.Tests.CorrelationModelTests.GeneratorCanBeDeterministic",
      "category": "Incursa.Platform.Correlation",
      "tags": [],
      "summary": "When generator Can Be Deterministic, then it behaves as expected.",
      "intent": "Document expected behavior for generator Can Be Deterministic.",
      "scenario": "Given generator Can Be Deterministic.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Correlation.Tests/CorrelationModelTests.cs",
        "line": 60,
        "member": "Incursa.Platform.Correlation.Tests.CorrelationModelTests.GeneratorCanBeDeterministic"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Correlation.Tests"
    },
    {
      "testId": "Incursa.Platform.Correlation.Tests:Incursa.Platform.Correlation.Tests.CorrelationModelTests.GeneratorReturnsValue",
      "category": "Incursa.Platform.Correlation",
      "tags": [],
      "summary": "When generator Returns Value, then it behaves as expected.",
      "intent": "Document expected behavior for generator Returns Value.",
      "scenario": "Given generator Returns Value.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Correlation.Tests/CorrelationModelTests.cs",
        "line": 47,
        "member": "Incursa.Platform.Correlation.Tests.CorrelationModelTests.GeneratorReturnsValue"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Correlation.Tests"
    },
    {
      "testId": "Incursa.Platform.Correlation.Tests:Incursa.Platform.Correlation.Tests.CorrelationModelTests.ScopeRestoresPreviousContext",
      "category": "Incursa.Platform.Correlation",
      "tags": [],
      "summary": "When scope Restores Previous Context, then it behaves as expected.",
      "intent": "Document expected behavior for scope Restores Previous Context.",
      "scenario": "Given scope Restores Previous Context.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Correlation.Tests/CorrelationModelTests.cs",
        "line": 116,
        "member": "Incursa.Platform.Correlation.Tests.CorrelationModelTests.ScopeRestoresPreviousContext"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Correlation.Tests"
    },
    {
      "testId": "Incursa.Platform.Correlation.Tests:Incursa.Platform.Correlation.Tests.CorrelationModelTests.SerializerRoundTrips",
      "category": "Incursa.Platform.Correlation",
      "tags": [],
      "summary": "When serializer Round Trips, then it behaves as expected.",
      "intent": "Document expected behavior for serializer Round Trips.",
      "scenario": "Given serializer Round Trips.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Correlation.Tests/CorrelationModelTests.cs",
        "line": 147,
        "member": "Incursa.Platform.Correlation.Tests.CorrelationModelTests.SerializerRoundTrips"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Correlation.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.EmailAspNetCoreExtensionsTests.AddIncursaEmailCoreRegistersComponents",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When add Incursa Email Core Registers Components, then it behaves as expected.",
      "intent": "Document expected behavior for add Incursa Email Core Registers Components.",
      "scenario": "Given add Incursa Email Core Registers Components.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/EmailAspNetCoreExtensionsTests.cs",
        "line": 34,
        "member": "Incursa.Platform.Email.Tests.EmailAspNetCoreExtensionsTests.AddIncursaEmailCoreRegistersComponents"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.EmailAspNetCoreExtensionsTests.HostedServiceInvokesProcessorAsync",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When hosted Service Invokes Processor Async, then it behaves as expected.",
      "intent": "Document expected behavior for hosted Service Invokes Processor Async.",
      "scenario": "Given hosted Service Invokes Processor Async.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/EmailAspNetCoreExtensionsTests.cs",
        "line": 55,
        "member": "Incursa.Platform.Email.Tests.EmailAspNetCoreExtensionsTests.HostedServiceInvokesProcessorAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.EmailIdempotencyCleanupTests.AddEmailIdempotencyCleanupHostedService_ThrowsForInvalidInterval",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When add Email Idempotency Cleanup Hosted Service Throws For Invalid Interval, then it behaves as expected.",
      "intent": "Document expected behavior for add Email Idempotency Cleanup Hosted Service Throws For Invalid Interval.",
      "scenario": "Given add Email Idempotency Cleanup Hosted Service Throws For Invalid Interval.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/EmailIdempotencyCleanupTests.cs",
        "line": 47,
        "member": "Incursa.Platform.Email.Tests.EmailIdempotencyCleanupTests.AddEmailIdempotencyCleanupHostedService_ThrowsForInvalidInterval"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.EmailIdempotencyCleanupTests.AddEmailIdempotencyCleanupHostedService_ThrowsForInvalidRetention",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When add Email Idempotency Cleanup Hosted Service Throws For Invalid Retention, then it behaves as expected.",
      "intent": "Document expected behavior for add Email Idempotency Cleanup Hosted Service Throws For Invalid Retention.",
      "scenario": "Given add Email Idempotency Cleanup Hosted Service Throws For Invalid Retention.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/EmailIdempotencyCleanupTests.cs",
        "line": 31,
        "member": "Incursa.Platform.Email.Tests.EmailIdempotencyCleanupTests.AddEmailIdempotencyCleanupHostedService_ThrowsForInvalidRetention"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.EmailIdempotencyCleanupTests.CleanupService_InvokesCleanupOnSchedule",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When cleanup Service Invokes Cleanup On Schedule, then it behaves as expected.",
      "intent": "Document expected behavior for cleanup Service Invokes Cleanup On Schedule.",
      "scenario": "Given cleanup Service Invokes Cleanup On Schedule.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/EmailIdempotencyCleanupTests.cs",
        "line": 63,
        "member": "Incursa.Platform.Email.Tests.EmailIdempotencyCleanupTests.CleanupService_InvokesCleanupOnSchedule"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.EmailMessageValidatorTests.Validate_ReturnsErrorsForMissingBody",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When validate Returns Errors For Missing Body, then it behaves as expected.",
      "intent": "Document expected behavior for validate Returns Errors For Missing Body.",
      "scenario": "Given validate Returns Errors For Missing Body.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/EmailMessageValidatorTests.cs",
        "line": 40,
        "member": "Incursa.Platform.Email.Tests.EmailMessageValidatorTests.Validate_ReturnsErrorsForMissingBody"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.EmailMessageValidatorTests.Validate_ReturnsSuccessForValidMessage",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When validate Returns Success For Valid Message, then it behaves as expected.",
      "intent": "Document expected behavior for validate Returns Success For Valid Message.",
      "scenario": "Given validate Returns Success For Valid Message.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/EmailMessageValidatorTests.cs",
        "line": 24,
        "member": "Incursa.Platform.Email.Tests.EmailMessageValidatorTests.Validate_ReturnsSuccessForValidMessage"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.EmailObservabilityTests.Enqueue_EmitsQueuedAuditEvent",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When enqueue Emits Queued Audit Event, then it behaves as expected.",
      "intent": "Document expected behavior for enqueue Emits Queued Audit Event.",
      "scenario": "Given enqueue Emits Queued Audit Event.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/EmailObservabilityTests.cs",
        "line": 31,
        "member": "Incursa.Platform.Email.Tests.EmailObservabilityTests.Enqueue_EmitsQueuedAuditEvent"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.EmailObservabilityTests.Processor_EmitsAttemptAndSentAuditEvents",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When processor Emits Attempt And Sent Audit Events, then it behaves as expected.",
      "intent": "Document expected behavior for processor Emits Attempt And Sent Audit Events.",
      "scenario": "Given processor Emits Attempt And Sent Audit Events.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/EmailObservabilityTests.cs",
        "line": 52,
        "member": "Incursa.Platform.Email.Tests.EmailObservabilityTests.Processor_EmitsAttemptAndSentAuditEvents"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.EmailOutboxDispatcherTests.DispatchAsync_SendsAndTracksOutcomes",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When dispatch Async Sends And Tracks Outcomes, then it behaves as expected.",
      "intent": "Document expected behavior for dispatch Async Sends And Tracks Outcomes.",
      "scenario": "Given dispatch Async Sends And Tracks Outcomes.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/EmailOutboxDispatcherTests.cs",
        "line": 24,
        "member": "Incursa.Platform.Email.Tests.EmailOutboxDispatcherTests.DispatchAsync_SendsAndTracksOutcomes"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.EmailOutboxOrchestrationTests.DuplicateEnqueue_DoesNotCreateSecondSend",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When duplicate Enqueue Does Not Create Second Send, then it behaves as expected.",
      "intent": "Document expected behavior for duplicate Enqueue Does Not Create Second Send.",
      "scenario": "Given duplicate Enqueue Does Not Create Second Send.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/EmailOutboxOrchestrationTests.cs",
        "line": 79,
        "member": "Incursa.Platform.Email.Tests.EmailOutboxOrchestrationTests.DuplicateEnqueue_DoesNotCreateSecondSend"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.EmailOutboxOrchestrationTests.Enqueue_ValidatesAndRecordsQueued",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When enqueue Validates And Records Queued, then it behaves as expected.",
      "intent": "Document expected behavior for enqueue Validates And Records Queued.",
      "scenario": "Given enqueue Validates And Records Queued.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/EmailOutboxOrchestrationTests.cs",
        "line": 32,
        "member": "Incursa.Platform.Email.Tests.EmailOutboxOrchestrationTests.Enqueue_ValidatesAndRecordsQueued"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.EmailOutboxOrchestrationTests.PermanentFailure_StopsAndMarksFinal",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When permanent Failure Stops And Marks Final, then it behaves as expected.",
      "intent": "Document expected behavior for permanent Failure Stops And Marks Final.",
      "scenario": "Given permanent Failure Stops And Marks Final.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/EmailOutboxOrchestrationTests.cs",
        "line": 173,
        "member": "Incursa.Platform.Email.Tests.EmailOutboxOrchestrationTests.PermanentFailure_StopsAndMarksFinal"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.EmailOutboxOrchestrationTests.PolicyDelay_ReschedulesWithoutSending",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When policy Delay Reschedules Without Sending, then it behaves as expected.",
      "intent": "Document expected behavior for policy Delay Reschedules Without Sending.",
      "scenario": "Given policy Delay Reschedules Without Sending.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/EmailOutboxOrchestrationTests.cs",
        "line": 197,
        "member": "Incursa.Platform.Email.Tests.EmailOutboxOrchestrationTests.PolicyDelay_ReschedulesWithoutSending"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.EmailOutboxOrchestrationTests.PolicyReject_FinalizesWithoutSending",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When policy Reject Finalizes Without Sending, then it behaves as expected.",
      "intent": "Document expected behavior for policy Reject Finalizes Without Sending.",
      "scenario": "Given policy Reject Finalizes Without Sending.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/EmailOutboxOrchestrationTests.cs",
        "line": 231,
        "member": "Incursa.Platform.Email.Tests.EmailOutboxOrchestrationTests.PolicyReject_FinalizesWithoutSending"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.EmailOutboxOrchestrationTests.ProbeConfirmation_FinalizesAfterFailure",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When probe Confirmation Finalizes After Failure, then it behaves as expected.",
      "intent": "Document expected behavior for probe Confirmation Finalizes After Failure.",
      "scenario": "Given probe Confirmation Finalizes After Failure.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/EmailOutboxOrchestrationTests.cs",
        "line": 146,
        "member": "Incursa.Platform.Email.Tests.EmailOutboxOrchestrationTests.ProbeConfirmation_FinalizesAfterFailure"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.EmailOutboxOrchestrationTests.Processor_SendsOnceAndMarksSent",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When processor Sends Once And Marks Sent, then it behaves as expected.",
      "intent": "Document expected behavior for processor Sends Once And Marks Sent.",
      "scenario": "Given processor Sends Once And Marks Sent.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/EmailOutboxOrchestrationTests.cs",
        "line": 52,
        "member": "Incursa.Platform.Email.Tests.EmailOutboxOrchestrationTests.Processor_SendsOnceAndMarksSent"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.EmailOutboxOrchestrationTests.TransientFailure_RetriesAndEventuallySucceeds",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When transient Failure Retries And Eventually Succeeds, then it behaves as expected.",
      "intent": "Document expected behavior for transient Failure Retries And Eventually Succeeds.",
      "scenario": "Given transient Failure Retries And Eventually Succeeds.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/EmailOutboxOrchestrationTests.cs",
        "line": 108,
        "member": "Incursa.Platform.Email.Tests.EmailOutboxOrchestrationTests.TransientFailure_RetriesAndEventuallySucceeds"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.InMemoryEmailOutboxStoreTests.Dequeue_ReturnsPendingItemsInOrder",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When dequeue Returns Pending Items In Order, then it behaves as expected.",
      "intent": "Document expected behavior for dequeue Returns Pending Items In Order.",
      "scenario": "Given dequeue Returns Pending Items In Order.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/InMemoryEmailOutboxStoreTests.cs",
        "line": 51,
        "member": "Incursa.Platform.Email.Tests.InMemoryEmailOutboxStoreTests.Dequeue_ReturnsPendingItemsInOrder"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.Email.Tests:Incursa.Platform.Email.Tests.InMemoryEmailOutboxStoreTests.Enqueue_MarksMessageKey",
      "category": "Incursa.Platform.Email",
      "tags": [],
      "summary": "When enqueue Marks Message Key, then it behaves as expected.",
      "intent": "Document expected behavior for enqueue Marks Message Key.",
      "scenario": "Given enqueue Marks Message Key.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Email.Tests/InMemoryEmailOutboxStoreTests.cs",
        "line": 24,
        "member": "Incursa.Platform.Email.Tests.InMemoryEmailOutboxStoreTests.Enqueue_MarksMessageKey"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Email.Tests"
    },
    {
      "testId": "Incursa.Platform.HealthProbe.Tests:Incursa.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.ParseDefaultsToConfiguredEndpoint",
      "category": "Incursa.Platform.HealthProbe",
      "tags": [],
      "summary": "Given only the base command, then parsing leaves EndpointName null and JsonOutput false.",
      "intent": "Describe default parsing with no endpoint or flags.",
      "scenario": "Given arguments containing only \"healthcheck\".",
      "behavior": "EndpointName remains null and JsonOutput stays false.",
      "source": {
        "file": "tests/Incursa.Platform.HealthProbe.Tests/HealthProbeCommandLineTests.cs",
        "line": 33,
        "member": "Incursa.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.ParseDefaultsToConfiguredEndpoint"
      },
      "status": "compliant",
      "project": "Incursa.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Incursa.Platform.HealthProbe.Tests:Incursa.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.ParseThrowsForUnknownFlag",
      "category": "Incursa.Platform.HealthProbe",
      "tags": [],
      "summary": "When an unknown flag is provided, then parsing throws a HealthProbeArgumentException.",
      "intent": "Describe parsing failure for unsupported command line options.",
      "scenario": "Given arguments including an unrecognized \"--nope\" option.",
      "behavior": "Parsing throws and the message mentions an unknown option.",
      "source": {
        "file": "tests/Incursa.Platform.HealthProbe.Tests/HealthProbeCommandLineTests.cs",
        "line": 96,
        "member": "Incursa.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.ParseThrowsForUnknownFlag"
      },
      "status": "compliant",
      "project": "Incursa.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Incursa.Platform.HealthProbe.Tests:Incursa.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.ParseUsesExplicitEndpointName",
      "category": "Incursa.Platform.HealthProbe",
      "tags": [],
      "summary": "Given an explicit endpoint argument, then parsing uses it as EndpointName.",
      "intent": "Describe parsing of a positional endpoint argument.",
      "scenario": "Given arguments \"healthcheck\" and \"deploy\".",
      "behavior": "EndpointName is \"deploy\".",
      "source": {
        "file": "tests/Incursa.Platform.HealthProbe.Tests/HealthProbeCommandLineTests.cs",
        "line": 46,
        "member": "Incursa.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.ParseUsesExplicitEndpointName"
      },
      "status": "compliant",
      "project": "Incursa.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Incursa.Platform.HealthProbe.Tests:Incursa.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.ParseUsesOverrides",
      "category": "Incursa.Platform.HealthProbe",
      "tags": [],
      "summary": "When override flags are provided, then parsing populates each override option.",
      "intent": "Describe parsing of URL, timeout, header, API key, TLS, and JSON flags.",
      "scenario": "Given arguments with url, timeout, header, apikey, insecure, and json options.",
      "behavior": "EndpointName and all override properties match the provided values.",
      "source": {
        "file": "tests/Incursa.Platform.HealthProbe.Tests/HealthProbeCommandLineTests.cs",
        "line": 58,
        "member": "Incursa.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.ParseUsesOverrides"
      },
      "status": "compliant",
      "project": "Incursa.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Incursa.Platform.HealthProbe.Tests:Incursa.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.TryRunReturnsInvalidWhenUrlMissing",
      "category": "Incursa.Platform.HealthProbe",
      "tags": [],
      "summary": "Given no URL override, then running the health check returns InvalidArguments.",
      "intent": "Describe validation when required URL input is missing.",
      "scenario": "Given a service provider and a command line containing only \"healthcheck\".",
      "behavior": "The returned exit code is InvalidArguments.",
      "source": {
        "file": "tests/Incursa.Platform.HealthProbe.Tests/HealthProbeCommandLineTests.cs",
        "line": 77,
        "member": "Incursa.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.TryRunReturnsInvalidWhenUrlMissing"
      },
      "status": "compliant",
      "project": "Incursa.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Incursa.Platform.HealthProbe.Tests:Incursa.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveAppendsLivePathWhenBaseHasNoPath",
      "category": "Incursa.Platform.HealthProbe",
      "tags": [],
      "summary": "When resolving the live endpoint against a base URL with no path, then /live is appended.",
      "intent": "Describe URL resolution for an explicit endpoint name.",
      "scenario": "Given a base URL without a path and a live endpoint mapping.",
      "behavior": "The resolved URL is https://example.test/live.",
      "source": {
        "file": "tests/Incursa.Platform.HealthProbe.Tests/HealthProbeUrlResolverTests.cs",
        "line": 33,
        "member": "Incursa.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveAppendsLivePathWhenBaseHasNoPath"
      },
      "status": "compliant",
      "project": "Incursa.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Incursa.Platform.HealthProbe.Tests:Incursa.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveAppendsReadyPathWhenBaseHasNoPath",
      "category": "Incursa.Platform.HealthProbe",
      "tags": [],
      "summary": "Given a base URL with no path and a default ready endpoint, then resolution appends /ready.",
      "intent": "Describe URL resolution for the default endpoint.",
      "scenario": "Given a base URL without a path, a ready endpoint path, and no override URL.",
      "behavior": "The resolved URL is https://example.test/ready and EndpointName is ready.",
      "source": {
        "file": "tests/Incursa.Platform.HealthProbe.Tests/HealthProbeUrlResolverTests.cs",
        "line": 13,
        "member": "Incursa.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveAppendsReadyPathWhenBaseHasNoPath"
      },
      "status": "compliant",
      "project": "Incursa.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Incursa.Platform.HealthProbe.Tests:Incursa.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveNormalizesPathWhenReadyPathIsRelative",
      "category": "Incursa.Platform.HealthProbe",
      "tags": [],
      "summary": "When the endpoint path is relative, then resolution combines it with the base URL.",
      "intent": "Describe resolution behavior for relative endpoint paths.",
      "scenario": "Given a base URL and a ready endpoint path without a leading slash.",
      "behavior": "The resolved URL is https://example.test/readyz.",
      "source": {
        "file": "tests/Incursa.Platform.HealthProbe.Tests/HealthProbeUrlResolverTests.cs",
        "line": 69,
        "member": "Incursa.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveNormalizesPathWhenReadyPathIsRelative"
      },
      "status": "compliant",
      "project": "Incursa.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Incursa.Platform.HealthProbe.Tests:Incursa.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveUsesExplicitPathWhenProvided",
      "category": "Incursa.Platform.HealthProbe",
      "tags": [],
      "summary": "Given an endpoint mapped to an absolute URL, then resolution uses that URL.",
      "intent": "Describe resolution behavior for absolute endpoint URLs.",
      "scenario": "Given an endpoint configured with https://example.test/healthz.",
      "behavior": "The resolved URL matches the configured absolute URL.",
      "source": {
        "file": "tests/Incursa.Platform.HealthProbe.Tests/HealthProbeUrlResolverTests.cs",
        "line": 51,
        "member": "Incursa.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveUsesExplicitPathWhenProvided"
      },
      "status": "compliant",
      "project": "Incursa.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Incursa.Platform.HealthProbe.Tests:Incursa.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveUsesOverrideUrlWhenProvided",
      "category": "Incursa.Platform.HealthProbe",
      "tags": [],
      "summary": "When an override URL is provided, then resolution returns the override and preserves the endpoint name.",
      "intent": "Describe precedence of override URLs.",
      "scenario": "Given a configured endpoint and an explicit override URL.",
      "behavior": "The resolved URL matches the override and EndpointName remains \"deploy\".",
      "source": {
        "file": "tests/Incursa.Platform.HealthProbe.Tests/HealthProbeUrlResolverTests.cs",
        "line": 88,
        "member": "Incursa.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveUsesOverrideUrlWhenProvided"
      },
      "status": "compliant",
      "project": "Incursa.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Incursa.Platform.HealthProbe.Tests:Incursa.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncAddsApiKeyHeaderWhenConfigured",
      "category": "Incursa.Platform.HealthProbe",
      "tags": [],
      "summary": "When API key settings are configured, then the probe request includes the API key header.",
      "intent": "Describe how API key options affect probe request headers.",
      "scenario": "Given options with ApiKey and ApiKeyHeaderName set in the runner.",
      "behavior": "The outgoing request contains the configured header and value.",
      "source": {
        "file": "tests/Incursa.Platform.HealthProbe.Tests/HttpHealthProbeRunnerTests.cs",
        "line": 151,
        "member": "Incursa.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncAddsApiKeyHeaderWhenConfigured"
      },
      "status": "compliant",
      "project": "Incursa.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Incursa.Platform.HealthProbe.Tests:Incursa.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncDoesNotTreatNonSuccessStatusAsHealthyEvenWhenJsonIsHealthy",
      "category": "Incursa.Platform.HealthProbe",
      "tags": [],
      "summary": "When the HTTP status is non-success, then the result is unhealthy even if JSON says Healthy.",
      "intent": "Describe precedence of HTTP status over JSON health status.",
      "scenario": "Given a ServiceUnavailable response whose JSON body reports \"Healthy\".",
      "behavior": "The result is unhealthy and the exit code is Unhealthy.",
      "source": {
        "file": "tests/Incursa.Platform.HealthProbe.Tests/HttpHealthProbeRunnerTests.cs",
        "line": 101,
        "member": "Incursa.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncDoesNotTreatNonSuccessStatusAsHealthyEvenWhenJsonIsHealthy"
      },
      "status": "compliant",
      "project": "Incursa.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Incursa.Platform.HealthProbe.Tests:Incursa.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsExceptionExitCodeOnTimeout",
      "category": "Incursa.Platform.HealthProbe",
      "tags": [],
      "summary": "When the probe times out, then the result uses the exception exit code.",
      "intent": "Describe timeout handling for HTTP probes.",
      "scenario": "Given a runner with a short timeout and a handler that delays beyond it.",
      "behavior": "The result is unhealthy and the exit code is Exception.",
      "source": {
        "file": "tests/Incursa.Platform.HealthProbe.Tests/HttpHealthProbeRunnerTests.cs",
        "line": 125,
        "member": "Incursa.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsExceptionExitCodeOnTimeout"
      },
      "status": "compliant",
      "project": "Incursa.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Incursa.Platform.HealthProbe.Tests:Incursa.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsHealthyForSuccessStatus",
      "category": "Incursa.Platform.HealthProbe",
      "tags": [],
      "summary": "When the probe handler returns 200 OK, then the result is healthy.",
      "intent": "Describe how a success HTTP status maps to a healthy probe result.",
      "scenario": "Given a runner using a stub handler that returns HttpStatusCode.OK.",
      "behavior": "The result is healthy and the exit code is Healthy.",
      "source": {
        "file": "tests/Incursa.Platform.HealthProbe.Tests/HttpHealthProbeRunnerTests.cs",
        "line": 17,
        "member": "Incursa.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsHealthyForSuccessStatus"
      },
      "status": "compliant",
      "project": "Incursa.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Incursa.Platform.HealthProbe.Tests:Incursa.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsHealthyWhenJsonStatusIsHealthy",
      "category": "Incursa.Platform.HealthProbe",
      "tags": [],
      "summary": "When a 200 OK response body reports Healthy, then the result is healthy.",
      "intent": "Describe how a JSON health status maps to the probe outcome.",
      "scenario": "Given a stubbed 200 OK response with JSON status \"Healthy\".",
      "behavior": "The result is healthy and the exit code is Healthy.",
      "source": {
        "file": "tests/Incursa.Platform.HealthProbe.Tests/HttpHealthProbeRunnerTests.cs",
        "line": 77,
        "member": "Incursa.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsHealthyWhenJsonStatusIsHealthy"
      },
      "status": "compliant",
      "project": "Incursa.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Incursa.Platform.HealthProbe.Tests:Incursa.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsUnhealthyForFailureStatus",
      "category": "Incursa.Platform.HealthProbe",
      "tags": [],
      "summary": "When the probe handler returns a failure status, then the result is unhealthy.",
      "intent": "Describe how non-success HTTP status maps to an unhealthy probe result.",
      "scenario": "Given a runner using a stub handler that returns ServiceUnavailable.",
      "behavior": "The result is unhealthy and the exit code is Unhealthy.",
      "source": {
        "file": "tests/Incursa.Platform.HealthProbe.Tests/HttpHealthProbeRunnerTests.cs",
        "line": 35,
        "member": "Incursa.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsUnhealthyForFailureStatus"
      },
      "status": "compliant",
      "project": "Incursa.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Incursa.Platform.HealthProbe.Tests:Incursa.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsUnhealthyWhenJsonStatusIsUnhealthy",
      "category": "Incursa.Platform.HealthProbe",
      "tags": [],
      "summary": "When a 200 OK response body reports Unhealthy, then the result is unhealthy.",
      "intent": "Describe how a JSON health status maps to the probe outcome.",
      "scenario": "Given a stubbed 200 OK response with JSON status \"Unhealthy\".",
      "behavior": "The result is unhealthy and the exit code is Unhealthy.",
      "source": {
        "file": "tests/Incursa.Platform.HealthProbe.Tests/HttpHealthProbeRunnerTests.cs",
        "line": 53,
        "member": "Incursa.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsUnhealthyWhenJsonStatusIsUnhealthy"
      },
      "status": "compliant",
      "project": "Incursa.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Incursa.Platform.Observability.Tests:Incursa.Platform.Observability.Tests.ObservationAnchorTests.AnchorRequiresValues",
      "category": "Incursa.Platform.Observability",
      "tags": [],
      "summary": "When anchor Requires Values, then it behaves as expected.",
      "intent": "Document expected behavior for anchor Requires Values.",
      "scenario": "Given anchor Requires Values.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Observability.Tests/ObservationAnchorTests.cs",
        "line": 26,
        "member": "Incursa.Platform.Observability.Tests.ObservationAnchorTests.AnchorRequiresValues"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Observability.Tests"
    },
    {
      "testId": "Incursa.Platform.Observability.Tests:Incursa.Platform.Observability.Tests.PlatformEventEmitterTests.EmitOperationCompletedMarksFailure",
      "category": "Incursa.Platform.Observability",
      "tags": [],
      "summary": "When emit Operation Completed Marks Failure, then it behaves as expected.",
      "intent": "Document expected behavior for emit Operation Completed Marks Failure.",
      "scenario": "Given emit Operation Completed Marks Failure.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Observability.Tests/PlatformEventEmitterTests.cs",
        "line": 81,
        "member": "Incursa.Platform.Observability.Tests.PlatformEventEmitterTests.EmitOperationCompletedMarksFailure"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Observability.Tests"
    },
    {
      "testId": "Incursa.Platform.Observability.Tests:Incursa.Platform.Observability.Tests.PlatformEventEmitterTests.EmitOperationStartedUsesTrackerAndWriter",
      "category": "Incursa.Platform.Observability",
      "tags": [],
      "summary": "When emit Operation Started Uses Tracker And Writer, then it behaves as expected.",
      "intent": "Document expected behavior for emit Operation Started Uses Tracker And Writer.",
      "scenario": "Given emit Operation Started Uses Tracker And Writer.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Observability.Tests/PlatformEventEmitterTests.cs",
        "line": 32,
        "member": "Incursa.Platform.Observability.Tests.PlatformEventEmitterTests.EmitOperationStartedUsesTrackerAndWriter"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Observability.Tests"
    },
    {
      "testId": "Incursa.Platform.Operations.Tests:Incursa.Platform.Operations.Tests.OperationModelTests.RunAsyncCompletesAndPropagatesFailure",
      "category": "Incursa.Platform.Operations",
      "tags": [],
      "summary": "When run Async Completes And Propagates Failure, then it behaves as expected.",
      "intent": "Document expected behavior for run Async Completes And Propagates Failure.",
      "scenario": "Given run Async Completes And Propagates Failure.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Operations.Tests/OperationModelTests.cs",
        "line": 110,
        "member": "Incursa.Platform.Operations.Tests.OperationModelTests.RunAsyncCompletesAndPropagatesFailure"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Operations.Tests"
    },
    {
      "testId": "Incursa.Platform.Operations.Tests:Incursa.Platform.Operations.Tests.OperationModelTests.ScopeCompletesOnSuccess",
      "category": "Incursa.Platform.Operations",
      "tags": [],
      "summary": "When scope Completes On Success, then it behaves as expected.",
      "intent": "Document expected behavior for scope Completes On Success.",
      "scenario": "Given scope Completes On Success.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Operations.Tests/OperationModelTests.cs",
        "line": 71,
        "member": "Incursa.Platform.Operations.Tests.OperationModelTests.ScopeCompletesOnSuccess"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Operations.Tests"
    },
    {
      "testId": "Incursa.Platform.Operations.Tests:Incursa.Platform.Operations.Tests.OperationModelTests.ScopeRecordsFailureOnDispose",
      "category": "Incursa.Platform.Operations",
      "tags": [],
      "summary": "When scope Records Failure On Dispose, then it behaves as expected.",
      "intent": "Document expected behavior for scope Records Failure On Dispose.",
      "scenario": "Given scope Records Failure On Dispose.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Operations.Tests/OperationModelTests.cs",
        "line": 90,
        "member": "Incursa.Platform.Operations.Tests.OperationModelTests.ScopeRecordsFailureOnDispose"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Operations.Tests"
    },
    {
      "testId": "Incursa.Platform.Operations.Tests:Incursa.Platform.Operations.Tests.OperationModelTests.StartUpdateCompleteTransitions",
      "category": "Incursa.Platform.Operations",
      "tags": [],
      "summary": "When start Update Complete Transitions, then it behaves as expected.",
      "intent": "Document expected behavior for start Update Complete Transitions.",
      "scenario": "Given start Update Complete Transitions.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Operations.Tests/OperationModelTests.cs",
        "line": 27,
        "member": "Incursa.Platform.Operations.Tests.OperationModelTests.StartUpdateCompleteTransitions"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Operations.Tests"
    },
    {
      "testId": "Incursa.Platform.Operations.Tests:Incursa.Platform.Operations.Tests.OperationModelTests.WatcherContractReturnsSnapshots",
      "category": "Incursa.Platform.Operations",
      "tags": [],
      "summary": "When watcher Contract Returns Snapshots, then it behaves as expected.",
      "intent": "Document expected behavior for watcher Contract Returns Snapshots.",
      "scenario": "Given watcher Contract Returns Snapshots.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Operations.Tests/OperationModelTests.cs",
        "line": 131,
        "member": "Incursa.Platform.Operations.Tests.OperationModelTests.WatcherContractReturnsSnapshots"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Operations.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Postgres.Tests.ControlPlaneGlobalSchedulerTests.AddPostgresPlatformMultiDatabaseWithControlPlaneAndList_RegistersGlobalSchedulerServices",
      "category": "Incursa.Platform.Postgres",
      "tags": [],
      "summary": "When control plane registration is used, then global scheduler services are available.",
      "intent": "Ensure global scheduler registrations are wired for control plane environments.",
      "scenario": "Given AddPostgresPlatformMultiDatabaseWithControlPlaneAndList called with valid options.",
      "behavior": "Then the global scheduler, outbox store, and lease factory can be resolved.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/ControlPlaneGlobalSchedulerTests.cs",
        "line": 31,
        "member": "Incursa.Platform.Postgres.Tests.ControlPlaneGlobalSchedulerTests.AddPostgresPlatformMultiDatabaseWithControlPlaneAndList_RegistersGlobalSchedulerServices"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.InMemory.Tests:Incursa.Platform.Tests.InMemoryInboxTimeBehaviorTests.ClaimAsync_RespectsFakeTimeProvider",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When claim Async Respects Fake Time Provider, then it behaves as expected.",
      "intent": "Document expected behavior for claim Async Respects Fake Time Provider.",
      "scenario": "Given claim Async Respects Fake Time Provider.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.InMemory.Tests/InMemoryInboxTimeBehaviorTests.cs",
        "line": 30,
        "member": "Incursa.Platform.Tests.InMemoryInboxTimeBehaviorTests.ClaimAsync_RespectsFakeTimeProvider"
      },
      "status": "compliant",
      "project": "Incursa.Platform.InMemory.Tests"
    },
    {
      "testId": "Incursa.Platform.InMemory.Tests:Incursa.Platform.Tests.InMemoryOutboxTimeBehaviorTests.ClaimDueAsync_RespectsFakeTimeProvider",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When claim Due Async Respects Fake Time Provider, then it behaves as expected.",
      "intent": "Document expected behavior for claim Due Async Respects Fake Time Provider.",
      "scenario": "Given claim Due Async Respects Fake Time Provider.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.InMemory.Tests/InMemoryOutboxTimeBehaviorTests.cs",
        "line": 30,
        "member": "Incursa.Platform.Tests.InMemoryOutboxTimeBehaviorTests.ClaimDueAsync_RespectsFakeTimeProvider"
      },
      "status": "compliant",
      "project": "Incursa.Platform.InMemory.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.ControlPlaneSchemaBundleTests.ControlPlaneBundle_AddsControlPlaneSchema_OnTopOfTenantBundle",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When control Plane Bundle Adds Control Plane Schema On Top Of Tenant Bundle, then it behaves as expected.",
      "intent": "Document expected behavior for control Plane Bundle Adds Control Plane Schema On Top Of Tenant Bundle.",
      "scenario": "Given control Plane Bundle Adds Control Plane Schema On Top Of Tenant Bundle.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/ControlPlaneSchemaBundleTests.cs",
        "line": 70,
        "member": "Incursa.Platform.Tests.ControlPlaneSchemaBundleTests.ControlPlaneBundle_AddsControlPlaneSchema_OnTopOfTenantBundle"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.ControlPlaneSchemaBundleTests.TenantBundle_CreatesFanoutTables",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When tenant Bundle Creates Fanout Tables, then it behaves as expected.",
      "intent": "Document expected behavior for tenant Bundle Creates Fanout Tables.",
      "scenario": "Given tenant Bundle Creates Fanout Tables.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/ControlPlaneSchemaBundleTests.cs",
        "line": 55,
        "member": "Incursa.Platform.Tests.ControlPlaneSchemaBundleTests.TenantBundle_CreatesFanoutTables"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.ControlPlaneSchemaBundleTests.TenantBundle_DoesNotInclude_ControlPlaneSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When tenant Bundle Does Not Include Control Plane Schema, then it behaves as expected.",
      "intent": "Document expected behavior for tenant Bundle Does Not Include Control Plane Schema.",
      "scenario": "Given tenant Bundle Does Not Include Control Plane Schema.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/ControlPlaneSchemaBundleTests.cs",
        "line": 37,
        "member": "Incursa.Platform.Tests.ControlPlaneSchemaBundleTests.TenantBundle_DoesNotInclude_ControlPlaneSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureDistributedLockSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the distributed lock schema is ensured with a custom schema, then the table is created there.",
      "intent": "Verify distributed lock deployment honors the configured schema name.",
      "scenario": "Given EnsureDistributedLockSchemaAsync is called with the \"platform\" schema and table name \"DistributedLock\".",
      "behavior": "The DistributedLock table is present in the custom schema.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/CustomSchemaIntegrationTests.cs",
        "line": 49,
        "member": "Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureDistributedLockSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureFanoutSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the fanout schema is ensured with a custom schema, then policy and cursor tables are created there.",
      "intent": "Verify fanout deployment honors the configured schema name.",
      "scenario": "Given EnsureFanoutSchemaAsync is called with the \"platform\" schema and custom table names.",
      "behavior": "FanoutPolicy and FanoutCursor tables are present in the custom schema.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/CustomSchemaIntegrationTests.cs",
        "line": 260,
        "member": "Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureFanoutSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureInboxSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the inbox schema is ensured with a custom schema, then the Inbox table is created there.",
      "intent": "Verify inbox deployment honors the configured schema name.",
      "scenario": "Given EnsureInboxSchemaAsync is called with the \"platform\" schema and table name \"Inbox\".",
      "behavior": "The Inbox table is present in the custom schema.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/CustomSchemaIntegrationTests.cs",
        "line": 133,
        "member": "Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureInboxSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureInboxWorkQueueSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the inbox work-queue schema is ensured with a custom schema, then inbox objects are created there.",
      "intent": "Verify inbox work-queue deployment honors the configured schema name.",
      "scenario": "Given EnsureInboxSchemaAsync and EnsureInboxWorkQueueSchemaAsync are called with the \"platform\" schema.",
      "behavior": "The Inbox table is present in the custom schema.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/CustomSchemaIntegrationTests.cs",
        "line": 229,
        "member": "Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureInboxWorkQueueSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureLeaseSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the lease schema is ensured with a custom schema, then the lease table is created there.",
      "intent": "Verify lease deployment honors the configured schema name.",
      "scenario": "Given EnsureLeaseSchemaAsync is called with the \"platform\" schema and table name \"Lease\".",
      "behavior": "The Lease table is present in the custom schema.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/CustomSchemaIntegrationTests.cs",
        "line": 76,
        "member": "Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureLeaseSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureOutboxSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the outbox schema is ensured with a custom schema, then outbox tables are created there.",
      "intent": "Verify outbox deployment honors the configured schema name.",
      "scenario": "Given EnsureOutboxSchemaAsync is called with the \"platform\" schema and table name \"Outbox\".",
      "behavior": "The Outbox and OutboxState tables are present in the custom schema.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/CustomSchemaIntegrationTests.cs",
        "line": 103,
        "member": "Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureOutboxSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureSchedulerSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the scheduler schema is ensured with a custom schema, then scheduler tables are created there.",
      "intent": "Verify scheduler deployment honors the configured schema name.",
      "scenario": "Given EnsureSchedulerSchemaAsync is called with the \"platform\" schema and custom table names.",
      "behavior": "Jobs, Timers, JobRuns, and SchedulerState tables are present in the custom schema.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/CustomSchemaIntegrationTests.cs",
        "line": 160,
        "member": "Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureSchedulerSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureWorkQueueSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the work-queue schema is ensured with a custom schema, then work-queue objects use that schema.",
      "intent": "Verify work-queue deployment honors the configured schema name.",
      "scenario": "Given EnsureOutboxSchemaAsync and EnsureWorkQueueSchemaAsync are called with the \"platform\" schema.",
      "behavior": "The Outbox table is present in the custom schema.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/CustomSchemaIntegrationTests.cs",
        "line": 198,
        "member": "Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureWorkQueueSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.CustomSchemaNames_WorkCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When creating scheduler tables in a custom schema, then tables and indexes use the custom names.",
      "intent": "Verify scheduler schema respects custom schema and table names.",
      "scenario": "Given EnsureSchedulerSchemaAsync is called with schema custom_test and custom table names.",
      "behavior": "CustomJobs, CustomJobRuns, and CustomTimers tables exist with the expected index name.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 319,
        "member": "Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.CustomSchemaNames_WorkCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.DatabaseSchema_AllRequiredTablesExist",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "Given core schemas are deployed, then all required tables exist.",
      "intent": "Verify core schema deployment creates the expected tables.",
      "scenario": "Given Outbox, Inbox, Scheduler, and Fanout schemas ensured in the infra schema.",
      "behavior": "Each expected core table is present in infra.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 59,
        "member": "Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.DatabaseSchema_AllRequiredTablesExist"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.DatabaseSchema_RequiredIndexesExist",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When verifying schema indexes, then required work-queue and uniqueness indexes exist.",
      "intent": "Validate required indexes are created for core tables.",
      "scenario": "Given the infra schema with Outbox, Inbox, Jobs, Timers, and JobRuns tables.",
      "behavior": "All expected indexes are present in PostgreSQL metadata.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 284,
        "member": "Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.DatabaseSchema_RequiredIndexesExist"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.InboxTable_HasCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the Inbox table, then all required columns and types match.",
      "intent": "Validate the Inbox table shape matches the expected schema.",
      "scenario": "Given the infra.Inbox table created by schema deployment.",
      "behavior": "Each required Inbox column exists with the expected PostgreSQL data type.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 250,
        "member": "Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.InboxTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.JobRunsTable_HasCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the JobRuns table, then all required columns and types match.",
      "intent": "Validate the JobRuns table shape matches the expected schema.",
      "scenario": "Given the infra.JobRuns table created by schema deployment.",
      "behavior": "Each required JobRuns column exists with the expected PostgreSQL data type.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 216,
        "member": "Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.JobRunsTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.JobsTable_HasCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the Jobs table, then all required columns and types match.",
      "intent": "Validate the Jobs table shape matches the expected schema.",
      "scenario": "Given the infra.Jobs table created by schema deployment.",
      "behavior": "Each required Jobs column exists with the expected PostgreSQL data type.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 152,
        "member": "Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.JobsTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.OutboxTable_HasCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the Outbox table, then all required columns and types match.",
      "intent": "Validate the Outbox table shape matches the expected schema.",
      "scenario": "Given the infra.Outbox table created by schema deployment.",
      "behavior": "Each required Outbox column exists with the expected PostgreSQL data type.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 117,
        "member": "Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.OutboxTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.TimersTable_HasCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the Timers table, then all required columns and types match.",
      "intent": "Validate the Timers table shape matches the expected schema.",
      "scenario": "Given the infra.Timers table created by schema deployment.",
      "behavior": "Each required Timers column exists with the expected PostgreSQL data type.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 181,
        "member": "Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.TimersTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.WorkQueueColumns_ExistAfterMigration",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When checking the Outbox table after work-queue migration, then work-queue columns exist.",
      "intent": "Confirm work-queue columns are present after migration.",
      "scenario": "Given the infra.Outbox table created by schema deployment.",
      "behavior": "Status, LockedUntil, and OwnerToken columns are present.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 351,
        "member": "Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.WorkQueueColumns_ExistAfterMigration"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddPostgresOutbox_WithSchemaDeploymentDisabled_DoesNotRegisterSchemaService",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When schema deployment is disabled, then Postgres outbox does not register schema services.",
      "intent": "Validate service registration is skipped when schema deployment is off.",
      "scenario": "Given a ServiceCollection and PostgresOutboxOptions with EnableSchemaDeployment set to false.",
      "behavior": "The service collection lacks IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService registrations.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 52,
        "member": "Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddPostgresOutbox_WithSchemaDeploymentDisabled_DoesNotRegisterSchemaService"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddPostgresOutbox_WithSchemaDeploymentEnabled_RegistersSchemaService",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When schema deployment is enabled, then Postgres outbox registers schema completion and background services.",
      "intent": "Validate service registration for the outbox schema deployment path.",
      "scenario": "Given a ServiceCollection and PostgresOutboxOptions with EnableSchemaDeployment set to true.",
      "behavior": "The service collection contains IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService registrations.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 29,
        "member": "Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddPostgresOutbox_WithSchemaDeploymentEnabled_RegistersSchemaService"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddPostgresPlatformMultiDatabaseWithControlPlaneAndList_WithSchemaDeploymentEnabled_RegistersSchemaService",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When control-plane schema deployment is enabled, then schema services are registered.",
      "intent": "Confirm control-plane multi-database registration wires schema deployment services.",
      "scenario": "Given a ServiceCollection, tenant list, and control-plane options with EnableSchemaDeployment set to true.",
      "behavior": "IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService are registered.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 154,
        "member": "Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddPostgresPlatformMultiDatabaseWithControlPlaneAndList_WithSchemaDeploymentEnabled_RegistersSchemaService"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddPostgresPlatformMultiDatabaseWithList_WithSchemaDeploymentDisabled_DoesNotRegisterSchemaService",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When list-based schema deployment is disabled, then schema services are not registered.",
      "intent": "Confirm list-based multi-database registration skips schema deployment services.",
      "scenario": "Given a ServiceCollection, one PlatformDatabase entry, and enableSchemaDeployment set to false.",
      "behavior": "IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService are absent.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 190,
        "member": "Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddPostgresPlatformMultiDatabaseWithList_WithSchemaDeploymentDisabled_DoesNotRegisterSchemaService"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddPostgresPlatformMultiDatabaseWithList_WithSchemaDeploymentEnabled_RegistersSchemaService",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When list-based multi-database schema deployment is enabled, then schema services are registered.",
      "intent": "Confirm list-based multi-database registration wires schema deployment services.",
      "scenario": "Given a ServiceCollection, one PlatformDatabase entry, and enableSchemaDeployment set to true.",
      "behavior": "IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService are registered.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 125,
        "member": "Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddPostgresPlatformMultiDatabaseWithList_WithSchemaDeploymentEnabled_RegistersSchemaService"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.DatabaseSchemaCompletion_CoordinatesStateCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When SetCompleted is called, then SchemaDeploymentCompleted finishes successfully.",
      "intent": "Verify schema completion signaling transitions the task to a completed state.",
      "scenario": "Given a new DatabaseSchemaCompletion instance with an incomplete task.",
      "behavior": "The completion task becomes completed with status RanToCompletion.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 108,
        "member": "Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.DatabaseSchemaCompletion_CoordinatesStateCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.SchemaCompletion_RegisteredSeparatelyFromBackgroundService",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When schema deployment is enabled, then schema completion is registered separately from the background service.",
      "intent": "Ensure completion services are singletons independent of the hosted service registration.",
      "scenario": "Given AddPostgresOutbox is called with EnableSchemaDeployment set to true.",
      "behavior": "IDatabaseSchemaCompletion and DatabaseSchemaCompletion are singletons and the background service is registered.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 75,
        "member": "Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.SchemaCompletion_RegisteredSeparatelyFromBackgroundService"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.FanoutCoordinatorIntegrationTests.FanoutSlices_CanJoinDownstreamMessagesIdempotently",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When fanout slices are joined, then completed steps are idempotent and correlation ids remain consistent.",
      "intent": "Verify join-store idempotency for downstream fan-in tracking.",
      "scenario": "Given three fanout slices sharing one correlation id and a join expecting three steps.",
      "behavior": "CompletedSteps stays at three after replay and all outbox messages share the same correlation id.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/FanoutCoordinatorIntegrationTests.cs",
        "line": 201,
        "member": "Incursa.Platform.Tests.FanoutCoordinatorIntegrationTests.FanoutSlices_CanJoinDownstreamMessagesIdempotently"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_RedispatchesAbandonedSlices",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When slices are abandoned, then subsequent runs redispatch them.",
      "intent": "Verify abandoned slices are eligible for redispatch.",
      "scenario": "Given a static planner with one analytics slice and an in-memory lease factory.",
      "behavior": "Two runs dispatch two messages and payloads include tenant-7.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/FanoutCoordinatorIntegrationTests.cs",
        "line": 130,
        "member": "Incursa.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_RedispatchesAbandonedSlices"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_RespectsActiveLeaseAndRecoversAfterExpiry",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a lease is already held, then the coordinator skips dispatch until the lease expires.",
      "intent": "Verify lease gating and recovery behavior for fanout coordination.",
      "scenario": "Given a pre-acquired lease for fanout:billing and a planner with one slice.",
      "behavior": "The first run dispatches 0, a later run dispatches 1, and one outbox row is created.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/FanoutCoordinatorIntegrationTests.cs",
        "line": 93,
        "member": "Incursa.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_RespectsActiveLeaseAndRecoversAfterExpiry"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_SkipsCompletedSlicesAfterCursorAdvances",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When cursors are marked completed, then subsequent runs skip those slices.",
      "intent": "Verify cursor advancement prevents redispatch of completed slices.",
      "scenario": "Given a sharded planner with two shards and cursors marked completed for both.",
      "behavior": "The initial run dispatches two slices and the follow-up run dispatches zero.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/FanoutCoordinatorIntegrationTests.cs",
        "line": 164,
        "member": "Incursa.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_SkipsCompletedSlicesAfterCursorAdvances"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.GlobalControlPlaneRoutingTests.GlobalAliases_RouteToControlPlane",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When global Aliases Route To Control Plane, then it behaves as expected.",
      "intent": "Document expected behavior for global Aliases Route To Control Plane.",
      "scenario": "Given global Aliases Route To Control Plane.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/GlobalControlPlaneRoutingTests.cs",
        "line": 39,
        "member": "Incursa.Platform.Tests.GlobalControlPlaneRoutingTests.GlobalAliases_RouteToControlPlane"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxCleanupTests.CleanupService_GracefullyHandles_MissingTable",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the inbox table is missing, then the cleanup service runs without recreating it.",
      "intent": "Verify cleanup handles missing tables without side effects.",
      "scenario": "Given the inbox table is dropped and the cleanup service runs with a short interval.",
      "behavior": "The service completes and the inbox table still does not exist.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxCleanupTests.cs",
        "line": 249,
        "member": "Incursa.Platform.Tests.InboxCleanupTests.CleanupService_GracefullyHandles_MissingTable"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxCleanupTests.Cleanup_DeletesOldProcessedMessages",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When cleanup runs with a seven-day retention period, then only old processed messages are deleted.",
      "intent": "Verify cleanup deletes processed rows older than the retention window.",
      "scenario": "Given one processed message older than 7 days, one recent processed message, and one unprocessed message.",
      "behavior": "Cleanup deletes only the old processed row and leaves the recent and unprocessed rows intact.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxCleanupTests.cs",
        "line": 55,
        "member": "Incursa.Platform.Tests.InboxCleanupTests.Cleanup_DeletesOldProcessedMessages"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxCleanupTests.Cleanup_RespectsRetentionPeriod",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When cleanup uses a 10-day retention period, then only messages older than 10 days are deleted.",
      "intent": "Verify cleanup uses the retention cutoff to select deletions.",
      "scenario": "Given processed messages at 30, 15, 7, 3, and 1 days old.",
      "behavior": "Two oldest rows are deleted and the three newest rows remain.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxCleanupTests.cs",
        "line": 185,
        "member": "Incursa.Platform.Tests.InboxCleanupTests.Cleanup_RespectsRetentionPeriod"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxCleanupTests.Cleanup_WithNoOldMessages_DeletesNothing",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "Given only recent processed messages, then cleanup deletes nothing.",
      "intent": "Verify cleanup leaves processed rows inside the retention window.",
      "scenario": "Given a single processed message with ProcessedUtc within the retention window.",
      "behavior": "Deleted count is 0 and the row remains.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxCleanupTests.cs",
        "line": 137,
        "member": "Incursa.Platform.Tests.InboxCleanupTests.Cleanup_WithNoOldMessages_DeletesNothing"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_RotatesOwnerTokensAcrossRuns",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When RunOnceAsync executes across multiple runs, then owner tokens rotate between runs.",
      "intent": "Verify each dispatch run uses a new owner token.",
      "scenario": "Given a stub store with two messages and two sequential dispatcher runs.",
      "behavior": "Two distinct owner tokens are recorded across the runs.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxDispatcherTests.cs",
        "line": 288,
        "member": "Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_RotatesOwnerTokensAcrossRuns"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithFailingHandler_AbandonsWithBackoffPolicy",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a handler fails and a backoff policy is configured, then the message is abandoned with that delay.",
      "intent": "Verify backoff delays are applied during abandon.",
      "scenario": "Given a stub work store, a failing handler, and a backoff policy returning five seconds.",
      "behavior": "The message is abandoned once with the configured delay and no failures are recorded.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxDispatcherTests.cs",
        "line": 208,
        "member": "Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithFailingHandler_AbandonsWithBackoffPolicy"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithFailingHandler_RetriesWithBackoff",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a handler throws, then RunOnceAsync abandons the message back to Seen.",
      "intent": "Verify handler failures result in a retryable abandon.",
      "scenario": "Given an enqueued failing-topic message and a handler that throws.",
      "behavior": "The processed count is 1 and the message status returns to Seen.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxDispatcherTests.cs",
        "line": 166,
        "member": "Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithFailingHandler_RetriesWithBackoff"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithNoHandlerForTopic_MarksMessageAsDead",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When no handler exists for a message topic, then RunOnceAsync marks the message Dead.",
      "intent": "Verify missing handlers move the message to Dead.",
      "scenario": "Given an enqueued unknown-topic message and a resolver with no handlers.",
      "behavior": "The processed count is 1 and the database status is Dead for msg-2.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxDispatcherTests.cs",
        "line": 125,
        "member": "Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithNoHandlerForTopic_MarksMessageAsDead"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithNoMessages_ReturnsZero",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "Given no inbox messages, then RunOnceAsync returns 0 processed items.",
      "intent": "Verify the dispatcher reports zero when no work is available.",
      "scenario": "Given an inbox work store and resolver with no enqueued messages.",
      "behavior": "The processed count is 0.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxDispatcherTests.cs",
        "line": 57,
        "member": "Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithNoMessages_ReturnsZero"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithPoisonMessage_FailsInsteadOfRetrying",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a message exceeds max attempts, then RunOnceAsync fails it instead of retrying.",
      "intent": "Verify poison messages are failed once they exceed the retry limit.",
      "scenario": "Given a failing handler, a stub message at attempt 5, and maxAttempts set to 5.",
      "behavior": "The message is recorded as failed and no abandon entries are created.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxDispatcherTests.cs",
        "line": 248,
        "member": "Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithPoisonMessage_FailsInsteadOfRetrying"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithValidMessage_ProcessesSuccessfully",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a queued message has a matching handler, then RunOnceAsync processes it and marks it Done.",
      "intent": "Verify successful dispatch updates the inbox status to Done.",
      "scenario": "Given an enqueued test-topic message and a resolver with a matching handler.",
      "behavior": "The processed count is 1 and the database status is Done for msg-1.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxDispatcherTests.cs",
        "line": 84,
        "member": "Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithValidMessage_ProcessesSuccessfully"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxIntegrationTests.CompleteInboxWorkflow_DirectServiceUsage_WorksEndToEnd",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "Given a direct inbox workflow, then AlreadyProcessed transitions from false to true and the row is Done.",
      "intent": "Verify end-to-end inbox processing with direct PostgresInboxService usage.",
      "scenario": "Given a PostgresInboxService configured with infra.Inbox and a test message id.",
      "behavior": "The first AlreadyProcessedAsync is false, after MarkProcessing/MarkProcessed it is true, and ProcessedUtc is set.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxIntegrationTests.cs",
        "line": 48,
        "member": "Incursa.Platform.Tests.InboxIntegrationTests.CompleteInboxWorkflow_DirectServiceUsage_WorksEndToEnd"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxIntegrationTests.ConcurrentAccess_WithMultipleThreads_HandledSafely",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When multiple threads call AlreadyProcessedAsync concurrently, then one row is created with attempts tracked.",
      "intent": "Verify concurrent deduplication records a single row and increments Attempts.",
      "scenario": "Given ten concurrent tasks invoking AlreadyProcessedAsync for the same message id.",
      "behavior": "All calls return false, only one row exists, and Attempts equals the task count.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxIntegrationTests.cs",
        "line": 138,
        "member": "Incursa.Platform.Tests.InboxIntegrationTests.ConcurrentAccess_WithMultipleThreads_HandledSafely"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxIntegrationTests.PoisonMessageWorkflow_MarkingAsDead_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a message is marked dead after processing starts, then its status is Dead and ProcessedUtc stays null.",
      "intent": "Verify poison-message handling in the inbox workflow.",
      "scenario": "Given a PostgresInboxService and a message marked Processing then Dead.",
      "behavior": "The database row shows Status Dead and no ProcessedUtc value.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxIntegrationTests.cs",
        "line": 96,
        "member": "Incursa.Platform.Tests.InboxIntegrationTests.PoisonMessageWorkflow_MarkingAsDead_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxWorkStoreTests.AbandonAsync_WithClaimedMessage_ReturnsToSeen",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When abandoning a claimed message, then its status returns to Seen.",
      "intent": "Verify abandon releases the claim and resets the status.",
      "scenario": "Given a message claimed by an owner token.",
      "behavior": "Status is Seen and OwnerToken is cleared.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxWorkStoreTests.cs",
        "line": 182,
        "member": "Incursa.Platform.Tests.InboxWorkStoreTests.AbandonAsync_WithClaimedMessage_ReturnsToSeen"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxWorkStoreTests.AckAsync_WithClaimedMessage_MarksAsDone",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When acknowledging a claimed message, then its status becomes Done.",
      "intent": "Verify acknowledgements finalize the inbox row.",
      "scenario": "Given a message claimed by an owner token.",
      "behavior": "Status is Done, OwnerToken is cleared, and ProcessedUtc is set.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxWorkStoreTests.cs",
        "line": 145,
        "member": "Incursa.Platform.Tests.InboxWorkStoreTests.AckAsync_WithClaimedMessage_MarksAsDone"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithAvailableMessage_ClaimsSuccessfully",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a message is available, then ClaimAsync claims it and marks it Processing.",
      "intent": "Verify claims update inbox status and ownership.",
      "scenario": "Given one enqueued message and a new owner token.",
      "behavior": "The message id is returned and the row shows Status Processing with the owner token.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxWorkStoreTests.cs",
        "line": 77,
        "member": "Incursa.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithAvailableMessage_ClaimsSuccessfully"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithConcurrentWorkers_EnsuresExclusiveClaims",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When two workers claim concurrently, then only one receives the message.",
      "intent": "Verify claim exclusivity under concurrent workers.",
      "scenario": "Given one enqueued message and two owner tokens claiming at the same time.",
      "behavior": "Exactly one claim result contains the message id.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxWorkStoreTests.cs",
        "line": 114,
        "member": "Incursa.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithConcurrentWorkers_EnsuresExclusiveClaims"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithNoMessages_ReturnsEmpty",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "Given an empty inbox, then ClaimAsync returns no message ids.",
      "intent": "Verify claim behavior when no work is available.",
      "scenario": "Given an inbox work store with no enqueued messages.",
      "behavior": "The claimed id list is empty.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxWorkStoreTests.cs",
        "line": 54,
        "member": "Incursa.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithNoMessages_ReturnsEmpty"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxWorkStoreTests.FailAsync_WithClaimedMessage_MarksAsDead",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When failing a claimed message, then its status becomes Dead.",
      "intent": "Verify failure handling marks the message as Dead.",
      "scenario": "Given a message claimed by an owner token and a failure reason.",
      "behavior": "Status is Dead and OwnerToken is cleared.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxWorkStoreTests.cs",
        "line": 218,
        "member": "Incursa.Platform.Tests.InboxWorkStoreTests.FailAsync_WithClaimedMessage_MarksAsDead"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxWorkStoreTests.GetAsync_WithInvalidMessageId_ThrowsException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When requesting a missing message id, then GetAsync throws InvalidOperationException.",
      "intent": "Verify missing messages raise an exception.",
      "scenario": "Given an inbox store with no message matching \"non-existent\".",
      "behavior": "An InvalidOperationException is thrown.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxWorkStoreTests.cs",
        "line": 321,
        "member": "Incursa.Platform.Tests.InboxWorkStoreTests.GetAsync_WithInvalidMessageId_ThrowsException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxWorkStoreTests.GetAsync_WithValidMessageId_ReturnsMessage",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "Given a valid message id, then GetAsync returns the stored inbox message.",
      "intent": "Verify message retrieval by id returns stored fields.",
      "scenario": "Given one enqueued message with id \"msg-1\".",
      "behavior": "The returned message matches the stored fields and has Attempt 1.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxWorkStoreTests.cs",
        "line": 291,
        "member": "Incursa.Platform.Tests.InboxWorkStoreTests.GetAsync_WithValidMessageId_ReturnsMessage"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.InboxWorkStoreTests.OwnerTokenEnforcement_OnlyAllowsOperationsByOwner",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a non-owner attempts to acknowledge a claim, then the row remains Processing.",
      "intent": "Verify owner token enforcement for state transitions.",
      "scenario": "Given a message claimed by one owner and an ack attempt by a different owner.",
      "behavior": "Status stays Processing and the OwnerToken remains the original owner.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/InboxWorkStoreTests.cs",
        "line": 254,
        "member": "Incursa.Platform.Tests.InboxWorkStoreTests.OwnerTokenEnforcement_OnlyAllowsOperationsByOwner"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenAllStepsCompleted_MarksJoinAsCompleted",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When all join steps are completed, then the join remains in a completed state.",
      "intent": "Confirm the wait handler leaves a completed join unchanged.",
      "scenario": "Given a join expecting two steps with both steps marked completed.",
      "behavior": "CompletedSteps equals ExpectedSteps after handling the wait message.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/JoinWaitHandlerTests.cs",
        "line": 123,
        "member": "Incursa.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenAllStepsCompleted_MarksJoinAsCompleted"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenAnyStepFailed_MarksJoinFailed",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When any join step fails and failure propagation is enabled, then the join is marked failed.",
      "intent": "Validate failure propagation for join steps.",
      "scenario": "Given a join with one completed step, one failed step, and FailIfAnyStepFailed enabled.",
      "behavior": "The join status is updated to Failed.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/JoinWaitHandlerTests.cs",
        "line": 168,
        "member": "Incursa.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenAnyStepFailed_MarksJoinFailed"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenJoinNotReady_ThrowsJoinNotReadyException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the join has incomplete steps, then the handler throws JoinNotReadyException.",
      "intent": "Validate that the wait handler blocks until the join is complete.",
      "scenario": "Given a join expecting three steps with only one completed and FailIfAnyStepFailed enabled.",
      "behavior": "HandleAsync raises JoinNotReadyException.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/JoinWaitHandlerTests.cs",
        "line": 87,
        "member": "Incursa.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenJoinNotReady_ThrowsJoinNotReadyException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.LeaseTests.AcquireAsync_WithExpiredLease_SucceedsAndReturnsNewExpiry",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a lease has expired, then a new owner can acquire it and receives a new expiry.",
      "intent": "Verify acquisition succeeds after lease expiration.",
      "scenario": "Given a short-lived lease is acquired, allowed to expire, and then re-acquired by a new owner.",
      "behavior": "The second acquisition succeeds with serverUtcNow set and a non-null leaseUntilUtc.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/LeaseTests.cs",
        "line": 120,
        "member": "Incursa.Platform.Tests.LeaseTests.AcquireAsync_WithExpiredLease_SucceedsAndReturnsNewExpiry"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.LeaseTests.AcquireAsync_WithFreeResource_SucceedsAndReturnsServerTime",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When acquiring a free lease, then the acquisition succeeds and returns server time and expiry.",
      "intent": "Verify acquisition succeeds for an unused lease name.",
      "scenario": "Given a new lease name, an owner, and a 30-second lease duration.",
      "behavior": "The lease is acquired, serverUtcNow is set, and leaseUntilUtc is shortly after server time.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/LeaseTests.cs",
        "line": 52,
        "member": "Incursa.Platform.Tests.LeaseTests.AcquireAsync_WithFreeResource_SucceedsAndReturnsServerTime"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.LeaseTests.AcquireAsync_WithOccupiedResource_FailsAndReturnsServerTime",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When acquiring an already-held lease, then the acquisition fails and returns server time.",
      "intent": "Verify acquisition fails for an occupied lease.",
      "scenario": "Given owner1 already holds the lease and owner2 attempts to acquire it.",
      "behavior": "The second acquisition fails, serverUtcNow is set, and leaseUntilUtc is null.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/LeaseTests.cs",
        "line": 86,
        "member": "Incursa.Platform.Tests.LeaseTests.AcquireAsync_WithOccupiedResource_FailsAndReturnsServerTime"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.LeaseTests.RenewAsync_WithExpiredLease_FailsAndReturnsServerTime",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When renewing after the lease expires, then the renewal fails and returns no expiry.",
      "intent": "Verify renewal fails for an expired lease.",
      "scenario": "Given a short lease is acquired, allowed to expire, and then renewed by the same owner.",
      "behavior": "Renewed is false, serverUtcNow is set, and leaseUntilUtc is null.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/LeaseTests.cs",
        "line": 230,
        "member": "Incursa.Platform.Tests.LeaseTests.RenewAsync_WithExpiredLease_FailsAndReturnsServerTime"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.LeaseTests.RenewAsync_WithValidOwner_SucceedsAndExtendsLease",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When renewing with the current owner, then the lease is extended.",
      "intent": "Verify renewal succeeds for the lease holder.",
      "scenario": "Given a lease acquired by an owner and a subsequent renew attempt by the same owner.",
      "behavior": "Renewal succeeds, server time advances, and the lease expiry moves forward.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/LeaseTests.cs",
        "line": 158,
        "member": "Incursa.Platform.Tests.LeaseTests.RenewAsync_WithValidOwner_SucceedsAndExtendsLease"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.LeaseTests.RenewAsync_WithWrongOwner_FailsAndReturnsServerTime",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When renewing with a different owner, then the renewal fails and no expiry is returned.",
      "intent": "Verify renewal fails for a non-owner.",
      "scenario": "Given owner1 holds the lease and owner2 attempts renewal.",
      "behavior": "Renewed is false, serverUtcNow is set, and leaseUntilUtc is null.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/LeaseTests.cs",
        "line": 196,
        "member": "Incursa.Platform.Tests.LeaseTests.RenewAsync_WithWrongOwner_FailsAndReturnsServerTime"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.MetricsSchemaTests.MetricDef_Table_Should_Exist",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "Given the metrics schema is deployed, then the MetricDef table exists.",
      "intent": "Verify MetricDef is created by the metrics schema deployment.",
      "scenario": "Given a database initialized with EnsureMetricsSchemaAsync.",
      "behavior": "INFORMATION_SCHEMA reports one MetricDef table in the infra schema.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/MetricsSchemaTests.cs",
        "line": 52,
        "member": "Incursa.Platform.Tests.MetricsSchemaTests.MetricDef_Table_Should_Exist"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.MetricsSchemaTests.MetricPointMinute_Table_Should_Exist",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "Given the metrics schema is deployed, then the MetricPointMinute table exists.",
      "intent": "Verify MetricPointMinute is created by the metrics schema deployment.",
      "scenario": "Given a database initialized with EnsureMetricsSchemaAsync.",
      "behavior": "INFORMATION_SCHEMA reports one MetricPointMinute table in the infra schema.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/MetricsSchemaTests.cs",
        "line": 100,
        "member": "Incursa.Platform.Tests.MetricsSchemaTests.MetricPointMinute_Table_Should_Exist"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.MetricsSchemaTests.MetricSeries_Table_Should_Exist",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "Given the metrics schema is deployed, then the MetricSeries table exists.",
      "intent": "Verify MetricSeries is created by the metrics schema deployment.",
      "scenario": "Given a database initialized with EnsureMetricsSchemaAsync.",
      "behavior": "INFORMATION_SCHEMA reports one MetricSeries table in the infra schema.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/MetricsSchemaTests.cs",
        "line": 76,
        "member": "Incursa.Platform.Tests.MetricsSchemaTests.MetricSeries_Table_Should_Exist"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.ListRegistration_WiresControlPlaneAndDiscoversDatabases",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "Given list-based registration, then control-plane configuration and tenant discovery are wired correctly.",
      "intent": "Verify list-based registration wires control-plane settings and discovery outputs.",
      "scenario": "Given two tenant databases, a control-plane database, and a service provider built with list registration.",
      "behavior": "Control-plane settings are populated and discovery/store providers return both tenant databases.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 57,
        "member": "Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.ListRegistration_WiresControlPlaneAndDiscoversDatabases"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_Discovery_MultipleTenants",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When dispatching for multiple discovery-registered tenants, then each tenant message is processed.",
      "intent": "Verify multi-tenant outbox dispatch with discovery-based registration.",
      "scenario": "Given two tenant databases, discovery-based registration, and a capturing outbox handler.",
      "behavior": "Each outbox table records one processed row after dispatch.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 175,
        "member": "Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_Discovery_MultipleTenants"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_Discovery_SingleTenant",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When dispatching for a single discovery-registered tenant, then its message is processed.",
      "intent": "Verify single-tenant outbox dispatch with discovery-based registration.",
      "scenario": "Given one tenant database, discovery-based registration, and a capturing outbox handler.",
      "behavior": "The tenant outbox table records one processed message.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 213,
        "member": "Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_Discovery_SingleTenant"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_List_MultipleTenants",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When dispatching for multiple list-registered tenants, then each tenant message is processed.",
      "intent": "Verify multi-tenant outbox dispatch with list-based registration.",
      "scenario": "Given two tenant databases, list-based registration, and a capturing outbox handler.",
      "behavior": "Each tenant payload is handled and each outbox table records one processed row.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 101,
        "member": "Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_List_MultipleTenants"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_List_SingleTenant",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When dispatching for a single list-registered tenant, then its message is processed.",
      "intent": "Verify single-tenant outbox dispatch with list-based registration.",
      "scenario": "Given one tenant database, list-based registration, and a capturing outbox handler.",
      "behavior": "The tenant outbox table records one processed message.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 140,
        "member": "Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_List_SingleTenant"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.MultiInboxDispatcherLeaseTests.MultiInboxDispatcher_WithLease_PreventsConcurrentProcessing",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When two dispatchers share a lease router, then only one processes the inbox batch.",
      "intent": "Verify lease-based coordination prevents concurrent processing.",
      "scenario": "Given five inbox messages, a Postgres lease factory, and two dispatchers running concurrently.",
      "behavior": "One dispatcher processes all five messages while the other processes none, totaling five handled messages.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/MultiInboxDispatcherLeaseTests.cs",
        "line": 52,
        "member": "Incursa.Platform.Tests.MultiInboxDispatcherLeaseTests.MultiInboxDispatcher_WithLease_PreventsConcurrentProcessing"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.MultiInboxDispatcherLeaseTests.MultiInboxDispatcher_WithoutLease_AllowsProcessing",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When no lease router is configured, then the dispatcher processes all available messages.",
      "intent": "Verify processing continues without lease coordination.",
      "scenario": "Given three inbox messages and a dispatcher created without a lease router.",
      "behavior": "The dispatcher processes all three messages and the handler records three payloads.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/MultiInboxDispatcherLeaseTests.cs",
        "line": 176,
        "member": "Incursa.Platform.Tests.MultiInboxDispatcherLeaseTests.MultiInboxDispatcher_WithoutLease_AllowsProcessing"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.MultiOutboxDispatcherLeaseTests.MultiOutboxDispatcher_WithLease_PreventsConcurrentProcessing",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When two dispatchers share a lease router, then only one processes the outbox batch.",
      "intent": "Verify lease-based coordination prevents concurrent processing.",
      "scenario": "Given five outbox messages, a Postgres lease factory, and two dispatchers running concurrently.",
      "behavior": "One dispatcher processes all five messages while the other processes none.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/MultiOutboxDispatcherLeaseTests.cs",
        "line": 44,
        "member": "Incursa.Platform.Tests.MultiOutboxDispatcherLeaseTests.MultiOutboxDispatcher_WithLease_PreventsConcurrentProcessing"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.MultiOutboxDispatcherLeaseTests.MultiOutboxDispatcher_WithoutLease_AllowsProcessing",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When no lease router is configured, then the dispatcher processes all available messages.",
      "intent": "Verify dispatch proceeds without lease coordination.",
      "scenario": "Given three outbox messages and a dispatcher created without a lease router.",
      "behavior": "The dispatcher processes all three messages and the handler records three payloads.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/MultiOutboxDispatcherLeaseTests.cs",
        "line": 160,
        "member": "Incursa.Platform.Tests.MultiOutboxDispatcherLeaseTests.MultiOutboxDispatcher_WithoutLease_AllowsProcessing"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.MultiOutboxDispatcherTests.MultiOutboxDispatcher_ProcessesMessagesFromMultipleStores",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When dispatching across multiple stores, then messages are processed from each store.",
      "intent": "Verify the dispatcher iterates across store providers and handles messages from each.",
      "scenario": "Given two schemas with one ready outbox message each and a shared handler.",
      "behavior": "Two runs process both messages and both outbox rows are marked processed.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/MultiOutboxDispatcherTests.cs",
        "line": 42,
        "member": "Incursa.Platform.Tests.MultiOutboxDispatcherTests.MultiOutboxDispatcher_ProcessesMessagesFromMultipleStores"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.MultiOutboxDispatcherTests.MultiOutboxDispatcher_WithDrainFirstStrategy_DrainsOneStoreBeforeMoving",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When using the drain-first strategy, then one store is drained before moving on.",
      "intent": "Verify the drain-first selection strategy exhausts one store before switching.",
      "scenario": "Given one store with three ready messages and a drain-first strategy.",
      "behavior": "Three runs process messages and the fourth run finds no work.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/MultiOutboxDispatcherTests.cs",
        "line": 159,
        "member": "Incursa.Platform.Tests.MultiOutboxDispatcherTests.MultiOutboxDispatcher_WithDrainFirstStrategy_DrainsOneStoreBeforeMoving"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxCleanupTests.CleanupService_GracefullyHandles_MissingTable",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the outbox table is missing, then the cleanup service runs without recreating it.",
      "intent": "Verify cleanup handles missing tables without side effects.",
      "scenario": "Given the outbox table is dropped and the cleanup service runs with a short interval.",
      "behavior": "The service completes and the outbox table still does not exist.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxCleanupTests.cs",
        "line": 228,
        "member": "Incursa.Platform.Tests.OutboxCleanupTests.CleanupService_GracefullyHandles_MissingTable"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxCleanupTests.Cleanup_DeletesOldProcessedMessages",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When cleanup runs with a seven-day retention period, then only old processed messages are deleted.",
      "intent": "Verify cleanup removes processed rows older than the retention window.",
      "scenario": "Given one processed message older than 7 days, one recent processed message, and one unprocessed message.",
      "behavior": "Cleanup deletes only the old processed row and leaves the recent and unprocessed rows intact.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxCleanupTests.cs",
        "line": 48,
        "member": "Incursa.Platform.Tests.OutboxCleanupTests.Cleanup_DeletesOldProcessedMessages"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxCleanupTests.Cleanup_RespectsRetentionPeriod",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When cleanup uses a 10-day retention period, then only messages older than 10 days are deleted.",
      "intent": "Verify retention cutoffs are respected during cleanup.",
      "scenario": "Given processed messages at 30, 15, 7, 3, and 1 days old.",
      "behavior": "Two oldest rows are deleted and the three newest rows remain.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxCleanupTests.cs",
        "line": 170,
        "member": "Incursa.Platform.Tests.OutboxCleanupTests.Cleanup_RespectsRetentionPeriod"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxCleanupTests.Cleanup_WithNoOldMessages_DeletesNothing",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When only recent processed messages exist, then cleanup deletes nothing.",
      "intent": "Verify cleanup does not remove rows inside the retention window.",
      "scenario": "Given a processed message with ProcessedAt within the retention period.",
      "behavior": "Deleted count is 0 and the row remains.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxCleanupTests.cs",
        "line": 128,
        "member": "Incursa.Platform.Tests.OutboxCleanupTests.Cleanup_WithNoOldMessages_DeletesNothing"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithAllParameters_EnqueuesCorrectMessage",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When EnqueueJoinWaitAsync is called with full parameters, then the join.wait message contains them.",
      "intent": "Verify join-wait payload fields are populated from all provided parameters.",
      "scenario": "Given a join id with on-complete and on-fail topics/payloads.",
      "behavior": "The stored payload matches the join id, flags, and on-complete/on-fail values.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxExtensionsTests.cs",
        "line": 68,
        "member": "Incursa.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithAllParameters_EnqueuesCorrectMessage"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithMinimalParameters_EnqueuesCorrectMessage",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When EnqueueJoinWaitAsync is called with minimal parameters, then optional fields remain null.",
      "intent": "Verify defaults are applied when optional join-wait parameters are omitted.",
      "scenario": "Given only a join id passed to EnqueueJoinWaitAsync.",
      "behavior": "The payload has the join id, FailIfAnyStepFailed true, and null optional fields.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxExtensionsTests.cs",
        "line": 107,
        "member": "Incursa.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithMinimalParameters_EnqueuesCorrectMessage"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_DefaultBackoff_ExponentialWithJitter",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When computing default backoff delays, then ranges grow exponentially with jitter and remain bounded.",
      "intent": "Verify the default backoff timing policy and caps.",
      "scenario": "Given backoff calculations for attempts 1, 2, 3, and 10.",
      "behavior": "Early attempts fall within expected jitter ranges and the maximum stays under two minutes.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 484,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_DefaultBackoff_ExponentialWithJitter"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_HandlerThrows_ReschedulesWithBackoff",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a handler throws and attempts remain, then RunOnceAsync reschedules with backoff.",
      "intent": "Verify handler exceptions reschedule messages with delay.",
      "scenario": "Given a handler configured to throw and a message with RetryCount 2.",
      "behavior": "The message is rescheduled with a positive delay and the error is captured.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 217,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_HandlerThrows_ReschedulesWithBackoff"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsAtCorrectLevels",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When processing a mix of success and missing-handler messages, then logs include info, debug, and warning entries.",
      "intent": "Verify log levels reflect batch, message, and missing-handler outcomes.",
      "scenario": "Given a capturing logger, one handled Test.Topic message, and one Unknown.Topic message.",
      "behavior": "The batch is processed and logs include Information for batch work, Debug for message processing, and Warning for missing handlers.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 401,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsAtCorrectLevels"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a message is processed successfully, then the handler and store record dispatch.",
      "intent": "Verify the success path invokes handlers and records dispatch.",
      "scenario": "Given a dispatcher with a matching handler and a test store containing one message.",
      "behavior": "Processed count is 1, the handler is invoked, and the store records dispatch.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 311,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsErrors_WhenHandlerFails",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a handler fails, then the dispatcher captures the error and reschedules the message.",
      "intent": "Verify handler failures produce reschedule entries with errors.",
      "scenario": "Given a handler configured to throw and a test store with one message.",
      "behavior": "The handler is invoked and the store records a reschedule with the exception message.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 356,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsErrors_WhenHandlerFails"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_NoHandler_MarksAsFailed",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a message has no registered handler, then RunOnceAsync marks it failed.",
      "intent": "Verify missing handlers cause failures with the correct error.",
      "scenario": "Given an empty resolver and a test store with one Unknown.Topic message.",
      "behavior": "Processed count is 1 and the store records a failure with a missing-handler error.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 176,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_NoHandler_MarksAsFailed"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_ProcessSingleMessage_Success",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a message has a matching handler, then RunOnceAsync dispatches it and returns 1.",
      "intent": "Verify successful single-message dispatch through the handler.",
      "scenario": "Given a test store with one Test.Topic message and a resolver with a matching handler.",
      "behavior": "Processed count is 1, the handler receives the message, and the store records dispatch.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 133,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_ProcessSingleMessage_Success"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_WithPoisonMessage_FailsWhenMaxAttemptsReached",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a failing message reaches the max attempts threshold, then it is marked failed.",
      "intent": "Verify poison messages fail once the retry limit is reached.",
      "scenario": "Given a dispatcher with maxAttempts 3 and a message at RetryCount 2 that throws.",
      "behavior": "The message is recorded as failed and no reschedule occurs.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 264,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_WithPoisonMessage_FailsWhenMaxAttemptsReached"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxHandlerTests.OutboxHandlerResolver_CaseInsensitive",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When resolving with different casing, then the handler is still found.",
      "intent": "Verify case-insensitive topic lookup in the resolver.",
      "scenario": "Given a resolver with a single handler for Email.Send.",
      "behavior": "TryGet succeeds for email.send and EMAIL.SEND while preserving the handler topic.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 106,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.OutboxHandlerResolver_CaseInsensitive"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxHandlerTests.OutboxHandlerResolver_WithHandlers_ResolvesCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "Given a resolver with multiple handlers, then known topics resolve and unknown topics do not.",
      "intent": "Verify resolver matching for known and unknown topics.",
      "scenario": "Given handlers for Email.Send, SMS.Send, and Push.Notification.",
      "behavior": "TryGet returns true for Email.Send and SMS.Send, and false for NonExistent.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 71,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.OutboxHandlerResolver_WithHandlers_ResolvesCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxHandlerTests.ServiceCollection_AddOutboxHandler_Factory_RegistersHandler",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When adding an outbox handler factory, then it is registered as a singleton IOutboxHandler.",
      "intent": "Verify handler factory registration uses singleton lifetime.",
      "scenario": "Given a ServiceCollection configured with time abstractions and a factory delegate.",
      "behavior": "The registration stores an implementation factory with singleton lifetime.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 551,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.ServiceCollection_AddOutboxHandler_Factory_RegistersHandler"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxHandlerTests.ServiceCollection_AddOutboxHandler_RegistersHandler",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When adding an outbox handler type, then it is registered as a singleton IOutboxHandler.",
      "intent": "Verify handler type registration uses singleton lifetime.",
      "scenario": "Given a ServiceCollection configured with time abstractions.",
      "behavior": "The registration uses TestHandler as the implementation type with singleton lifetime.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 522,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.ServiceCollection_AddOutboxHandler_RegistersHandler"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxJoinTests.AttachMessageToJoinAsync_CalledTwice_IsIdempotent",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When attaching the same message twice, then only one association exists.",
      "intent": "Verify AttachMessageToJoinAsync is idempotent.",
      "scenario": "Given a join and a single outbox message attached twice.",
      "behavior": "The join member table contains a single row for that pair.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 187,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.AttachMessageToJoinAsync_CalledTwice_IsIdempotent"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxJoinTests.AttachMessageToJoinAsync_WithValidIds_CreatesAssociation",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When attaching a message to a join, then the association is stored.",
      "intent": "Verify join member rows are created for attached messages.",
      "scenario": "Given an existing join and a created outbox message id.",
      "behavior": "The join member table has one row for the join/message pair.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 154,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.AttachMessageToJoinAsync_WithValidIds_CreatesAssociation"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxJoinTests.CompleteJoinWorkflow_WithAllStepsCompleted_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When all steps complete, then the join reports completed status and counts.",
      "intent": "Verify the full join workflow records completion for every step.",
      "scenario": "Given a join expecting three steps with three attached messages all completed.",
      "behavior": "CompletedSteps is 3, FailedSteps is 0, and Status is Completed.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 340,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.CompleteJoinWorkflow_WithAllStepsCompleted_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxJoinTests.CompleteJoinWorkflow_WithSomeStepsFailed_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When some steps fail, then the join reports failed status and counts.",
      "intent": "Verify the join workflow records failures alongside completions.",
      "scenario": "Given a join expecting three steps with two completed and one failed.",
      "behavior": "Status is Failed with CompletedSteps 2 and FailedSteps 1.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 384,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.CompleteJoinWorkflow_WithSomeStepsFailed_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxJoinTests.CreateJoinAsync_WithValidParameters_CreatesJoin",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When CreateJoinAsync is called with valid parameters, then a pending join is created.",
      "intent": "Verify join creation populates expected metadata and counters.",
      "scenario": "Given a tenant id, expected steps, and metadata payload.",
      "behavior": "The join has a non-empty id, pending status, zero counts, and a recent CreatedUtc.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 86,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.CreateJoinAsync_WithValidParameters_CreatesJoin"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxJoinTests.GetJoinAsync_WithExistingJoin_ReturnsJoin",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When retrieving an existing join, then GetJoinAsync returns it.",
      "intent": "Verify joins can be fetched by id.",
      "scenario": "Given a join created via CreateJoinAsync.",
      "behavior": "The retrieved join matches the created JoinId and ExpectedSteps.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 116,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.GetJoinAsync_WithExistingJoin_ReturnsJoin"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxJoinTests.GetJoinAsync_WithNonExistentJoin_ReturnsNull",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When retrieving a non-existent join, then GetJoinAsync returns null.",
      "intent": "Verify unknown join ids are handled gracefully.",
      "scenario": "Given a randomly generated JoinIdentifier.",
      "behavior": "The retrieved join is null.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 138,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.GetJoinAsync_WithNonExistentJoin_ReturnsNull"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxJoinTests.GetJoinMessagesAsync_WithMultipleMessages_ReturnsAllMessageIds",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a join has multiple attached messages, then GetJoinMessagesAsync returns all ids.",
      "intent": "Verify join message enumeration returns every attached message.",
      "scenario": "Given a join with three attached outbox messages.",
      "behavior": "The returned list contains all three message ids.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 309,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.GetJoinMessagesAsync_WithMultipleMessages_ReturnsAllMessageIds"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_CalledTwiceForSameMessage_IsIdempotent",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IncrementCompletedAsync is called twice for the same message, then counts are not duplicated.",
      "intent": "Verify completion increments are idempotent per message.",
      "scenario": "Given a join with one attached message completed twice.",
      "behavior": "CompletedSteps remains 1 and FailedSteps remains 0.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 422,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_CalledTwiceForSameMessage_IsIdempotent"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_WhenTotalWouldExceedExpected_DoesNotOverCount",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When completed steps would exceed expected, then counts do not overrun expected steps.",
      "intent": "Verify completion counting is capped at ExpectedSteps.",
      "scenario": "Given a join expecting two steps with three attached messages completed.",
      "behavior": "CompletedSteps remains at 2 and FailedSteps remains 0.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 472,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_WhenTotalWouldExceedExpected_DoesNotOverCount"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_WithValidMessage_IncrementsCount",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When incrementing completion for an attached message, then CompletedSteps increases.",
      "intent": "Verify completion updates counters and timestamps.",
      "scenario": "Given a join with an attached message.",
      "behavior": "CompletedSteps is 1, FailedSteps is 0, and LastUpdatedUtc advances.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 225,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_WithValidMessage_IncrementsCount"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxJoinTests.IncrementFailedAsync_CalledTwiceForSameMessage_IsIdempotent",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IncrementFailedAsync is called twice for the same message, then counts are not duplicated.",
      "intent": "Verify failure increments are idempotent per message.",
      "scenario": "Given a join with one attached message failed twice.",
      "behavior": "FailedSteps remains 1 and CompletedSteps remains 0.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 447,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.IncrementFailedAsync_CalledTwiceForSameMessage_IsIdempotent"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxJoinTests.IncrementFailedAsync_WithValidMessage_IncrementsCount",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When incrementing failure for an attached message, then FailedSteps increases.",
      "intent": "Verify failure updates counters and timestamps.",
      "scenario": "Given a join with an attached message.",
      "behavior": "FailedSteps is 1, CompletedSteps is 0, and LastUpdatedUtc advances.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 254,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.IncrementFailedAsync_WithValidMessage_IncrementsCount"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxJoinTests.OutboxAck_AutomaticallyReportsJoinCompletion",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When outbox messages are acked, then join completion counts are incremented.",
      "intent": "Verify outbox acknowledgements report join completion automatically.",
      "scenario": "Given a join expecting two messages attached to the outbox.",
      "behavior": "CompletedSteps moves from 1 after the first ack to 2 after the second.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 507,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.OutboxAck_AutomaticallyReportsJoinCompletion"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxJoinTests.OutboxAck_MultipleAcksForSameMessage_IsIdempotent",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the same message is acked multiple times, then join counts are not over-incremented.",
      "intent": "Verify outbox ack reporting is idempotent per message.",
      "scenario": "Given a join expecting one message that is acked twice.",
      "behavior": "CompletedSteps remains 1 and FailedSteps remains 0.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 578,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.OutboxAck_MultipleAcksForSameMessage_IsIdempotent"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxJoinTests.OutboxFail_AutomaticallyReportsJoinFailure",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When outbox messages fail, then join failure counts are incremented.",
      "intent": "Verify outbox failures report join failures automatically.",
      "scenario": "Given a join expecting two messages where one is acked and one fails.",
      "behavior": "CompletedSteps is 1 and FailedSteps is 1.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 545,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.OutboxFail_AutomaticallyReportsJoinFailure"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxJoinTests.UpdateStatusAsync_WithValidStatus_UpdatesJoinStatus",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When UpdateStatusAsync sets a status, then the join status is updated.",
      "intent": "Verify status updates persist for joins.",
      "scenario": "Given a pending join that is updated to Completed.",
      "behavior": "The stored join status is Completed.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 283,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.UpdateStatusAsync_WithValidStatus_UpdatesJoinStatus"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxWorkQueueTests.ConcurrentClaim_MultipleWorkers_NoOverlap",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When two workers claim concurrently, then claimed sets do not overlap.",
      "intent": "Verify concurrent claims are exclusive per work item.",
      "scenario": "Given ten ready items and two workers claiming up to five each.",
      "behavior": "Claimed ids are disjoint and total claimed does not exceed ten.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxWorkQueueTests.cs",
        "line": 156,
        "member": "Incursa.Platform.Tests.OutboxWorkQueueTests.ConcurrentClaim_MultipleWorkers_NoOverlap"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxWorkQueueTests.InvalidOwnerOperations_DoNotAffectItems",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a non-owner attempts to ack items, then item status is unchanged.",
      "intent": "Verify owner token enforcement for state changes.",
      "scenario": "Given claimed items owned by one token and an ack attempt with another token.",
      "behavior": "Status remains InProgress for the claimed items.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxWorkQueueTests.cs",
        "line": 180,
        "member": "Incursa.Platform.Tests.OutboxWorkQueueTests.InvalidOwnerOperations_DoNotAffectItems"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxAbandon_WithValidOwner_ReturnsToReady",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When abandoning claimed items with the correct owner, then they return to Ready.",
      "intent": "Verify abandon resets status for claimed items.",
      "scenario": "Given claimed items and the matching owner token.",
      "behavior": "Status returns to Ready for each claimed item.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxWorkQueueTests.cs",
        "line": 106,
        "member": "Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxAbandon_WithValidOwner_ReturnsToReady"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxAck_WithValidOwner_MarksDoneAndProcessed",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When acking claimed items with the correct owner, then they are marked done and processed.",
      "intent": "Verify acknowledgements update status and processing flags.",
      "scenario": "Given claimed items and the matching owner token.",
      "behavior": "Status becomes Done and IsProcessed is true for each claimed item.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxWorkQueueTests.cs",
        "line": 89,
        "member": "Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxAck_WithValidOwner_MarksDoneAndProcessed"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxClaim_WithBatchSize_RespectsLimit",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When batch size is smaller than ready items, then ClaimAsync respects the limit.",
      "intent": "Verify ClaimAsync honors the requested batch size.",
      "scenario": "Given five ready outbox items and a batch size of two.",
      "behavior": "ClaimAsync returns exactly two ids.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxWorkQueueTests.cs",
        "line": 74,
        "member": "Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxClaim_WithBatchSize_RespectsLimit"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxClaim_WithReadyItems_ReturnsClaimedIds",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When ready items are available, then ClaimAsync returns their ids.",
      "intent": "Verify ready outbox work items can be claimed.",
      "scenario": "Given three ready outbox items and a new owner token.",
      "behavior": "ClaimAsync returns all three ids and they match the inserted items.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxWorkQueueTests.cs",
        "line": 57,
        "member": "Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxClaim_WithReadyItems_ReturnsClaimedIds"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxFail_WithValidOwner_MarksAsFailed",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When failing claimed items with the correct owner, then they are marked Failed.",
      "intent": "Verify failure marks the work items as failed.",
      "scenario": "Given claimed items and the matching owner token.",
      "behavior": "Status becomes Failed for each claimed item.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxWorkQueueTests.cs",
        "line": 122,
        "member": "Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxFail_WithValidOwner_MarksAsFailed"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxReapExpired_WithExpiredItems_ReturnsToReady",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a claim expires, then ReapExpired returns items to Ready.",
      "intent": "Verify expired leases are reaped back to Ready.",
      "scenario": "Given a claimed item with a 1-second lease that is allowed to expire.",
      "behavior": "ReapExpiredAsync resets the item status to Ready.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxWorkQueueTests.cs",
        "line": 138,
        "member": "Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxReapExpired_WithExpiredItems_ReturnsToReady"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxWorkerTests.Manual_AbandonOperation_Works",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AbandonAsync is called manually, then items return to Ready.",
      "intent": "Verify manual abandon resets item status.",
      "scenario": "Given claimed items and the matching owner token.",
      "behavior": "Item status is Ready after abandon.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 137,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.Manual_AbandonOperation_Works"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_ConcurrentClaims_NoOverlap",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When multiple concurrent claims run, then claimed ids are unique.",
      "intent": "Verify concurrency does not allow duplicate claims.",
      "scenario": "Given ten ready items and five concurrent claimers.",
      "behavior": "All claimed ids are unique and total claimed does not exceed ten.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 254,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_ConcurrentClaims_NoOverlap"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_EmptyIdLists_NoErrors",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When work-queue operations receive empty id lists, then they complete without error.",
      "intent": "Verify empty operations are handled gracefully.",
      "scenario": "Given empty id lists for AckAsync, AbandonAsync, and FailAsync.",
      "behavior": "The operations complete without throwing exceptions.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 239,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_EmptyIdLists_NoErrors"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_IdempotentOperations_NoErrors",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AckAsync is called repeatedly, then the operation is idempotent.",
      "intent": "Verify repeated acknowledgements leave the item done.",
      "scenario": "Given claimed items and multiple AckAsync calls by the owner.",
      "behavior": "Items remain in Done status.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 204,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_IdempotentOperations_NoErrors"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_LeaseExpiration_AllowsReclaim",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a lease expires, then another owner can reclaim the item after reaping.",
      "intent": "Verify expired leases allow reclamation.",
      "scenario": "Given an item claimed with a 1-second lease, then reaped after expiry.",
      "behavior": "A second claim returns the same item id.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 155,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_LeaseExpiration_AllowsReclaim"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_RestartUsesNewOwnerTokenAfterReap",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a claim is reaped, then the new owner token is recorded on reclaim.",
      "intent": "Verify owner tokens update when items are reclaimed after expiry.",
      "scenario": "Given an item claimed by owner1, expired, reaped, and reclaimed by owner2.",
      "behavior": "The OwnerToken stored for the item matches owner2.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 179,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_RestartUsesNewOwnerTokenAfterReap"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_UnauthorizedOwner_CannotModify",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a non-owner attempts to modify items, then status remains InProgress.",
      "intent": "Verify owner token enforcement for acknowledgements.",
      "scenario": "Given items claimed by owner1 and an ack attempt by owner2.",
      "behavior": "Item status stays InProgress.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 222,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_UnauthorizedOwner_CannotModify"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxWorkerTests.Worker_ClaimsItemsCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When items are claimed, then they are marked InProgress.",
      "intent": "Verify claim operations update item status.",
      "scenario": "Given two ready outbox items and a claim call.",
      "behavior": "Claimed ids match the inserted items and their status is InProgress.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 116,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.Worker_ClaimsItemsCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxWorkerTests.Worker_ProcessesClaimedItems_AndAcknowledgesThem",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the worker processes claimed items, then it acknowledges them and marks them Done.",
      "intent": "Verify the worker processes and acknowledges all claimed items.",
      "scenario": "Given three ready outbox items and a running worker.",
      "behavior": "ProcessedItems contains all ids and their status is Done.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 74,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.Worker_ProcessesClaimedItems_AndAcknowledgesThem"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxWorkerTests.Worker_RespectsCancellationToken",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the worker is canceled, then it stops promptly.",
      "intent": "Verify cancellation short-circuits long processing delays.",
      "scenario": "Given a worker with a long processing delay and a cancellation token after one second.",
      "behavior": "StopAsync completes within five seconds.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 279,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.Worker_RespectsCancellationToken"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.OutboxWorkerTests.Worker_WithProcessingFailure_AbandonsItems",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When processing fails, then the worker abandons items back to Ready.",
      "intent": "Verify failures result in abandon rather than ack.",
      "scenario": "Given a worker configured to fail processing with two ready items.",
      "behavior": "Outbox items return to Ready status.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 95,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.Worker_WithProcessingFailure_AbandonsItems"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresAuditAdapterTests.WriteAndQueryByAnchorRoundTrip",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When write And Query By Anchor Round Trip, then it behaves as expected.",
      "intent": "Document expected behavior for write And Query By Anchor Round Trip.",
      "scenario": "Given write And Query By Anchor Round Trip.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresAuditAdapterTests.cs",
        "line": 43,
        "member": "Incursa.Platform.Tests.PostgresAuditAdapterTests.WriteAndQueryByAnchorRoundTrip"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresDapperTypeHandlerTests.AllTypesInSingleQuery_RoundTrip_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When all identifier columns are queried together, then each property matches its inserted value.",
      "intent": "Confirm multi-column mapping across all identifier type handlers.",
      "scenario": "Given handlers are registered and one row contains each identifier value.",
      "behavior": "The projected record returns every identifier unchanged.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresDapperTypeHandlerTests.cs",
        "line": 318,
        "member": "Incursa.Platform.Tests.PostgresDapperTypeHandlerTests.AllTypesInSingleQuery_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresDapperTypeHandlerTests.DatabaseIdentifier_RoundTrip_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a DatabaseIdentifier is stored, then Dapper returns the same database id.",
      "intent": "Verify Dapper mapping for DatabaseIdentifier UUIDs.",
      "scenario": "Given handlers are registered and a row is inserted with DatabaseIdColumn set.",
      "behavior": "The queried DatabaseIdentifier matches the inserted value.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresDapperTypeHandlerTests.cs",
        "line": 286,
        "member": "Incursa.Platform.Tests.PostgresDapperTypeHandlerTests.DatabaseIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresDapperTypeHandlerTests.InboxMessageIdentifier_RoundTrip_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an InboxMessageIdentifier is inserted, then Dapper reads the same identifier.",
      "intent": "Verify Dapper mapping for InboxMessageIdentifier UUIDs.",
      "scenario": "Given handlers are registered and a row is inserted with InboxMessageIdColumn set.",
      "behavior": "The queried InboxMessageIdentifier matches the inserted value.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresDapperTypeHandlerTests.cs",
        "line": 126,
        "member": "Incursa.Platform.Tests.PostgresDapperTypeHandlerTests.InboxMessageIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresDapperTypeHandlerTests.InstanceIdentifier_RoundTrip_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an InstanceIdentifier is stored, then Dapper reads the same instance id.",
      "intent": "Verify Dapper mapping for InstanceIdentifier UUIDs.",
      "scenario": "Given handlers are registered and a row is inserted with InstanceIdColumn set.",
      "behavior": "The queried InstanceIdentifier matches the inserted value.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresDapperTypeHandlerTests.cs",
        "line": 254,
        "member": "Incursa.Platform.Tests.PostgresDapperTypeHandlerTests.InstanceIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresDapperTypeHandlerTests.JoinIdentifier_RoundTrip_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a JoinIdentifier is stored, then Dapper returns the same join id.",
      "intent": "Verify Dapper mapping for JoinIdentifier UUIDs.",
      "scenario": "Given handlers are registered and a row is inserted with JoinIdColumn set.",
      "behavior": "The queried JoinIdentifier matches the inserted value.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresDapperTypeHandlerTests.cs",
        "line": 222,
        "member": "Incursa.Platform.Tests.PostgresDapperTypeHandlerTests.JoinIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresDapperTypeHandlerTests.NullableOwnerToken_RoundTrip_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a nullable OwnerToken is stored in a nullable column, then it is read back intact.",
      "intent": "Confirm nullable OwnerToken values are materialized correctly.",
      "scenario": "Given handlers are registered and a row is inserted with NullableOwnerTokenColumn set.",
      "behavior": "The nullable query result equals the inserted OwnerToken.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresDapperTypeHandlerTests.cs",
        "line": 93,
        "member": "Incursa.Platform.Tests.PostgresDapperTypeHandlerTests.NullableOwnerToken_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresDapperTypeHandlerTests.OutboxMessageIdentifier_RoundTrip_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an OutboxMessageIdentifier is inserted, then Dapper returns the same identifier.",
      "intent": "Verify Dapper mapping for OutboxMessageIdentifier UUIDs.",
      "scenario": "Given handlers are registered and a row is inserted with OutboxMessageIdColumn set.",
      "behavior": "The queried OutboxMessageIdentifier matches the inserted value.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresDapperTypeHandlerTests.cs",
        "line": 158,
        "member": "Incursa.Platform.Tests.PostgresDapperTypeHandlerTests.OutboxMessageIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresDapperTypeHandlerTests.OutboxWorkItemIdentifier_RoundTrip_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an OutboxWorkItemIdentifier is stored, then Dapper reads it back unchanged.",
      "intent": "Verify Dapper mapping for OutboxWorkItemIdentifier UUIDs.",
      "scenario": "Given handlers are registered and a row is inserted with OutboxWorkItemIdColumn set.",
      "behavior": "The queried OutboxWorkItemIdentifier matches the inserted value.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresDapperTypeHandlerTests.cs",
        "line": 190,
        "member": "Incursa.Platform.Tests.PostgresDapperTypeHandlerTests.OutboxWorkItemIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresDapperTypeHandlerTests.OwnerToken_RoundTrip_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a row is inserted with an OwnerToken, then Dapper returns the same token.",
      "intent": "Confirm the OwnerToken handler maps UUID values losslessly.",
      "scenario": "Given handlers are registered and a row is inserted with OwnerTokenColumn plus other GUID fields.",
      "behavior": "The OwnerToken query result matches the inserted token.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresDapperTypeHandlerTests.cs",
        "line": 61,
        "member": "Incursa.Platform.Tests.PostgresDapperTypeHandlerTests.OwnerToken_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresEmailDeliverySinkTests.RecordAttempt_WritesAttemptDetails",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an attempt is recorded, then attempt details are stored.",
      "intent": "Capture provider attempt details.",
      "scenario": "Given a failed attempt.",
      "behavior": "Stores status, attempt number, and provider details.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresEmailDeliverySinkTests.cs",
        "line": 83,
        "member": "Incursa.Platform.Tests.PostgresEmailDeliverySinkTests.RecordAttempt_WritesAttemptDetails"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresEmailDeliverySinkTests.RecordExternal_WritesExternalUpdate",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an external update is recorded, then provider metadata is stored.",
      "intent": "Capture webhook delivery updates.",
      "scenario": "Given a provider event id.",
      "behavior": "Stores provider event id and status.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresEmailDeliverySinkTests.cs",
        "line": 111,
        "member": "Incursa.Platform.Tests.PostgresEmailDeliverySinkTests.RecordExternal_WritesExternalUpdate"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresEmailDeliverySinkTests.RecordQueued_StoresCorrelationContext",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a correlation context is present, then correlation fields are stored.",
      "intent": "Capture ambient correlation metadata.",
      "scenario": "Given a correlation context in scope.",
      "behavior": "Stores correlation ids and tags.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresEmailDeliverySinkTests.cs",
        "line": 136,
        "member": "Incursa.Platform.Tests.PostgresEmailDeliverySinkTests.RecordQueued_StoresCorrelationContext"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresEmailDeliverySinkTests.RecordQueued_WritesQueuedEvent",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a message is queued, then a delivery event is recorded.",
      "intent": "Capture queued delivery events.",
      "scenario": "Given a new message.",
      "behavior": "Stores a queued event with payload and timestamp.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresEmailDeliverySinkTests.cs",
        "line": 65,
        "member": "Incursa.Platform.Tests.PostgresEmailDeliverySinkTests.RecordQueued_WritesQueuedEvent"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresEmailOutboxStoreTests.Dequeue_ReturnsPendingItemsInOrder",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When dequeue is called, then pending items are returned in enqueue order.",
      "intent": "Ensure due items are claimed in FIFO order.",
      "scenario": "Given two pending messages.",
      "behavior": "Returns items ordered by EnqueuedAtUtc and increments attempt count.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresEmailOutboxStoreTests.cs",
        "line": 86,
        "member": "Incursa.Platform.Tests.PostgresEmailOutboxStoreTests.Dequeue_ReturnsPendingItemsInOrder"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresEmailOutboxStoreTests.Enqueue_IsIdempotentForProviderAndMessageKey",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When enqueue is called twice for the same provider/key, then only one row is stored.",
      "intent": "Verify idempotent enqueue behavior.",
      "scenario": "Given a duplicate message key for the same provider.",
      "behavior": "Only one row exists in the outbox table.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresEmailOutboxStoreTests.cs",
        "line": 122,
        "member": "Incursa.Platform.Tests.PostgresEmailOutboxStoreTests.Enqueue_IsIdempotentForProviderAndMessageKey"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresEmailOutboxStoreTests.Enqueue_MarksMessageKey",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When enqueue is called, then the provider/message key is recorded.",
      "intent": "Verify idempotency key tracking.",
      "scenario": "Given an empty outbox and a new message.",
      "behavior": "AlreadyEnqueued returns true after enqueue.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresEmailOutboxStoreTests.cs",
        "line": 60,
        "member": "Incursa.Platform.Tests.PostgresEmailOutboxStoreTests.Enqueue_MarksMessageKey"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithHash_StoresHashCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AlreadyProcessedAsync is called with a hash, then the hash is stored.",
      "intent": "Verify the message hash is persisted with the inbox row.",
      "scenario": "Given a message id/source and a byte[] hash passed to AlreadyProcessedAsync.",
      "behavior": "The stored Hash value matches the provided hash.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresInboxServiceTests.cs",
        "line": 196,
        "member": "Incursa.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithHash_StoresHashCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithInvalidMessageId_ThrowsArgumentException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AlreadyProcessedAsync receives a null or empty message id, then it throws ArgumentException.",
      "intent": "Verify invalid message ids are rejected.",
      "scenario": "Given null or empty messageId inputs.",
      "behavior": "AlreadyProcessedAsync throws ArgumentException.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresInboxServiceTests.cs",
        "line": 222,
        "member": "Incursa.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithInvalidMessageId_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithInvalidSource_ThrowsArgumentException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AlreadyProcessedAsync receives a null or empty source, then it throws ArgumentException.",
      "intent": "Verify invalid sources are rejected.",
      "scenario": "Given null or empty source inputs.",
      "behavior": "AlreadyProcessedAsync throws ArgumentException.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresInboxServiceTests.cs",
        "line": 237,
        "member": "Incursa.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithInvalidSource_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithNewMessage_ReturnsFalseAndRecordsMessage",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AlreadyProcessedAsync is called for a new message, then it returns false and records the row.",
      "intent": "Verify new messages are inserted and reported as not processed.",
      "scenario": "Given a PostgresInboxService and a new message id/source.",
      "behavior": "AlreadyProcessedAsync returns false and one inbox row exists for the message id.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresInboxServiceTests.cs",
        "line": 39,
        "member": "Incursa.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithNewMessage_ReturnsFalseAndRecordsMessage"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithProcessedMessage_ReturnsTrue",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a message has been marked processed, then AlreadyProcessedAsync returns true.",
      "intent": "Verify processed messages are detected as already processed.",
      "scenario": "Given a message recorded via AlreadyProcessedAsync and then marked processed.",
      "behavior": "A subsequent AlreadyProcessedAsync call returns true.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresInboxServiceTests.cs",
        "line": 64,
        "member": "Incursa.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithProcessedMessage_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresInboxServiceTests.ConcurrentAlreadyProcessedAsync_WithSameMessage_HandledCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When multiple AlreadyProcessedAsync calls run concurrently, then one row exists with attempts tracked.",
      "intent": "Verify concurrent checks create a single inbox row and increment attempts.",
      "scenario": "Given five concurrent AlreadyProcessedAsync calls for the same message id.",
      "behavior": "All calls return false, one row exists, and Attempts equals 5.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresInboxServiceTests.cs",
        "line": 159,
        "member": "Incursa.Platform.Tests.PostgresInboxServiceTests.ConcurrentAlreadyProcessedAsync_WithSameMessage_HandledCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresInboxServiceTests.MarkDeadAsync_UpdatesStatus",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When MarkDeadAsync is called, then Status becomes Dead.",
      "intent": "Verify MarkDeadAsync marks messages as dead.",
      "scenario": "Given a message recorded via AlreadyProcessedAsync.",
      "behavior": "The inbox row Status is Dead.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresInboxServiceTests.cs",
        "line": 134,
        "member": "Incursa.Platform.Tests.PostgresInboxServiceTests.MarkDeadAsync_UpdatesStatus"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresInboxServiceTests.MarkProcessedAsync_SetsProcessedUtcAndStatus",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When MarkProcessedAsync is called, then ProcessedUtc is set and Status is Done.",
      "intent": "Verify MarkProcessedAsync updates completion fields.",
      "scenario": "Given a message recorded via AlreadyProcessedAsync.",
      "behavior": "ProcessedUtc is non-null and Status is Done in the inbox row.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresInboxServiceTests.cs",
        "line": 83,
        "member": "Incursa.Platform.Tests.PostgresInboxServiceTests.MarkProcessedAsync_SetsProcessedUtcAndStatus"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresInboxServiceTests.MarkProcessingAsync_UpdatesStatus",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When MarkProcessingAsync is called, then Status becomes Processing.",
      "intent": "Verify MarkProcessingAsync moves the message into processing state.",
      "scenario": "Given a message recorded via AlreadyProcessedAsync.",
      "behavior": "The inbox row Status is Processing.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresInboxServiceTests.cs",
        "line": 109,
        "member": "Incursa.Platform.Tests.PostgresInboxServiceTests.MarkProcessingAsync_UpdatesStatus"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresLeaseRunnerTests.AcquireAsync_WithAvailableLease_ReturnsRunnerInstance",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an available lease is acquired, then a runner is returned with valid state.",
      "intent": "Verify a new lease acquisition initializes runner identity and state.",
      "scenario": "Given a new lease name, owner, and a fake monotonic clock.",
      "behavior": "The runner is not lost, reflects the lease name/owner, and has an un-canceled token.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresLeaseRunnerTests.cs",
        "line": 50,
        "member": "Incursa.Platform.Tests.PostgresLeaseRunnerTests.AcquireAsync_WithAvailableLease_ReturnsRunnerInstance"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresLeaseRunnerTests.AcquireAsync_WithUnavailableLease_ReturnsNull",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a lease is already held, then a second acquisition attempt returns null.",
      "intent": "Confirm unavailable leases are not re-acquired by another owner.",
      "scenario": "Given owner1 holds the lease and owner2 attempts to acquire the same lease.",
      "behavior": "The second acquisition returns null.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresLeaseRunnerTests.cs",
        "line": 85,
        "member": "Incursa.Platform.Tests.PostgresLeaseRunnerTests.AcquireAsync_WithUnavailableLease_ReturnsNull"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresLeaseRunnerTests.DisposedRunner_DoesNotRenew",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a runner is disposed, then TryRenewNowAsync returns false.",
      "intent": "Verify renewal requests are rejected after disposal.",
      "scenario": "Given a runner that has been acquired and then disposed.",
      "behavior": "TryRenewNowAsync returns false.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresLeaseRunnerTests.cs",
        "line": 239,
        "member": "Incursa.Platform.Tests.PostgresLeaseRunnerTests.DisposedRunner_DoesNotRenew"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresLeaseRunnerTests.MonotonicRenewal_WithCustomRenewPercent_RenewsAtCorrectInterval",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When renewal is scheduled at 50% of the lease duration, then the runner stays valid past the midpoint.",
      "intent": "Confirm monotonic renewal timing honors a custom renew percentage.",
      "scenario": "Given a 10-second lease and renewPercent set to 0.5.",
      "behavior": "After waiting past the midpoint, IsLost is false and cancellation is not requested.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresLeaseRunnerTests.cs",
        "line": 201,
        "member": "Incursa.Platform.Tests.PostgresLeaseRunnerTests.MonotonicRenewal_WithCustomRenewPercent_RenewsAtCorrectInterval"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresLeaseRunnerTests.RenewTimer_UsesFakeMonotonicClockAcrossClockSkewAndGcPauses",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the monotonic clock jumps forward, then renewal scheduling advances using monotonic time.",
      "intent": "Validate renewal scheduling resilience to wall-clock skew and GC pauses.",
      "scenario": "Given a runner with a fake monotonic clock and access to the internal renew timer callback.",
      "behavior": "The next renew time advances with monotonic time and remains unchanged on immediate retry.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresLeaseRunnerTests.cs",
        "line": 272,
        "member": "Incursa.Platform.Tests.PostgresLeaseRunnerTests.RenewTimer_UsesFakeMonotonicClockAcrossClockSkewAndGcPauses"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresLeaseRunnerTests.ThrowIfLost_WhenLeaseIsValid_DoesNotThrow",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "Given a valid lease runner, then ThrowIfLost does not throw.",
      "intent": "Confirm loss checks are no-ops while the lease is valid.",
      "scenario": "Given a runner acquired with a 30-second lease duration.",
      "behavior": "ThrowIfLost completes without exception.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresLeaseRunnerTests.cs",
        "line": 169,
        "member": "Incursa.Platform.Tests.PostgresLeaseRunnerTests.ThrowIfLost_WhenLeaseIsValid_DoesNotThrow"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresLeaseRunnerTests.TryRenewNowAsync_WithValidRunner_SucceedsAndExtendsLease",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a valid runner renews, then TryRenewNowAsync succeeds and the runner remains valid.",
      "intent": "Verify manual renewal keeps the lease active.",
      "scenario": "Given a runner acquired for a new lease name and owner.",
      "behavior": "TryRenewNowAsync returns true and IsLost stays false.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresLeaseRunnerTests.cs",
        "line": 133,
        "member": "Incursa.Platform.Tests.PostgresLeaseRunnerTests.TryRenewNowAsync_WithValidRunner_SucceedsAndExtendsLease"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresOperationTrackerTests.AddEventAsync_CreatesOperationEvent",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddEventAsync is called, then an operation event row is created.",
      "intent": "Verify operation events are persisted.",
      "scenario": "Given an existing operation and a new event.",
      "behavior": "The operation events table contains the new event.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresOperationTrackerTests.cs",
        "line": 94,
        "member": "Incursa.Platform.Tests.PostgresOperationTrackerTests.AddEventAsync_CreatesOperationEvent"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresOperationTrackerTests.StartAsync_CreatesOperationRow",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When StartAsync is called, then a new operation row is created.",
      "intent": "Verify operations are persisted with pending status.",
      "scenario": "Given a tracker and a new operation name.",
      "behavior": "The operations table contains the new operation with status Pending.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresOperationTrackerTests.cs",
        "line": 64,
        "member": "Incursa.Platform.Tests.PostgresOperationTrackerTests.StartAsync_CreatesOperationRow"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresOperationWatcherTests.FindStalledAsync_ReturnsStalledOperations",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an operation is stale, then FindStalledAsync returns it.",
      "intent": "Verify stalled detection returns pending/running operations that are past the threshold.",
      "scenario": "Given an operation with an old UpdatedAtUtc timestamp.",
      "behavior": "The stalled list contains the operation.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresOperationWatcherTests.cs",
        "line": 62,
        "member": "Incursa.Platform.Tests.PostgresOperationWatcherTests.FindStalledAsync_ReturnsStalledOperations"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresOperationWatcherTests.MarkStalledAsync_UpdatesOperationStatus",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When MarkStalledAsync is called, then the operation is marked stalled.",
      "intent": "Verify stalled transitions update status and completion time.",
      "scenario": "Given an existing pending operation.",
      "behavior": "Status is set to Stalled and CompletedAtUtc is populated.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresOperationWatcherTests.cs",
        "line": 97,
        "member": "Incursa.Platform.Tests.PostgresOperationWatcherTests.MarkStalledAsync_UpdatesOperationStatus"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresOutboxServiceTests.Constructor_CreatesInstance",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When constructed with valid options, then the service is created and implements IOutbox.",
      "intent": "Verify the outbox service can be instantiated with valid options.",
      "scenario": "Given PostgresOutboxOptions and a null logger instance.",
      "behavior": "The instance is non-null and assignable to IOutbox.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 52,
        "member": "Incursa.Platform.Tests.PostgresOutboxServiceTests.Constructor_CreatesInstance"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_MultipleMessages_AllInsertedSuccessfully",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When multiple messages are enqueued in a transaction, then all rows are inserted.",
      "intent": "Verify batch enqueues insert all messages within the transaction.",
      "scenario": "Given three enqueue calls in the same transaction.",
      "behavior": "The outbox table contains three rows.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 201,
        "member": "Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_MultipleMessages_AllInsertedSuccessfully"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_Standalone_EnsuresTableExists",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When standalone enqueue runs with schema deployment enabled, then it creates the table and inserts the row.",
      "intent": "Verify schema deployment ensures the outbox table exists before enqueue.",
      "scenario": "Given a custom schema/table with EnableSchemaDeployment true and the table dropped.",
      "behavior": "The custom outbox table is created and contains the enqueued message.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 341,
        "member": "Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_Standalone_EnsuresTableExists"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_Standalone_MultipleMessages_AllInsertedSuccessfully",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When multiple standalone enqueue calls are made, then all rows are inserted.",
      "intent": "Verify multiple standalone enqueues insert all messages.",
      "scenario": "Given three distinct topics/payloads enqueued without a transaction.",
      "behavior": "The outbox table contains three matching rows.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 304,
        "member": "Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_Standalone_MultipleMessages_AllInsertedSuccessfully"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_Standalone_WithNullCorrelationId_InsertsMessageSuccessfully",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When standalone enqueue uses a null correlation id, then the message is inserted.",
      "intent": "Verify standalone enqueue handles null correlation ids.",
      "scenario": "Given a topic and payload with a null correlation id.",
      "behavior": "The outbox table contains one row matching the topic and payload.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 274,
        "member": "Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_Standalone_WithNullCorrelationId_InsertsMessageSuccessfully"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_Standalone_WithValidParameters_InsertsMessageToDatabase",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When using standalone enqueue, then the message is inserted with the correlation id.",
      "intent": "Verify standalone enqueue persists messages without an explicit transaction.",
      "scenario": "Given a topic, payload, and correlation id.",
      "behavior": "The outbox table contains one row matching the topic, payload, and correlation id.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 242,
        "member": "Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_Standalone_WithValidParameters_InsertsMessageToDatabase"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithCustomSchemaAndTable_InsertsMessageToCorrectTable",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When using a custom schema and table, then EnqueueAsync inserts into the custom table.",
      "intent": "Verify custom schema/table options are honored by enqueue.",
      "scenario": "Given a custom outbox service and a transaction scoped to the custom table.",
      "behavior": "The custom outbox table contains one row matching the topic and payload.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 94,
        "member": "Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithCustomSchemaAndTable_InsertsMessageToCorrectTable"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithNullCorrelationId_InsertsMessageSuccessfully",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When EnqueueAsync is called with a null correlation id, then the message is inserted.",
      "intent": "Verify null correlation ids do not block insertion.",
      "scenario": "Given a transaction and a message with a null correlation id.",
      "behavior": "The outbox table contains one row matching the topic and payload.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 135,
        "member": "Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithNullCorrelationId_InsertsMessageSuccessfully"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithNullTransaction_ThrowsNullReferenceException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When EnqueueAsync receives a null transaction, then it throws ArgumentNullException.",
      "intent": "Verify EnqueueAsync validates the transaction argument.",
      "scenario": "Given a null IDbTransaction argument.",
      "behavior": "EnqueueAsync throws ArgumentNullException.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 225,
        "member": "Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithNullTransaction_ThrowsNullReferenceException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithValidParameters_InsertsMessageToDatabase",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When EnqueueAsync is called in a transaction, then a message row is inserted.",
      "intent": "Verify transactional enqueue inserts a row with topic and payload.",
      "scenario": "Given an open connection, a transaction, and topic/payload/correlation id values.",
      "behavior": "The outbox table contains one row matching the topic and payload.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 65,
        "member": "Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithValidParameters_InsertsMessageToDatabase"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithValidParameters_SetsDefaultValues",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When EnqueueAsync inserts a message, then default fields are set.",
      "intent": "Verify default outbox values are populated on insert.",
      "scenario": "Given a new message enqueued in a transaction.",
      "behavior": "IsProcessed is false, ProcessedAt is null, RetryCount is 0, CreatedAt is recent, and MessageId is set.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 163,
        "member": "Incursa.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithValidParameters_SetsDefaultValues"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresOutboxStoreWhiteBoxTests.FailAsync_SetsFailureMetadata",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When fail Async Sets Failure Metadata, then it behaves as expected.",
      "intent": "Document expected behavior for fail Async Sets Failure Metadata.",
      "scenario": "Given fail Async Sets Failure Metadata.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresOutboxStoreWhiteBoxTests.cs",
        "line": 81,
        "member": "Incursa.Platform.Tests.PostgresOutboxStoreWhiteBoxTests.FailAsync_SetsFailureMetadata"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresOutboxStoreWhiteBoxTests.MarkDispatchedAsync_SetsProcessedFlags",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When mark Dispatched Async Sets Processed Flags, then it behaves as expected.",
      "intent": "Document expected behavior for mark Dispatched Async Sets Processed Flags.",
      "scenario": "Given mark Dispatched Async Sets Processed Flags.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresOutboxStoreWhiteBoxTests.cs",
        "line": 54,
        "member": "Incursa.Platform.Tests.PostgresOutboxStoreWhiteBoxTests.MarkDispatchedAsync_SetsProcessedFlags"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresOutboxStoreWhiteBoxTests.RescheduleAsync_IncrementsRetryCountAndSetsError",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When reschedule Async Increments Retry Count And Sets Error, then it behaves as expected.",
      "intent": "Document expected behavior for reschedule Async Increments Retry Count And Sets Error.",
      "scenario": "Given reschedule Async Increments Retry Count And Sets Error.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresOutboxStoreWhiteBoxTests.cs",
        "line": 110,
        "member": "Incursa.Platform.Tests.PostgresOutboxStoreWhiteBoxTests.RescheduleAsync_IncrementsRetryCountAndSetsError"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresSchedulerClientTests.Constructor_WithValidConnectionString_CreatesInstance",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When constructed with valid options, then the client is created and implements ISchedulerClient.",
      "intent": "Verify the scheduler client can be instantiated with valid options.",
      "scenario": "Given PostgresSchedulerOptions with a valid connection string.",
      "behavior": "The instance is non-null and assignable to ISchedulerClient.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresSchedulerClientTests.cs",
        "line": 54,
        "member": "Incursa.Platform.Tests.PostgresSchedulerClientTests.Constructor_WithValidConnectionString_CreatesInstance"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresSchedulerClientTests.CreateOrUpdateJobAsync_ExistingJob_UpdatesJob",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When updating an existing job, then the job is updated without duplication.",
      "intent": "Verify CreateOrUpdateJobAsync updates existing jobs.",
      "scenario": "Given a job created once and then updated with a new topic.",
      "behavior": "The Jobs table has one row and the topic matches the update.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresSchedulerClientTests.cs",
        "line": 185,
        "member": "Incursa.Platform.Tests.PostgresSchedulerClientTests.CreateOrUpdateJobAsync_ExistingJob_UpdatesJob"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresSchedulerClientTests.CreateOrUpdateJobAsync_NewJob_InsertsJob",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When creating a new job, then a job row is inserted.",
      "intent": "Verify CreateOrUpdateJobAsync inserts new jobs.",
      "scenario": "Given a job name, topic, and cron schedule that do not yet exist.",
      "behavior": "The Jobs table contains one row for the job name.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresSchedulerClientTests.cs",
        "line": 139,
        "member": "Incursa.Platform.Tests.PostgresSchedulerClientTests.CreateOrUpdateJobAsync_NewJob_InsertsJob"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresSchedulerClientTests.CreateOrUpdateJobAsync_WithNullPayload_SetsPayloadToNull",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a job is created without a payload, then the payload column is null.",
      "intent": "Verify null payloads are persisted as NULL.",
      "scenario": "Given CreateOrUpdateJobAsync called without a payload for a new job.",
      "behavior": "The Jobs row payload column is NULL.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresSchedulerClientTests.cs",
        "line": 162,
        "member": "Incursa.Platform.Tests.PostgresSchedulerClientTests.CreateOrUpdateJobAsync_WithNullPayload_SetsPayloadToNull"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresSchedulerClientTests.DeleteJobAsync_WithValidJobName_RemovesJob",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When deleting a job by name, then the job row is removed.",
      "intent": "Verify DeleteJobAsync removes jobs.",
      "scenario": "Given a job created and then deleted by name.",
      "behavior": "The Jobs table contains zero rows for the job name.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresSchedulerClientTests.cs",
        "line": 219,
        "member": "Incursa.Platform.Tests.PostgresSchedulerClientTests.DeleteJobAsync_WithValidJobName_RemovesJob"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresSchedulerClientTests.ScheduleTimerAsync_WithCustomTableNames_InsertsToCorrectTable",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When scheduling with custom table names, then the timer is inserted into the custom table.",
      "intent": "Verify custom schema/table names are honored for timers.",
      "scenario": "Given a scheduler client configured with custom schema and table names.",
      "behavior": "The custom timers table contains one row for the scheduled timer.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresSchedulerClientTests.cs",
        "line": 94,
        "member": "Incursa.Platform.Tests.PostgresSchedulerClientTests.ScheduleTimerAsync_WithCustomTableNames_InsertsToCorrectTable"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresSchedulerClientTests.ScheduleTimerAsync_WithValidParameters_InsertsTimerToDatabase",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When scheduling a timer, then a timer row is inserted into the database.",
      "intent": "Verify ScheduleTimerAsync persists timers to the Timers table.",
      "scenario": "Given a topic, payload, and due time in the near future.",
      "behavior": "The Timers table contains one row for the returned timer id and topic.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresSchedulerClientTests.cs",
        "line": 67,
        "member": "Incursa.Platform.Tests.PostgresSchedulerClientTests.ScheduleTimerAsync_WithValidParameters_InsertsTimerToDatabase"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.PostgresSchedulerClientTests.TriggerJobAsync_WithValidJobName_CreatesJobRun",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When triggering a job by name, then a job run row is created.",
      "intent": "Verify TriggerJobAsync creates job runs.",
      "scenario": "Given an existing job and a trigger call.",
      "behavior": "The JobRuns table contains at least one row for the job.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/PostgresSchedulerClientTests.cs",
        "line": 244,
        "member": "Incursa.Platform.Tests.PostgresSchedulerClientTests.TriggerJobAsync_WithValidJobName_CreatesJobRun"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_AfterLeaseReleased_CanAcquireAgain",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a lease is released, then acquiring the resource again succeeds.",
      "intent": "Verify release allows a new lease with a higher fencing token.",
      "scenario": "Given a resource acquired, disposed, and then acquired again.",
      "behavior": "The second lease is non-null with a fencing token greater than the first.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/SystemLeaseTests.cs",
        "line": 107,
        "member": "Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_AfterLeaseReleased_CanAcquireAgain"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_ReentrantWithSameOwnerToken_Succeeds",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When acquiring the same resource with the same owner token, then both acquisitions succeed.",
      "intent": "Verify reentrant acquisition with the same owner token is permitted.",
      "scenario": "Given two AcquireAsync calls for the same resource using the same owner token.",
      "behavior": "Both leases are non-null and the second fencing token exceeds the first.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/SystemLeaseTests.cs",
        "line": 237,
        "member": "Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_ReentrantWithSameOwnerToken_Succeeds"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_SameResourceTwice_SecondCallReturnsNull",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When acquiring the same resource twice, then the second call returns null.",
      "intent": "Verify lease acquisition is exclusive per resource.",
      "scenario": "Given one resource acquired and a second acquisition attempt for the same resource.",
      "behavior": "The second acquisition returns null.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/SystemLeaseTests.cs",
        "line": 84,
        "member": "Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_SameResourceTwice_SecondCallReturnsNull"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_WithCustomOwnerToken_UsesProvidedToken",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When acquiring with a custom owner token, then the lease uses the provided token.",
      "intent": "Verify caller-supplied owner tokens are honored.",
      "scenario": "Given a custom OwnerToken and a new resource name.",
      "behavior": "The acquired lease reports the provided owner token.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/SystemLeaseTests.cs",
        "line": 212,
        "member": "Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_WithCustomOwnerToken_UsesProvidedToken"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_WithDifferentResources_BothSucceed",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When acquiring leases for different resources, then both acquisitions succeed.",
      "intent": "Verify resource isolation across independent leases.",
      "scenario": "Given two distinct resource names and one lease factory.",
      "behavior": "Both leases are non-null with different resource names and owner tokens.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/SystemLeaseTests.cs",
        "line": 184,
        "member": "Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_WithDifferentResources_BothSucceed"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_WithValidResource_CanAcquireLease",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When acquiring a lease for a valid resource, then a lease is returned with expected metadata.",
      "intent": "Verify successful lease acquisition populates owner and fencing tokens.",
      "scenario": "Given a PostgresLeaseFactory, a new resource name, and a 30-second lease duration.",
      "behavior": "The lease is non-null with the resource name, non-empty owner token, and active cancellation token.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/SystemLeaseTests.cs",
        "line": 59,
        "member": "Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_WithValidResource_CanAcquireLease"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.SystemLeaseTests.ThrowIfLost_WhenLeaseIsValid_DoesNotThrow",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a lease is valid, then ThrowIfLost does not throw.",
      "intent": "Verify loss checks are no-ops for active leases.",
      "scenario": "Given a lease acquired for a resource.",
      "behavior": "ThrowIfLost completes without exception.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/SystemLeaseTests.cs",
        "line": 163,
        "member": "Incursa.Platform.Tests.SystemLeaseTests.ThrowIfLost_WhenLeaseIsValid_DoesNotThrow"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.Postgres.Tests:Incursa.Platform.Tests.SystemLeaseTests.TryRenewNowAsync_WithValidLease_SucceedsAndIncrementsFencingToken",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When TryRenewNowAsync is called on a valid lease, then it succeeds and increments the fencing token.",
      "intent": "Verify renewal updates fencing token for a held lease.",
      "scenario": "Given a lease acquired for a resource with a 30-second duration.",
      "behavior": "TryRenewNowAsync returns true and the fencing token increases.",
      "source": {
        "file": "tests/Incursa.Platform.Postgres.Tests/SystemLeaseTests.cs",
        "line": 136,
        "member": "Incursa.Platform.Tests.SystemLeaseTests.TryRenewNowAsync_WithValidLease_SucceedsAndIncrementsFencingToken"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Postgres.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.ConfiguredLeaseFactoryProviderTests.ConfiguredProvider_CreatesFactoriesFromConfigsAsync",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When lease factory configs are provided, then the provider creates a factory for each configuration.",
      "intent": "Verify configured provider materializes lease factories from config entries.",
      "scenario": "Given two LeaseDatabaseConfig entries and a test logger factory.",
      "behavior": "Then GetAllFactoriesAsync returns two factories with identifiers matching the configs.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/ConfiguredLeaseFactoryProviderTests.cs",
        "line": 45,
        "member": "Incursa.Platform.Tests.ConfiguredLeaseFactoryProviderTests.ConfiguredProvider_CreatesFactoriesFromConfigsAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.ConfiguredLeaseFactoryProviderTests.ConfiguredProvider_GetFactoryByKey_ReturnsCorrectFactoryAsync",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a factory is requested by key, then the provider returns the matching factory or null.",
      "intent": "Ensure key-based lookup resolves known factories and rejects unknown keys.",
      "scenario": "Given two LeaseDatabaseConfig entries and a ConfiguredLeaseFactoryProvider instance.",
      "behavior": "Then known keys return factories with matching identifiers and an unknown key returns null.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/ConfiguredLeaseFactoryProviderTests.cs",
        "line": 84,
        "member": "Incursa.Platform.Tests.ConfiguredLeaseFactoryProviderTests.ConfiguredProvider_GetFactoryByKey_ReturnsCorrectFactoryAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.ConfiguredLeaseFactoryProviderTests.ConfiguredProvider_GetFactoryIdentifier_ReturnsUnknownForInvalidFactory",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a factory not created by the provider is inspected, then its identifier is reported as \"Unknown\".",
      "intent": "Confirm identifier lookup only recognizes provider-managed factories.",
      "scenario": "Given an external SqlLeaseFactory not created by ConfiguredLeaseFactoryProvider.",
      "behavior": "Then GetFactoryIdentifier returns \"Unknown\".",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/ConfiguredLeaseFactoryProviderTests.cs",
        "line": 127,
        "member": "Incursa.Platform.Tests.ConfiguredLeaseFactoryProviderTests.ConfiguredProvider_GetFactoryIdentifier_ReturnsUnknownForInvalidFactory"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.ControlPlaneConfigurationTests.AddSqlPlatformMultiDatabaseWithControlPlaneAndDiscovery_OldSignature_StillWorks",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the obsolete discovery-based control plane overload is used, then it still wires defaults correctly.",
      "intent": "Ensure legacy discovery registration continues to configure the control plane schema.",
      "scenario": "Given AddSqlPlatformMultiDatabaseWithControlPlaneAndDiscovery called via the obsolete signature and a list-based discovery.",
      "behavior": "Then PlatformConfiguration defaults the schema to \"infra\".",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/ControlPlaneConfigurationTests.cs",
        "line": 247,
        "member": "Incursa.Platform.Tests.ControlPlaneConfigurationTests.AddSqlPlatformMultiDatabaseWithControlPlaneAndDiscovery_OldSignature_StillWorks"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.ControlPlaneConfigurationTests.AddSqlPlatformMultiDatabaseWithControlPlaneAndDiscovery_WithOptions_ConfiguresSchemaName",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When discovery-based control plane registration specifies a schema name, then configuration uses it.",
      "intent": "Verify control-plane settings flow through discovery-based registration.",
      "scenario": "Given AddSqlPlatformMultiDatabaseWithControlPlaneAndDiscovery with a ListBasedDatabaseDiscovery and custom SchemaName.",
      "behavior": "Then PlatformConfiguration reflects the schema and connection string.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/ControlPlaneConfigurationTests.cs",
        "line": 84,
        "member": "Incursa.Platform.Tests.ControlPlaneConfigurationTests.AddSqlPlatformMultiDatabaseWithControlPlaneAndDiscovery_WithOptions_ConfiguresSchemaName"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.ControlPlaneConfigurationTests.AddSqlPlatformMultiDatabaseWithControlPlaneAndList_OldSignature_StillWorks",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the obsolete list-based control plane overload is used, then it still wires defaults correctly.",
      "intent": "Ensure legacy registration paths continue to configure the control plane schema.",
      "scenario": "Given AddSqlPlatformMultiDatabaseWithControlPlaneAndList called via the obsolete signature.",
      "behavior": "Then PlatformConfiguration defaults the schema to \"infra\".",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/ControlPlaneConfigurationTests.cs",
        "line": 201,
        "member": "Incursa.Platform.Tests.ControlPlaneConfigurationTests.AddSqlPlatformMultiDatabaseWithControlPlaneAndList_OldSignature_StillWorks"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.ControlPlaneConfigurationTests.AddSqlPlatformMultiDatabaseWithControlPlaneAndList_RegistersGlobalSchedulerServices",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When control plane registration is used, then global scheduler services are available.",
      "intent": "Ensure global scheduler registrations are wired for control plane environments.",
      "scenario": "Given AddSqlPlatformMultiDatabaseWithControlPlaneAndList called with valid options.",
      "behavior": "Then the global scheduler, outbox store, and lease factory can be resolved.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/ControlPlaneConfigurationTests.cs",
        "line": 133,
        "member": "Incursa.Platform.Tests.ControlPlaneConfigurationTests.AddSqlPlatformMultiDatabaseWithControlPlaneAndList_RegistersGlobalSchedulerServices"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.ControlPlaneConfigurationTests.AddSqlPlatformMultiDatabaseWithControlPlaneAndList_WithOptions_ConfiguresSchemaName",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When list-based control plane registration specifies a schema name, then configuration uses it.",
      "intent": "Verify control-plane schema settings are propagated to configuration.",
      "scenario": "Given AddSqlPlatformMultiDatabaseWithControlPlaneAndList called with control plane options specifying SchemaName = \"control\".",
      "behavior": "Then PlatformConfiguration uses the control plane schema and connection string.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/ControlPlaneConfigurationTests.cs",
        "line": 38,
        "member": "Incursa.Platform.Tests.ControlPlaneConfigurationTests.AddSqlPlatformMultiDatabaseWithControlPlaneAndList_WithOptions_ConfiguresSchemaName"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.ControlPlaneConfigurationTests.PlatformControlPlaneOptions_DefaultSchemaName_IsDbo",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When PlatformControlPlaneOptions is created without a schema name, then it defaults to \"infra\".",
      "intent": "Confirm control-plane options default schema aligns with platform conventions.",
      "scenario": "Given a PlatformControlPlaneOptions instance with only ConnectionString set.",
      "behavior": "Then SchemaName is \"infra\".",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/ControlPlaneConfigurationTests.cs",
        "line": 178,
        "member": "Incursa.Platform.Tests.ControlPlaneConfigurationTests.PlatformControlPlaneOptions_DefaultSchemaName_IsDbo"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.ControlPlaneSchemaBundleTests.ControlPlaneBundle_AddsControlPlaneSchema_OnTopOfTenantBundle",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When control Plane Bundle Adds Control Plane Schema On Top Of Tenant Bundle, then it behaves as expected.",
      "intent": "Document expected behavior for control Plane Bundle Adds Control Plane Schema On Top Of Tenant Bundle.",
      "scenario": "Given control Plane Bundle Adds Control Plane Schema On Top Of Tenant Bundle.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/ControlPlaneSchemaBundleTests.cs",
        "line": 55,
        "member": "Incursa.Platform.Tests.ControlPlaneSchemaBundleTests.ControlPlaneBundle_AddsControlPlaneSchema_OnTopOfTenantBundle"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.ControlPlaneSchemaBundleTests.TenantBundle_DoesNotInclude_ControlPlaneSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When tenant Bundle Does Not Include Control Plane Schema, then it behaves as expected.",
      "intent": "Document expected behavior for tenant Bundle Does Not Include Control Plane Schema.",
      "scenario": "Given tenant Bundle Does Not Include Control Plane Schema.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/ControlPlaneSchemaBundleTests.cs",
        "line": 37,
        "member": "Incursa.Platform.Tests.ControlPlaneSchemaBundleTests.TenantBundle_DoesNotInclude_ControlPlaneSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureDistributedLockSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the distributed lock schema is ensured with a custom schema, then all lock objects are created under that schema.",
      "intent": "Verify distributed lock tables and procedures honor a non-default schema name.",
      "scenario": "Given EnsureDistributedLockSchemaAsync called with the CustomSchema value.",
      "behavior": "Then the DistributedLock table and Lock_* procedures exist in the custom schema.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/CustomSchemaIntegrationTests.cs",
        "line": 48,
        "member": "Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureDistributedLockSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureFanoutSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the fanout schema is ensured with a custom schema, then fanout tables are created under that schema.",
      "intent": "Verify fanout schema deployment respects custom schema configuration.",
      "scenario": "Given EnsureFanoutSchemaAsync called with the CustomSchema value.",
      "behavior": "Then FanoutPolicy and FanoutCursor tables exist in the custom schema.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/CustomSchemaIntegrationTests.cs",
        "line": 310,
        "member": "Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureFanoutSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureInboxSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the inbox schema is ensured with a custom schema, then the inbox table is created under that schema.",
      "intent": "Verify inbox schema deployment uses the configured schema name.",
      "scenario": "Given EnsureInboxSchemaAsync called with the CustomSchema value.",
      "behavior": "Then the Inbox table exists in the custom schema.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/CustomSchemaIntegrationTests.cs",
        "line": 152,
        "member": "Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureInboxSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureInboxWorkQueueSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the inbox work queue schema is ensured with a custom schema, then inbox work-queue objects are created there.",
      "intent": "Verify inbox work queue deployment uses custom schema names after inbox setup.",
      "scenario": "Given an inbox table exists and EnsureInboxWorkQueueSchemaAsync is run with the CustomSchema value.",
      "behavior": "Then the StringIdList type and Inbox_* procedures exist in the custom schema.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/CustomSchemaIntegrationTests.cs",
        "line": 263,
        "member": "Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureInboxWorkQueueSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureLeaseSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the lease schema is ensured with a custom schema, then lease tables and procedures are created under that schema.",
      "intent": "Verify lease schema deployment respects custom schema names.",
      "scenario": "Given EnsureLeaseSchemaAsync called with the CustomSchema value.",
      "behavior": "Then the Lease table and Lease_* procedures exist in the custom schema.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/CustomSchemaIntegrationTests.cs",
        "line": 88,
        "member": "Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureLeaseSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureOutboxSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the outbox schema is ensured with a custom schema, then outbox tables are created under that schema.",
      "intent": "Verify outbox table deployment honors custom schema configuration.",
      "scenario": "Given EnsureOutboxSchemaAsync called with the CustomSchema value.",
      "behavior": "Then the Outbox and OutboxState tables exist in the custom schema.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/CustomSchemaIntegrationTests.cs",
        "line": 122,
        "member": "Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureOutboxSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureSchedulerSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the scheduler schema is ensured with a custom schema, then scheduler tables are created under that schema.",
      "intent": "Verify scheduler schema deployment honors custom schema names.",
      "scenario": "Given EnsureSchedulerSchemaAsync called with the CustomSchema value.",
      "behavior": "Then Jobs, Timers, JobRuns, and SchedulerState tables exist in the custom schema.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/CustomSchemaIntegrationTests.cs",
        "line": 179,
        "member": "Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureSchedulerSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureWorkQueueSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the work queue schema is ensured with a custom schema, then work-queue types and procedures are created there.",
      "intent": "Verify work queue deployment uses custom schema names after outbox setup.",
      "scenario": "Given an outbox table exists and EnsureWorkQueueSchemaAsync is run with the CustomSchema value.",
      "behavior": "Then the GuidIdList type and Outbox_* procedures exist in the custom schema.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/CustomSchemaIntegrationTests.cs",
        "line": 216,
        "member": "Incursa.Platform.Tests.CustomSchemaIntegrationTests.EnsureWorkQueueSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DapperTypeHandlerTests.AllTypesInSingleQuery_RoundTrip_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When all strongly-typed IDs are inserted in one row, then Dapper retrieves each value correctly.",
      "intent": "Validate multiple type handlers in a single query.",
      "scenario": "Given a test row containing OwnerToken and various identifier types.",
      "behavior": "Then each retrieved identifier matches its original value.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DapperTypeHandlerTests.cs",
        "line": 451,
        "member": "Incursa.Platform.Tests.DapperTypeHandlerTests.AllTypesInSingleQuery_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DapperTypeHandlerTests.DatabaseIdentifier_RoundTrip_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a DatabaseIdentifier is inserted and retrieved via Dapper, then it round-trips to the same value.",
      "intent": "Validate the Dapper type handler for DatabaseIdentifier.",
      "scenario": "Given a test table and a generated DatabaseIdentifier value.",
      "behavior": "Then the retrieved DatabaseIdentifier equals the original value.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DapperTypeHandlerTests.cs",
        "line": 407,
        "member": "Incursa.Platform.Tests.DapperTypeHandlerTests.DatabaseIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DapperTypeHandlerTests.InboxMessageIdentifier_RoundTrip_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an InboxMessageIdentifier is inserted and retrieved via Dapper, then it round-trips to the same value.",
      "intent": "Validate the Dapper type handler for InboxMessageIdentifier.",
      "scenario": "Given a test table and a generated InboxMessageIdentifier value.",
      "behavior": "Then the retrieved InboxMessageIdentifier equals the original value.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DapperTypeHandlerTests.cs",
        "line": 187,
        "member": "Incursa.Platform.Tests.DapperTypeHandlerTests.InboxMessageIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DapperTypeHandlerTests.InstanceIdentifier_RoundTrip_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an InstanceIdentifier is inserted and retrieved via Dapper, then it round-trips to the same value.",
      "intent": "Validate the Dapper type handler for InstanceIdentifier.",
      "scenario": "Given a test table and a generated InstanceIdentifier value.",
      "behavior": "Then the retrieved InstanceIdentifier equals the original value.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DapperTypeHandlerTests.cs",
        "line": 363,
        "member": "Incursa.Platform.Tests.DapperTypeHandlerTests.InstanceIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DapperTypeHandlerTests.JoinIdentifier_RoundTrip_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a JoinIdentifier is inserted and retrieved via Dapper, then it round-trips to the same value.",
      "intent": "Validate the Dapper type handler for JoinIdentifier.",
      "scenario": "Given a test table and a generated JoinIdentifier value.",
      "behavior": "Then the retrieved JoinIdentifier equals the original value.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DapperTypeHandlerTests.cs",
        "line": 319,
        "member": "Incursa.Platform.Tests.DapperTypeHandlerTests.JoinIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DapperTypeHandlerTests.NullableOwnerToken_RoundTrip_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a nullable OwnerToken is stored and retrieved, then values round-trip and nulls remain null.",
      "intent": "Validate nullable OwnerToken handling in Dapper.",
      "scenario": "Given a test table and a nullable OwnerToken value inserted once with a value and once with null.",
      "behavior": "Then the first row returns the original OwnerToken and the second row returns null.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DapperTypeHandlerTests.cs",
        "line": 119,
        "member": "Incursa.Platform.Tests.DapperTypeHandlerTests.NullableOwnerToken_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DapperTypeHandlerTests.OutboxMessageIdentifier_RoundTrip_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an OutboxMessageIdentifier is inserted and retrieved via Dapper, then it round-trips to the same value.",
      "intent": "Validate the Dapper type handler for OutboxMessageIdentifier.",
      "scenario": "Given a test table and a generated OutboxMessageIdentifier value.",
      "behavior": "Then the retrieved OutboxMessageIdentifier equals the original value.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DapperTypeHandlerTests.cs",
        "line": 231,
        "member": "Incursa.Platform.Tests.DapperTypeHandlerTests.OutboxMessageIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DapperTypeHandlerTests.OutboxWorkItemIdentifier_RoundTrip_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an OutboxWorkItemIdentifier is inserted and retrieved via Dapper, then it round-trips to the same value.",
      "intent": "Validate the Dapper type handler for OutboxWorkItemIdentifier.",
      "scenario": "Given a test table and a generated OutboxWorkItemIdentifier value.",
      "behavior": "Then the retrieved OutboxWorkItemIdentifier equals the original value.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DapperTypeHandlerTests.cs",
        "line": 275,
        "member": "Incursa.Platform.Tests.DapperTypeHandlerTests.OutboxWorkItemIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DapperTypeHandlerTests.OwnerToken_RoundTrip_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an OwnerToken is inserted and retrieved via Dapper, then it round-trips to the same value.",
      "intent": "Validate the Dapper type handler for OwnerToken.",
      "scenario": "Given a test table and a generated OwnerToken value.",
      "behavior": "Then the retrieved OwnerToken equals the original value.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DapperTypeHandlerTests.cs",
        "line": 75,
        "member": "Incursa.Platform.Tests.DapperTypeHandlerTests.OwnerToken_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.CustomSchemaNames_WorkCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a custom schema name is used, then scheduler tables and indexes are created in that schema.",
      "intent": "Ensure schema customization works for scheduler artifacts.",
      "scenario": "Given DatabaseSchemaManager.EnsureSchedulerSchemaAsync called with a custom schema and table names.",
      "behavior": "Then the custom tables exist and the expected index name is present.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 325,
        "member": "Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.CustomSchemaNames_WorkCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.DatabaseSchema_AllRequiredTablesExist",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the schema is deployed, then all required core tables exist in the infra schema.",
      "intent": "Verify core platform tables are created in the test database.",
      "scenario": "Given schema deployment for outbox, inbox, scheduler, and fanout modules.",
      "behavior": "Then the expected table names are present under infra.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 66,
        "member": "Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.DatabaseSchema_AllRequiredTablesExist"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.InboxTable_HasCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the Inbox table, then required columns exist with expected data types.",
      "intent": "Ensure inbox schema matches production column definitions.",
      "scenario": "Given the Inbox table deployed in the infra schema.",
      "behavior": "Then all inbox columns are present with correct types.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 269,
        "member": "Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.InboxTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.JobRunsTable_HasCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the JobRuns table, then required columns exist with expected data types.",
      "intent": "Ensure job run schema matches production column definitions.",
      "scenario": "Given the JobRuns table deployed in the infra schema.",
      "behavior": "Then all job run and work-queue columns are present with correct types.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 232,
        "member": "Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.JobRunsTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.JobsTable_HasCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the Jobs table, then required columns exist with expected data types.",
      "intent": "Ensure jobs schema matches production column definitions.",
      "scenario": "Given the Jobs table deployed in the infra schema.",
      "behavior": "Then all job definition columns are present with correct types.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 162,
        "member": "Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.JobsTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.OutboxTable_HasCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the Outbox table, then required columns exist with expected data types.",
      "intent": "Ensure outbox schema matches production column definitions.",
      "scenario": "Given the Outbox table deployed in the infra schema.",
      "behavior": "Then all essential outbox and work-queue columns are present with correct types.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 122,
        "member": "Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.OutboxTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.RequiredIndexes_ExistOnAllTables",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When required indexes are inspected, then core tables have the expected indexes.",
      "intent": "Verify production index definitions are present in tests.",
      "scenario": "Given the infra schema with deployed tables and indexes.",
      "behavior": "Then the outbox, jobs, timers, and job runs indexes exist.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 300,
        "member": "Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.RequiredIndexes_ExistOnAllTables"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.TimersTable_HasCorrectSchema",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the Timers table, then required columns exist with expected data types.",
      "intent": "Ensure timers schema matches production column definitions.",
      "scenario": "Given the Timers table deployed in the infra schema.",
      "behavior": "Then all timer and work-queue columns are present with correct types.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 194,
        "member": "Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.TimersTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.WorkQueueColumns_ExistAfterMigration",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When work-queue migrations are applied, then work-queue columns and types exist.",
      "intent": "Verify work-queue migration adds required columns and table types.",
      "scenario": "Given the Outbox table after schema deployment.",
      "behavior": "Then Status, LockedUntil, OwnerToken, and the GuidIdList type exist.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 367,
        "member": "Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.WorkQueueColumns_ExistAfterMigration"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.WorkQueueProcedures_UseDatabaseUtcTime",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When work-queue procedures are inspected, then they use SYSUTCDATETIME for timing.",
      "intent": "Ensure stored procedures rely on database-authoritative time.",
      "scenario": "Given the Outbox and Inbox work-queue procedures deployed in infra.",
      "behavior": "Then procedure definitions include SYSUTCDATETIME.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 392,
        "member": "Incursa.Platform.Tests.DatabaseSchemaConsistencyTests.WorkQueueProcedures_UseDatabaseUtcTime"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddSqlOutbox_WithSchemaDeploymentDisabled_DoesNotRegisterSchemaService",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlOutbox disables schema deployment, then schema completion and background services are not registered.",
      "intent": "Avoid schema deployment services when deployment is disabled.",
      "scenario": "Given SqlOutboxOptions with EnableSchemaDeployment set to false.",
      "behavior": "Then IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService are absent from the service collection.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 72,
        "member": "Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddSqlOutbox_WithSchemaDeploymentDisabled_DoesNotRegisterSchemaService"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddSqlOutbox_WithSchemaDeploymentEnabled_RegistersSchemaService",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlOutbox enables schema deployment, then schema completion and background services are registered.",
      "intent": "Ensure schema deployment wiring is added when enabled.",
      "scenario": "Given SqlOutboxOptions with EnableSchemaDeployment set to true.",
      "behavior": "Then IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService are registered in the service collection.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 38,
        "member": "Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddSqlOutbox_WithSchemaDeploymentEnabled_RegistersSchemaService"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddSqlPlatformMultiDatabaseWithControlPlaneAndList_WithSchemaDeploymentEnabled_RegistersSchemaService",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When control-plane registration enables schema deployment, then schema services are registered.",
      "intent": "Ensure schema deployment services are added for control-plane registration.",
      "scenario": "Given AddSqlPlatformMultiDatabaseWithControlPlaneAndList with EnableSchemaDeployment set to true.",
      "behavior": "Then IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService are registered.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 222,
        "member": "Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddSqlPlatformMultiDatabaseWithControlPlaneAndList_WithSchemaDeploymentEnabled_RegistersSchemaService"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddSqlPlatformMultiDatabaseWithList_WithSchemaDeploymentDisabled_DoesNotRegisterSchemaService",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When multi-database list registration disables schema deployment, then schema services are not registered.",
      "intent": "Avoid schema deployment services when list-based registration disables deployment.",
      "scenario": "Given AddSqlPlatformMultiDatabaseWithList with enableSchemaDeployment set to false.",
      "behavior": "Then IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService are absent.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 269,
        "member": "Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddSqlPlatformMultiDatabaseWithList_WithSchemaDeploymentDisabled_DoesNotRegisterSchemaService"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddSqlPlatformMultiDatabaseWithList_WithSchemaDeploymentEnabled_RegistersSchemaService",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When multi-database list registration enables schema deployment, then schema services are registered.",
      "intent": "Ensure schema deployment services are added for list-based registration.",
      "scenario": "Given AddSqlPlatformMultiDatabaseWithList with enableSchemaDeployment set to true.",
      "behavior": "Then IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService are registered.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 182,
        "member": "Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.AddSqlPlatformMultiDatabaseWithList_WithSchemaDeploymentEnabled_RegistersSchemaService"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.DatabaseSchemaCompletion_CoordinatesStateCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When DatabaseSchemaCompletion is completed, then its completion task transitions to RanToCompletion.",
      "intent": "Ensure schema completion state tracking works as expected.",
      "scenario": "Given a new DatabaseSchemaCompletion instance.",
      "behavior": "Then SchemaDeploymentCompleted is initially incomplete and becomes completed after SetCompleted.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 153,
        "member": "Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.DatabaseSchemaCompletion_CoordinatesStateCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.SchemaCompletion_RegisteredSeparatelyFromBackgroundService",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When schema deployment is enabled, then IDatabaseSchemaCompletion and DatabaseSchemaCompletion are registered separately.",
      "intent": "Verify schema completion registrations use the expected lifetimes and factories.",
      "scenario": "Given AddSqlOutbox with schema deployment enabled.",
      "behavior": "Then IDatabaseSchemaCompletion is a singleton factory and DatabaseSchemaCompletion is registered directly.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 106,
        "member": "Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.SchemaCompletion_RegisteredSeparatelyFromBackgroundService"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.SchemaSnapshotManifest_IsTracked",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the schema snapshot manifest is expected, then the snapshot file exists on disk.",
      "intent": "Ensure the schema snapshot artifact is tracked in the repository.",
      "scenario": "Given the expected schema snapshot file path from SchemaVersionSnapshot.",
      "behavior": "Then the snapshot file exists at the expected location.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 309,
        "member": "Incursa.Platform.Tests.DatabaseSchemaDeploymentTests.SchemaSnapshotManifest_IsTracked"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicDiscoveryEnforcementTests.PlatformProviders_ShouldUseDiscoveryAsync",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "Verifies that providers use the correct discovery instance.",
      "intent": "Ensure providers use IPlatformDatabaseDiscovery results for tenant enumeration.",
      "scenario": "Given discovery returns two tenant databases and AddSqlPlatformMultiDatabaseWithDiscovery is used.",
      "behavior": "Then outbox, inbox, scheduler, lease, and fanout providers each return two entries.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicDiscoveryEnforcementTests.cs",
        "line": 201,
        "member": "Incursa.Platform.Tests.DynamicDiscoveryEnforcementTests.PlatformProviders_ShouldUseDiscoveryAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicDiscoveryEnforcementTests.PlatformWithDiscovery_ShouldNotConfigureCustomerDatabaseOptions",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "Verifies that when using platform registration with discovery, customer database features (Inbox, Outbox, Lease, Scheduler, Fanout) do NOT have services.Configure<TOptions>() called (they should use discovery instead). Global features may have Configure<TOptions>() called.",
      "intent": "Enforce discovery-driven configuration for tenant features while allowing global options.",
      "scenario": "Given AddSqlPlatformMultiDatabaseWithControlPlaneAndDiscovery with a discovery implementation and control plane options.",
      "behavior": "Then Outbox/Inbox/Scheduler/Fanout options remain default.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicDiscoveryEnforcementTests.cs",
        "line": 44,
        "member": "Incursa.Platform.Tests.DynamicDiscoveryEnforcementTests.PlatformWithDiscovery_ShouldNotConfigureCustomerDatabaseOptions"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicDiscoveryEnforcementTests.PlatformWithDiscovery_ShouldRegisterAllProviders",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "Verifies that all customer database features have their providers registered when using platform registration.",
      "intent": "Validate provider registration for outbox, inbox, scheduler, fanout, and leases.",
      "scenario": "Given AddSqlPlatformMultiDatabaseWithDiscovery and a discovery implementation.",
      "behavior": "Then the outbox, inbox, scheduler, fanout, and lease providers resolve from the service provider.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicDiscoveryEnforcementTests.cs",
        "line": 151,
        "member": "Incursa.Platform.Tests.DynamicDiscoveryEnforcementTests.PlatformWithDiscovery_ShouldRegisterAllProviders"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicDiscoveryEnforcementTests.PlatformWithList_ShouldNotConfigureCustomerDatabaseOptions",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "Verifies that when using platform registration with a list, customer database features do NOT have services.Configure<TOptions>() called.",
      "intent": "Ensure list-based registration still relies on discovery providers rather than direct options.",
      "scenario": "Given AddSqlPlatformMultiDatabaseWithList with two tenant databases and schema deployment disabled.",
      "behavior": "Then Outbox/Inbox/Scheduler/Fanout options remain default.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicDiscoveryEnforcementTests.cs",
        "line": 98,
        "member": "Incursa.Platform.Tests.DynamicDiscoveryEnforcementTests.PlatformWithList_ShouldNotConfigureCustomerDatabaseOptions"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicInboxWorkStoreProviderTests.DynamicProvider_DetectsNewDatabases",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a new inbox database is added to discovery, then RefreshAsync updates the store list.",
      "intent": "Ensure the provider detects newly added inbox databases.",
      "scenario": "Given discovery initially returns Customer1 and later adds Customer2 before RefreshAsync.",
      "behavior": "Then GetAllStoresAsync returns two stores with identifiers for both customers.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicInboxWorkStoreProviderTests.cs",
        "line": 104,
        "member": "Incursa.Platform.Tests.DynamicInboxWorkStoreProviderTests.DynamicProvider_DetectsNewDatabases"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicInboxWorkStoreProviderTests.DynamicProvider_DetectsRemovedDatabases",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an inbox database is removed from discovery, then RefreshAsync removes its store.",
      "intent": "Ensure the provider drops stores for removed inbox databases.",
      "scenario": "Given discovery initially returns Customer1 and Customer2, then Customer2 is removed before RefreshAsync.",
      "behavior": "Then GetAllStoresAsync returns one store identified as Customer1.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicInboxWorkStoreProviderTests.cs",
        "line": 160,
        "member": "Incursa.Platform.Tests.DynamicInboxWorkStoreProviderTests.DynamicProvider_DetectsRemovedDatabases"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicInboxWorkStoreProviderTests.DynamicProvider_DiscoversInitialDatabases",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the dynamic inbox provider performs initial discovery, then it returns stores for all configured databases.",
      "intent": "Verify initial discovery populates inbox work stores from discovery results.",
      "scenario": "Given a SampleInboxDatabaseDiscovery returning Customer1 and Customer2 configs.",
      "behavior": "Then GetAllStoresAsync returns two stores with identifiers matching the discovered customers.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicInboxWorkStoreProviderTests.cs",
        "line": 51,
        "member": "Incursa.Platform.Tests.DynamicInboxWorkStoreProviderTests.DynamicProvider_DiscoversInitialDatabases"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicInboxWorkStoreProviderTests.DynamicProvider_RefreshesAutomaticallyAfterInterval",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the refresh interval elapses, then the provider automatically refreshes discovery results.",
      "intent": "Validate time-based automatic refresh behavior for inbox work stores.",
      "scenario": "Given a FakeTimeProvider, one initial database, and a second database added before time advances.",
      "behavior": "Then advancing time past the interval causes GetAllStoresAsync to return two stores.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicInboxWorkStoreProviderTests.cs",
        "line": 216,
        "member": "Incursa.Platform.Tests.DynamicInboxWorkStoreProviderTests.DynamicProvider_RefreshesAutomaticallyAfterInterval"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_DetectsConnectionStringChanges",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a connection string changes for an existing key, then RefreshAsync recreates the factory.",
      "intent": "Ensure the provider detects connection string changes and refreshes factories.",
      "scenario": "Given Customer1 is removed and re-added with a new connection string before RefreshAsync.",
      "behavior": "Then the factory for Customer1 is replaced with a new instance.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicLeaseFactoryProviderTests.cs",
        "line": 333,
        "member": "Incursa.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_DetectsConnectionStringChanges"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_DetectsNewDatabases",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a new lease database is added to discovery, then RefreshAsync updates the factory list.",
      "intent": "Ensure the provider detects newly added lease databases.",
      "scenario": "Given discovery initially returns Customer1 and later adds Customer2 before RefreshAsync.",
      "behavior": "Then GetAllFactoriesAsync returns two factories with identifiers for both customers.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicLeaseFactoryProviderTests.cs",
        "line": 104,
        "member": "Incursa.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_DetectsNewDatabases"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_DetectsRemovedDatabases",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a lease database is removed from discovery, then RefreshAsync removes its factory.",
      "intent": "Ensure the provider drops factories for removed lease databases.",
      "scenario": "Given discovery initially returns Customer1 and Customer2, then Customer2 is removed before RefreshAsync.",
      "behavior": "Then GetAllFactoriesAsync returns one factory identified as Customer1.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicLeaseFactoryProviderTests.cs",
        "line": 161,
        "member": "Incursa.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_DetectsRemovedDatabases"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_DiscoversInitialDatabases",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the dynamic lease provider performs initial discovery, then it returns factories for all configured databases.",
      "intent": "Verify initial discovery populates lease factories from discovery results.",
      "scenario": "Given a SampleLeaseDatabaseDiscovery returning Customer1 and Customer2 configs.",
      "behavior": "Then GetAllFactoriesAsync returns two factories with identifiers matching the discovered customers.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicLeaseFactoryProviderTests.cs",
        "line": 51,
        "member": "Incursa.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_DiscoversInitialDatabases"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_GetFactoryByKey_ReturnsCorrectFactory",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When known lease keys are requested, then GetFactoryByKeyAsync returns the matching factories.",
      "intent": "Verify keyed lease factory lookup works after discovery.",
      "scenario": "Given discovery provides Customer1 and Customer2 and initial discovery has completed.",
      "behavior": "Then known keys return factories and an unknown key returns null.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicLeaseFactoryProviderTests.cs",
        "line": 273,
        "member": "Incursa.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_GetFactoryByKey_ReturnsCorrectFactory"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_RefreshesAutomaticallyAfterInterval",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the refresh interval elapses, then the provider automatically refreshes discovery results.",
      "intent": "Validate time-based automatic refresh behavior for lease factories.",
      "scenario": "Given a FakeTimeProvider, one initial database, and a second database added before time advances.",
      "behavior": "Then advancing time past the interval causes GetAllFactoriesAsync to return two factories.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicLeaseFactoryProviderTests.cs",
        "line": 218,
        "member": "Incursa.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_RefreshesAutomaticallyAfterInterval"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicOutboxStoreProviderTests.DynamicProvider_DetectsNewDatabases",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a new outbox database is added to discovery, then RefreshAsync updates the store list.",
      "intent": "Ensure the provider detects newly added outbox databases.",
      "scenario": "Given discovery initially returns Customer1 and later adds Customer2 before RefreshAsync.",
      "behavior": "Then GetAllStoresAsync returns two stores with identifiers for both customers.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicOutboxStoreProviderTests.cs",
        "line": 127,
        "member": "Incursa.Platform.Tests.DynamicOutboxStoreProviderTests.DynamicProvider_DetectsNewDatabases"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicOutboxStoreProviderTests.DynamicProvider_DetectsRemovedDatabases",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an outbox database is removed from discovery, then RefreshAsync removes its store.",
      "intent": "Ensure the provider drops stores for removed outbox databases.",
      "scenario": "Given discovery initially returns Customer1 and Customer2, then Customer2 is removed before RefreshAsync.",
      "behavior": "Then GetAllStoresAsync returns one store identified as Customer1.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicOutboxStoreProviderTests.cs",
        "line": 183,
        "member": "Incursa.Platform.Tests.DynamicOutboxStoreProviderTests.DynamicProvider_DetectsRemovedDatabases"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicOutboxStoreProviderTests.DynamicProvider_DiscoversInitialDatabases",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the dynamic outbox provider performs initial discovery, then it returns stores for all configured databases.",
      "intent": "Verify initial discovery populates outbox stores from discovery results.",
      "scenario": "Given a SampleOutboxDatabaseDiscovery returning Customer1 and Customer2 configs.",
      "behavior": "Then GetAllStoresAsync returns two stores with identifiers matching the discovered customers.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicOutboxStoreProviderTests.cs",
        "line": 74,
        "member": "Incursa.Platform.Tests.DynamicOutboxStoreProviderTests.DynamicProvider_DiscoversInitialDatabases"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicOutboxStoreProviderTests.DynamicProvider_RefreshesAutomaticallyAfterInterval",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the refresh interval elapses, then the provider automatically refreshes discovery results.",
      "intent": "Validate time-based automatic refresh behavior.",
      "scenario": "Given a FakeTimeProvider, one initial database, and a second database added before time advances.",
      "behavior": "Then advancing time past the interval causes GetAllStoresAsync to return two stores.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicOutboxStoreProviderTests.cs",
        "line": 239,
        "member": "Incursa.Platform.Tests.DynamicOutboxStoreProviderTests.DynamicProvider_RefreshesAutomaticallyAfterInterval"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_DetectsNewDatabases",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a new database appears in discovery, then RefreshAsync updates the store list.",
      "intent": "Ensure the provider detects newly added scheduler databases.",
      "scenario": "Given discovery initially returns Customer1 and later adds Customer2 before RefreshAsync.",
      "behavior": "Then GetAllStoresAsync returns two stores with identifiers for both customers.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicSchedulerStoreProviderTests.cs",
        "line": 108,
        "member": "Incursa.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_DetectsNewDatabases"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_DetectsRemovedDatabases",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a database is removed from discovery, then RefreshAsync removes its store.",
      "intent": "Ensure the provider drops stores for removed scheduler databases.",
      "scenario": "Given discovery initially returns Customer1 and Customer2, then Customer2 is removed before RefreshAsync.",
      "behavior": "Then GetAllStoresAsync returns one store identified as Customer1.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicSchedulerStoreProviderTests.cs",
        "line": 163,
        "member": "Incursa.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_DetectsRemovedDatabases"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_DiscoversInitialDatabases",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the dynamic scheduler provider performs initial discovery, then it returns stores for all configured databases.",
      "intent": "Verify initial discovery populates scheduler stores from discovery results.",
      "scenario": "Given a SampleSchedulerDatabaseDiscovery returning Customer1 and Customer2 configs.",
      "behavior": "Then GetAllStoresAsync returns two stores with identifiers matching the discovered customers.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicSchedulerStoreProviderTests.cs",
        "line": 51,
        "member": "Incursa.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_DiscoversInitialDatabases"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_GetSchedulerClientByKey_ReturnsCorrectClient",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a known scheduler key is requested, then GetSchedulerClientByKey returns a client instance.",
      "intent": "Verify keyed scheduler client lookup works after discovery.",
      "scenario": "Given discovery provides Customer1 and initial discovery has completed.",
      "behavior": "Then GetSchedulerClientByKey(\"Customer1\") returns a non-null client.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicSchedulerStoreProviderTests.cs",
        "line": 218,
        "member": "Incursa.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_GetSchedulerClientByKey_ReturnsCorrectClient"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_GetSchedulerClientByKey_ReturnsNullForUnknownKey",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an unknown scheduler key is requested, then GetSchedulerClientByKey returns null.",
      "intent": "Ensure missing scheduler keys are reported as null lookups.",
      "scenario": "Given discovery provides Customer1 and initial discovery has completed.",
      "behavior": "Then GetSchedulerClientByKey(\"UnknownCustomer\") returns null.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/DynamicSchedulerStoreProviderTests.cs",
        "line": 262,
        "member": "Incursa.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_GetSchedulerClientByKey_ReturnsNullForUnknownKey"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.FanoutCoordinatorIntegrationTests.FanoutSlices_CanJoinDownstreamMessagesIdempotently",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When fanout slices share a correlation ID, then join completion is idempotent and correlation IDs match.",
      "intent": "Validate downstream join tracking for fanout-dispatched messages.",
      "scenario": "Given three slices dispatched with the same correlation ID and a join expecting three steps.",
      "behavior": "Then completed steps remain at three after replay and all outbox messages share one correlation ID.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/FanoutCoordinatorIntegrationTests.cs",
        "line": 201,
        "member": "Incursa.Platform.Tests.FanoutCoordinatorIntegrationTests.FanoutSlices_CanJoinDownstreamMessagesIdempotently"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_RedispatchesAbandonedSlices",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When cursors do not advance, then RunAsync redispatches the same slice on subsequent runs.",
      "intent": "Ensure abandoned slices can be redispatched.",
      "scenario": "Given a static planner with one slice and an in-memory lease factory.",
      "behavior": "Then two consecutive runs each dispatch one message and outbox payloads match the slice shard.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/FanoutCoordinatorIntegrationTests.cs",
        "line": 130,
        "member": "Incursa.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_RedispatchesAbandonedSlices"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_RespectsActiveLeaseAndRecoversAfterExpiry",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a lease is active, then RunAsync returns no dispatches, and after the lease expires it dispatches the slice once.",
      "intent": "Verify lease gating and recovery behavior for the fanout coordinator.",
      "scenario": "Given an active in-memory lease for the fanout topic and a planner with a single slice.",
      "behavior": "Then the first RunAsync returns zero and the later RunAsync dispatches one message into the outbox.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/FanoutCoordinatorIntegrationTests.cs",
        "line": 93,
        "member": "Incursa.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_RespectsActiveLeaseAndRecoversAfterExpiry"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_SkipsCompletedSlicesAfterCursorAdvances",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When fanout cursors are marked completed, then RunAsync skips dispatching completed slices.",
      "intent": "Confirm cursor advancement prevents duplicate dispatches.",
      "scenario": "Given a sharded planner that dispatches two shards and cursors marked completed for both shards.",
      "behavior": "Then a subsequent RunAsync returns zero dispatched slices.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/FanoutCoordinatorIntegrationTests.cs",
        "line": 164,
        "member": "Incursa.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_SkipsCompletedSlicesAfterCursorAdvances"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.FanoutRouterIntegrationTests.AddDynamicMultiSqlFanout_RegistersServicesCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When dynamic fanout discovery loads tenants, then policy and cursor repositories are created for each tenant.",
      "intent": "Validate discovery-based fanout configuration builds repositories from discovered databases.",
      "scenario": "Given a MockFanoutDatabaseDiscovery returning two tenants and a DynamicFanoutRepositoryProvider.",
      "behavior": "Then repository lists contain two policy repositories and two cursor repositories.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/FanoutRouterIntegrationTests.cs",
        "line": 251,
        "member": "Incursa.Platform.Tests.FanoutRouterIntegrationTests.AddDynamicMultiSqlFanout_RegistersServicesCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.FanoutRouterIntegrationTests.AddMultiSqlFanout_RepositoryProvider_ReturnsCorrectIdentifiers",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When repository identifiers are requested, then each repository returns a unique non-empty identifier.",
      "intent": "Ensure repository identifiers map uniquely to configured tenants.",
      "scenario": "Given a ConfiguredFanoutRepositoryProvider created from two SqlFanoutOptions entries.",
      "behavior": "Then the repository identifiers are populated and distinct.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/FanoutRouterIntegrationTests.cs",
        "line": 119,
        "member": "Incursa.Platform.Tests.FanoutRouterIntegrationTests.AddMultiSqlFanout_RepositoryProvider_ReturnsCorrectIdentifiers"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.FanoutRouterIntegrationTests.AddMultiSqlFanout_WithListOfOptions_RegistersServicesCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When fanout is configured with multiple option entries, then repositories are created per tenant and routed correctly.",
      "intent": "Validate list-based fanout configuration builds distinct policy and cursor repositories.",
      "scenario": "Given two SqlFanoutOptions entries and a ConfiguredFanoutRepositoryProvider.",
      "behavior": "Then repository counts match the option entries and router returns distinct repositories per tenant.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/FanoutRouterIntegrationTests.cs",
        "line": 50,
        "member": "Incursa.Platform.Tests.FanoutRouterIntegrationTests.AddMultiSqlFanout_WithListOfOptions_RegistersServicesCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.FanoutRouterIntegrationTests.FanoutRouter_GetPolicyRepository_ReturnsCorrectRepository",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a known tenant key is requested, then FanoutRouter returns the policy and cursor repositories.",
      "intent": "Verify router lookup returns repositories for configured tenants.",
      "scenario": "Given a single SqlFanoutOptions entry for Tenant1 and a FanoutRouter built from it.",
      "behavior": "Then GetPolicyRepository and GetCursorRepository return non-null repositories.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/FanoutRouterIntegrationTests.cs",
        "line": 172,
        "member": "Incursa.Platform.Tests.FanoutRouterIntegrationTests.FanoutRouter_GetPolicyRepository_ReturnsCorrectRepository"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.FanoutRouterIntegrationTests.FanoutRouter_GetPolicyRepository_ThrowsWhenKeyNotFound",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a tenant key is missing, then FanoutRouter throws an InvalidOperationException containing the key.",
      "intent": "Ensure invalid fanout keys are rejected with actionable errors.",
      "scenario": "Given a FanoutRouter configured for Tenant1 only and a lookup for \"NonExistentKey\".",
      "behavior": "Then both policy and cursor repository lookups throw and mention the missing key.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/FanoutRouterIntegrationTests.cs",
        "line": 211,
        "member": "Incursa.Platform.Tests.FanoutRouterIntegrationTests.FanoutRouter_GetPolicyRepository_ThrowsWhenKeyNotFound"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.GlobalControlPlaneRoutingTests.GlobalAliases_RouteToControlPlane",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When global Aliases Route To Control Plane, then it behaves as expected.",
      "intent": "Document expected behavior for global Aliases Route To Control Plane.",
      "scenario": "Given global Aliases Route To Control Plane.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/GlobalControlPlaneRoutingTests.cs",
        "line": 38,
        "member": "Incursa.Platform.Tests.GlobalControlPlaneRoutingTests.GlobalAliases_RouteToControlPlane"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxCleanupTests.CleanupService_GracefullyHandles_MissingStoredProcedure",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the cleanup stored procedure is missing, then the cleanup service runs without crashing.",
      "intent": "Ensure the background cleanup service tolerates missing schema deployment.",
      "scenario": "Given an inbox database with the cleanup procedure dropped and a short cleanup interval.",
      "behavior": "Then StartAsync completes without throwing and the procedure remains missing.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxCleanupTests.cs",
        "line": 221,
        "member": "Incursa.Platform.Tests.InboxCleanupTests.CleanupService_GracefullyHandles_MissingStoredProcedure"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxCleanupTests.Cleanup_DeletesOldProcessedMessages",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When cleanup runs with a retention window, then only processed messages older than the window are deleted.",
      "intent": "Verify the cleanup procedure removes stale processed inbox records.",
      "scenario": "Given old processed, recent processed, and unprocessed inbox rows before running cleanup.",
      "behavior": "Then only the old processed message is deleted and other rows remain.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxCleanupTests.cs",
        "line": 45,
        "member": "Incursa.Platform.Tests.InboxCleanupTests.Cleanup_DeletesOldProcessedMessages"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxCleanupTests.Cleanup_RespectsRetentionPeriod",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When cleanup runs with a 10-day retention period, then only messages older than 10 days are deleted.",
      "intent": "Confirm retention period filtering is applied correctly.",
      "scenario": "Given processed messages at 30, 15, 7, 3, and 1 days old.",
      "behavior": "Then the 30- and 15-day messages are deleted while newer messages remain.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxCleanupTests.cs",
        "line": 163,
        "member": "Incursa.Platform.Tests.InboxCleanupTests.Cleanup_RespectsRetentionPeriod"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxCleanupTests.Cleanup_WithNoOldMessages_DeletesNothing",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When cleanup runs and no processed messages are older than retention, then nothing is deleted.",
      "intent": "Ensure cleanup is a no-op when no rows qualify.",
      "scenario": "Given only a recent processed inbox message before running cleanup.",
      "behavior": "Then the cleanup procedure deletes zero rows and the message remains.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxCleanupTests.cs",
        "line": 122,
        "member": "Incursa.Platform.Tests.InboxCleanupTests.Cleanup_WithNoOldMessages_DeletesNothing"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_RotatesOwnerTokensAcrossRuns",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When RunOnceAsync is called multiple times, then each run uses a new owner token.",
      "intent": "Ensure dispatcher rotates owner tokens across separate runs.",
      "scenario": "Given a StubInboxWorkStore and two RunOnceAsync calls.",
      "behavior": "Then the store captures two distinct owner tokens.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxDispatcherTests.cs",
        "line": 229,
        "member": "Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_RotatesOwnerTokensAcrossRuns"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithFailingHandler_AbandonsWithBackoffPolicy",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a handler fails and a backoff policy is supplied, then the message is abandoned with that delay.",
      "intent": "Ensure dispatcher honors custom backoff delays on failure.",
      "scenario": "Given a StubInboxWorkStore, a failing handler, and a backoff policy returning 5 seconds.",
      "behavior": "Then the message is abandoned with the configured delay and not failed.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxDispatcherTests.cs",
        "line": 165,
        "member": "Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithFailingHandler_AbandonsWithBackoffPolicy"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithFailingHandler_RetriesWithBackoff",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a handler throws, then RunOnceAsync abandons the message for retry.",
      "intent": "Validate failure paths return messages to Seen for future retries.",
      "scenario": "Given an enqueued message handled by a FailingInboxHandler that throws.",
      "behavior": "Then RunOnceAsync returns 1 and the message status is Seen.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxDispatcherTests.cs",
        "line": 131,
        "member": "Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithFailingHandler_RetriesWithBackoff"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithNoHandlerForTopic_MarksMessageAsDead",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When no handler exists for a message topic, then RunOnceAsync marks the message Dead.",
      "intent": "Ensure unhandled topics are failed instead of retried indefinitely.",
      "scenario": "Given an enqueued inbox message with an unknown topic and no registered handlers.",
      "behavior": "Then RunOnceAsync returns 1 and the message status is Dead.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxDispatcherTests.cs",
        "line": 98,
        "member": "Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithNoHandlerForTopic_MarksMessageAsDead"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithNoMessages_ReturnsZero",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When RunOnceAsync is called with no inbox messages, then it returns zero processed items.",
      "intent": "Verify the dispatcher reports no work when the store is empty.",
      "scenario": "Given a SqlInboxWorkStore with no queued messages and an empty handler resolver.",
      "behavior": "Then RunOnceAsync returns 0.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxDispatcherTests.cs",
        "line": 46,
        "member": "Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithNoMessages_ReturnsZero"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithPoisonMessage_FailsInsteadOfRetrying",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a message exceeds max attempts, then RunOnceAsync fails it instead of retrying.",
      "intent": "Verify poison-message handling respects maxAttempts.",
      "scenario": "Given a StubInboxWorkStore message with attempt count at maxAttempts.",
      "behavior": "Then the message is marked failed and not abandoned.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxDispatcherTests.cs",
        "line": 197,
        "member": "Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithPoisonMessage_FailsInsteadOfRetrying"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithValidMessage_ProcessesSuccessfully",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a message has a matching handler, then RunOnceAsync processes it and marks it Done.",
      "intent": "Validate successful handler execution updates inbox status.",
      "scenario": "Given an enqueued inbox message and a TestInboxHandler registered for its topic.",
      "behavior": "Then RunOnceAsync returns 1 and the message status is Done.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxDispatcherTests.cs",
        "line": 65,
        "member": "Incursa.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithValidMessage_ProcessesSuccessfully"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxIntegrationTests.CompleteInboxWorkflow_DirectServiceUsage_WorksEndToEnd",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the inbox service is used end-to-end, then a message transitions to Done and is reported as processed.",
      "intent": "Validate the core inbox workflow from first check through completion.",
      "scenario": "Given a SqlInboxService created with options and a test logger.",
      "behavior": "Then the first AlreadyProcessedAsync returns false, the second returns true, and the DB status is Done.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxIntegrationTests.cs",
        "line": 39,
        "member": "Incursa.Platform.Tests.InboxIntegrationTests.CompleteInboxWorkflow_DirectServiceUsage_WorksEndToEnd"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxIntegrationTests.ConcurrentAccess_WithMultipleThreads_HandledSafely",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When multiple threads call AlreadyProcessedAsync concurrently, then only one record is created and attempts are tracked.",
      "intent": "Ensure inbox deduplication remains safe under concurrent access.",
      "scenario": "Given ten concurrent SqlInboxService instances calling AlreadyProcessedAsync for the same message id.",
      "behavior": "Then all calls return false, one record exists, and Attempts equals the task count.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxIntegrationTests.cs",
        "line": 113,
        "member": "Incursa.Platform.Tests.InboxIntegrationTests.ConcurrentAccess_WithMultipleThreads_HandledSafely"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxIntegrationTests.PoisonMessageWorkflow_MarkingAsDead_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a message is marked dead, then its inbox status is Dead and processed time remains null.",
      "intent": "Verify poison-message handling sets the expected state.",
      "scenario": "Given a SqlInboxService that marks a message as processing and then dead.",
      "behavior": "Then the database row status is Dead and ProcessedUtc is null.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxIntegrationTests.cs",
        "line": 79,
        "member": "Incursa.Platform.Tests.InboxIntegrationTests.PoisonMessageWorkflow_MarkingAsDead_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxRouterIntegrationTests.AddDynamicMultiSqlInbox_CreatesProviderCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When dynamic discovery is used, then a dynamic inbox provider and router can be created.",
      "intent": "Confirm the dynamic provider pattern constructs functional components.",
      "scenario": "Given a SampleInboxDatabaseDiscovery and a FakeTimeProvider with test logging.",
      "behavior": "Then a DynamicInboxWorkStoreProvider and InboxRouter are constructed successfully.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxRouterIntegrationTests.cs",
        "line": 164,
        "member": "Incursa.Platform.Tests.InboxRouterIntegrationTests.AddDynamicMultiSqlInbox_CreatesProviderCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxRouterIntegrationTests.AddDynamicMultiSqlInbox_WithCustomRefreshInterval_ConfiguresCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a custom refresh interval is supplied, then the dynamic provider is created with that setting.",
      "intent": "Ensure dynamic inbox discovery supports custom refresh intervals.",
      "scenario": "Given a SampleInboxDatabaseDiscovery and a custom refresh interval value.",
      "behavior": "Then a DynamicInboxWorkStoreProvider is constructed successfully using that interval.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxRouterIntegrationTests.cs",
        "line": 193,
        "member": "Incursa.Platform.Tests.InboxRouterIntegrationTests.AddDynamicMultiSqlInbox_WithCustomRefreshInterval_ConfiguresCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxRouterIntegrationTests.AddMultiSqlInbox_WithCustomSelectionStrategy_UsesProvidedStrategy",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a custom selection strategy is supplied, then a dispatcher can be built with it.",
      "intent": "Ensure the multi-inbox pattern supports replacing the selection strategy.",
      "scenario": "Given a DrainFirstInboxSelectionStrategy and a configured inbox provider.",
      "behavior": "Then a MultiInboxDispatcher is constructed successfully with the custom strategy.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxRouterIntegrationTests.cs",
        "line": 94,
        "member": "Incursa.Platform.Tests.InboxRouterIntegrationTests.AddMultiSqlInbox_WithCustomSelectionStrategy_UsesProvidedStrategy"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxRouterIntegrationTests.AddMultiSqlInbox_WithListOfOptions_RegistersServicesCorrectlyAsync",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a list of inbox options is used, then the provider and router resolve inboxes for each tenant.",
      "intent": "Validate configured multi-inbox wiring produces usable stores and router outputs.",
      "scenario": "Given two SqlInboxOptions and a ConfiguredInboxWorkStoreProvider with a test logger.",
      "behavior": "Then GetAllStoresAsync returns two stores and the router returns distinct inboxes.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxRouterIntegrationTests.cs",
        "line": 46,
        "member": "Incursa.Platform.Tests.InboxRouterIntegrationTests.AddMultiSqlInbox_WithListOfOptions_RegistersServicesCorrectlyAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxRouterIntegrationTests.AddMultiSqlInbox_WithStoreProviderFactory_CreatesProviderCorrectlyAsync",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the provider factory pattern is used, then a configured inbox store provider is created.",
      "intent": "Verify the factory produces a ConfiguredInboxWorkStoreProvider with expected stores.",
      "scenario": "Given a single SqlInboxOptions entry and a test logger factory.",
      "behavior": "Then GetAllStoresAsync returns one store from the configured provider.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxRouterIntegrationTests.cs",
        "line": 131,
        "member": "Incursa.Platform.Tests.InboxRouterIntegrationTests.AddMultiSqlInbox_WithStoreProviderFactory_CreatesProviderCorrectlyAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxRouterIntegrationTests.DynamicDiscovery_RoutesToCorrectDatabase",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When dynamic discovery loads tenant configurations, then routing returns distinct inboxes per tenant.",
      "intent": "Validate router behavior with dynamically discovered tenants.",
      "scenario": "Given a SampleInboxDatabaseDiscovery returning two tenant configs and an initial provider refresh.",
      "behavior": "Then GetInbox returns non-null, distinct inboxes for both tenant identifiers.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxRouterIntegrationTests.cs",
        "line": 264,
        "member": "Incursa.Platform.Tests.InboxRouterIntegrationTests.DynamicDiscovery_RoutesToCorrectDatabase"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxRouterIntegrationTests.MultiTenantScenario_RoutesToCorrectInbox",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When tenant keys are routed, then each key maps to a distinct inbox instance.",
      "intent": "Demonstrate multi-tenant routing using configured inbox options.",
      "scenario": "Given two SqlInboxOptions entries for Tenant1 and Tenant2.",
      "behavior": "Then the router returns two different inbox instances for each tenant.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxRouterIntegrationTests.cs",
        "line": 221,
        "member": "Incursa.Platform.Tests.InboxRouterIntegrationTests.MultiTenantScenario_RoutesToCorrectInbox"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxRouterTests.InboxRouter_WithGuidKey_ReturnsInbox",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a Guid tenant key is requested, then the router returns an inbox instance.",
      "intent": "Verify inbox routing by Guid key converted to string.",
      "scenario": "Given a ConfiguredInboxWorkStoreProvider configured with a Guid-based connection string.",
      "behavior": "Then GetInbox(Guid) returns a non-null inbox.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxRouterTests.cs",
        "line": 69,
        "member": "Incursa.Platform.Tests.InboxRouterTests.InboxRouter_WithGuidKey_ReturnsInbox"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxRouterTests.InboxRouter_WithInvalidKey_ThrowsException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an unknown tenant key is requested, then the router throws an InvalidOperationException.",
      "intent": "Ensure the router fails fast for missing tenant entries.",
      "scenario": "Given a provider with one configured tenant and a non-existent tenant key.",
      "behavior": "Then GetInbox throws InvalidOperationException.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxRouterTests.cs",
        "line": 99,
        "member": "Incursa.Platform.Tests.InboxRouterTests.InboxRouter_WithInvalidKey_ThrowsException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxRouterTests.InboxRouter_WithNullKey_ThrowsArgumentException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an empty tenant key is requested, then the router throws an ArgumentException.",
      "intent": "Validate tenant key input guarding.",
      "scenario": "Given a router configured with a single tenant and an empty key input.",
      "behavior": "Then GetInbox throws ArgumentException.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxRouterTests.cs",
        "line": 125,
        "member": "Incursa.Platform.Tests.InboxRouterTests.InboxRouter_WithNullKey_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxRouterTests.InboxRouter_WithNullProvider_ThrowsArgumentNullException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the router is constructed with a null provider, then it throws an ArgumentNullException.",
      "intent": "Ensure InboxRouter requires a non-null store provider.",
      "scenario": "Given an attempt to construct InboxRouter with a null IInboxWorkStoreProvider.",
      "behavior": "Then the constructor throws ArgumentNullException.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxRouterTests.cs",
        "line": 151,
        "member": "Incursa.Platform.Tests.InboxRouterTests.InboxRouter_WithNullProvider_ThrowsArgumentNullException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxRouterTests.InboxRouter_WithValidKey_ReturnsInbox",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a configured tenant key is requested, then the router returns an inbox instance.",
      "intent": "Verify inbox routing by string key for configured stores.",
      "scenario": "Given a ConfiguredInboxWorkStoreProvider built from two SqlInboxOptions and a test logger.",
      "behavior": "Then GetInbox returns a non-null inbox for the matching tenant.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxRouterTests.cs",
        "line": 34,
        "member": "Incursa.Platform.Tests.InboxRouterTests.InboxRouter_WithValidKey_ReturnsInbox"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxWorkStoreTests.AbandonAsync_WithClaimedMessage_ReturnsToSeen",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AbandonAsync is called by the owner, then the message returns to Seen status.",
      "intent": "Verify abandoning a claim resets the inbox state.",
      "scenario": "Given a claimed inbox message and the owning token.",
      "behavior": "Then the row status is Seen and OwnerToken is cleared.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxWorkStoreTests.cs",
        "line": 161,
        "member": "Incursa.Platform.Tests.InboxWorkStoreTests.AbandonAsync_WithClaimedMessage_ReturnsToSeen"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxWorkStoreTests.AckAsync_WithClaimedMessage_MarksAsDone",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AckAsync is called by the owner, then the message is marked Done and processed time is set.",
      "intent": "Verify successful acknowledgements update inbox state.",
      "scenario": "Given a claimed inbox message and the owning token.",
      "behavior": "Then the row status is Done, OwnerToken is cleared, and ProcessedUtc is set.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxWorkStoreTests.cs",
        "line": 128,
        "member": "Incursa.Platform.Tests.InboxWorkStoreTests.AckAsync_WithClaimedMessage_MarksAsDone"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithAvailableMessage_ClaimsSuccessfully",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a ready message exists, then ClaimAsync claims it and marks it as processing.",
      "intent": "Verify claims update inbox status and owner token correctly.",
      "scenario": "Given an enqueued inbox message and a generated owner token.",
      "behavior": "Then ClaimAsync returns the message id and the row is marked Processing with the owner token.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxWorkStoreTests.cs",
        "line": 63,
        "member": "Incursa.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithAvailableMessage_ClaimsSuccessfully"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithConcurrentWorkers_EnsuresExclusiveClaims",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When two workers claim concurrently, then only one receives the message.",
      "intent": "Ensure exclusive claims under concurrent callers.",
      "scenario": "Given a single inbox message and two ClaimAsync calls with different owner tokens.",
      "behavior": "Then exactly one claim list contains the message id.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxWorkStoreTests.cs",
        "line": 97,
        "member": "Incursa.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithConcurrentWorkers_EnsuresExclusiveClaims"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithNoMessages_ReturnsEmpty",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When ClaimAsync is called with no pending messages, then it returns an empty set.",
      "intent": "Confirm the inbox work store returns no claims when there is no work.",
      "scenario": "Given an empty inbox table and a SqlInboxWorkStore instance.",
      "behavior": "Then ClaimAsync returns an empty list of message ids.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxWorkStoreTests.cs",
        "line": 45,
        "member": "Incursa.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithNoMessages_ReturnsEmpty"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxWorkStoreTests.FailAsync_WithClaimedMessage_MarksAsDead",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When FailAsync is called by the owner, then the message is marked Dead.",
      "intent": "Verify failed processing sets the inbox message to Dead.",
      "scenario": "Given a claimed inbox message and the owning token.",
      "behavior": "Then the row status is Dead and OwnerToken is cleared.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxWorkStoreTests.cs",
        "line": 193,
        "member": "Incursa.Platform.Tests.InboxWorkStoreTests.FailAsync_WithClaimedMessage_MarksAsDead"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxWorkStoreTests.GetAsync_WithInvalidMessageId_ThrowsException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When GetAsync is called with an unknown message id, then it throws an InvalidOperationException.",
      "intent": "Ensure missing inbox messages result in a failure.",
      "scenario": "Given a SqlInboxWorkStore with no message matching the requested id.",
      "behavior": "Then GetAsync throws InvalidOperationException.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxWorkStoreTests.cs",
        "line": 284,
        "member": "Incursa.Platform.Tests.InboxWorkStoreTests.GetAsync_WithInvalidMessageId_ThrowsException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxWorkStoreTests.GetAsync_WithValidMessageId_ReturnsMessage",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When GetAsync is called with a valid message id, then it returns the stored message details.",
      "intent": "Verify inbox work store retrieval returns expected fields.",
      "scenario": "Given an enqueued inbox message with a known id.",
      "behavior": "Then GetAsync returns a message with matching id, source, topic, payload, and attempt.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxWorkStoreTests.cs",
        "line": 258,
        "member": "Incursa.Platform.Tests.InboxWorkStoreTests.GetAsync_WithValidMessageId_ReturnsMessage"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.InboxWorkStoreTests.OwnerTokenEnforcement_OnlyAllowsOperationsByOwner",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a non-owner tries to acknowledge a claim, then the message remains in Processing.",
      "intent": "Ensure owner token enforcement prevents unauthorized state changes.",
      "scenario": "Given a message claimed by one owner and AckAsync called with a different owner token.",
      "behavior": "Then the row status remains Processing with the original owner token.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/InboxWorkStoreTests.cs",
        "line": 225,
        "member": "Incursa.Platform.Tests.InboxWorkStoreTests.OwnerTokenEnforcement_OnlyAllowsOperationsByOwner"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenAllStepsCompleted_MarksJoinAsCompleted",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When all join steps are completed, then HandleAsync marks the join as completed.",
      "intent": "Ensure successful joins transition to the Completed status.",
      "scenario": "Given a join expecting two steps with both steps marked complete.",
      "behavior": "Then the join status is updated to Completed.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/JoinWaitHandlerTests.cs",
        "line": 144,
        "member": "Incursa.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenAllStepsCompleted_MarksJoinAsCompleted"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenCompletedSuccessfully_EnqueuesFollowUpMessage",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a join completes with follow-up settings, then HandleAsync enqueues the follow-up outbox message.",
      "intent": "Verify that completion triggers an additional outbox message when configured.",
      "scenario": "Given a completed join and a JoinWaitPayload containing OnCompleteTopic and OnCompletePayload.",
      "behavior": "Then the outbox table contains a message with the follow-up topic.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/JoinWaitHandlerTests.cs",
        "line": 252,
        "member": "Incursa.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenCompletedSuccessfully_EnqueuesFollowUpMessage"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenFailIfAnyStepFailedIsFalse_CompletesEvenWithFailures",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When FailIfAnyStepFailed is false, then HandleAsync completes the join even if some steps failed.",
      "intent": "Allow joins to complete successfully when failure tolerance is enabled.",
      "scenario": "Given a join with one completed step, one failed step, and FailIfAnyStepFailed set to false.",
      "behavior": "Then the join status is updated to Completed.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/JoinWaitHandlerTests.cs",
        "line": 361,
        "member": "Incursa.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenFailIfAnyStepFailedIsFalse_CompletesEvenWithFailures"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenJoinAlreadyCompleted_IsIdempotent",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a join is already completed, then repeated HandleAsync calls leave it completed.",
      "intent": "Ensure join completion handling is idempotent.",
      "scenario": "Given a join already marked Completed and a join.wait message handled twice.",
      "behavior": "Then the join status remains Completed after both calls.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/JoinWaitHandlerTests.cs",
        "line": 309,
        "member": "Incursa.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenJoinAlreadyCompleted_IsIdempotent"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenJoinNotReady_ThrowsJoinNotReadyException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a join has incomplete steps, then HandleAsync throws JoinNotReadyException.",
      "intent": "Prevent completion handling until all expected steps are finished.",
      "scenario": "Given a join expecting three steps with only one step marked complete and FailIfAnyStepFailed enabled.",
      "behavior": "Then the handler throws JoinNotReadyException.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/JoinWaitHandlerTests.cs",
        "line": 97,
        "member": "Incursa.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenJoinNotReady_ThrowsJoinNotReadyException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenSomeStepsFailed_MarksJoinAsFailed",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When any join step fails and failures are not allowed, then HandleAsync marks the join as failed.",
      "intent": "Enforce failure propagation when FailIfAnyStepFailed is true.",
      "scenario": "Given a join with one completed step, one failed step, and FailIfAnyStepFailed enabled.",
      "behavior": "Then the join status is updated to Failed.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/JoinWaitHandlerTests.cs",
        "line": 198,
        "member": "Incursa.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenSomeStepsFailed_MarksJoinAsFailed"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.LeaseRunnerTests.AcquireAsync_WithAvailableLease_ReturnsRunnerInstance",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a lease is available, then AcquireAsync returns a runner with initialized state.",
      "intent": "Validate LeaseRunner acquisition returns a usable runner instance.",
      "scenario": "Given a unique lease name, owner, and lease duration using the real LeaseApi.",
      "behavior": "Then the runner is not null, has expected name/owner, and is not marked lost.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/LeaseRunnerTests.cs",
        "line": 58,
        "member": "Incursa.Platform.Tests.LeaseRunnerTests.AcquireAsync_WithAvailableLease_ReturnsRunnerInstance"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.LeaseRunnerTests.AcquireAsync_WithUnavailableLease_ReturnsNull",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a lease is already held, then a second AcquireAsync returns null.",
      "intent": "Ensure LeaseRunner does not acquire a lease already owned by another runner.",
      "scenario": "Given owner1 acquires a lease and owner2 attempts to acquire the same lease immediately after.",
      "behavior": "Then the second acquisition returns null.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/LeaseRunnerTests.cs",
        "line": 101,
        "member": "Incursa.Platform.Tests.LeaseRunnerTests.AcquireAsync_WithUnavailableLease_ReturnsNull"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.LeaseRunnerTests.DisposedRunner_DoesNotRenew",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a runner is disposed, then TryRenewNowAsync returns false.",
      "intent": "Ensure disposed runners do not attempt renewals.",
      "scenario": "Given a LeaseRunner that has been disposed after acquisition.",
      "behavior": "Then TryRenewNowAsync returns false.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/LeaseRunnerTests.cs",
        "line": 287,
        "member": "Incursa.Platform.Tests.LeaseRunnerTests.DisposedRunner_DoesNotRenew"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.LeaseRunnerTests.MonotonicRenewal_WithCustomRenewPercent_RenewsAtCorrectInterval",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a custom renew percent is used, then automatic renewal keeps the runner valid past the threshold.",
      "intent": "Validate that automatic renewal triggers early enough to avoid lease loss.",
      "scenario": "Given a short lease duration with a 50% renew percent and a wait past half the duration.",
      "behavior": "Then the runner remains active and its cancellation token is not canceled.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/LeaseRunnerTests.cs",
        "line": 241,
        "member": "Incursa.Platform.Tests.LeaseRunnerTests.MonotonicRenewal_WithCustomRenewPercent_RenewsAtCorrectInterval"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.LeaseRunnerTests.RenewTimer_UsesMonotonicClockAcrossClockSkewAndGcPauses",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the monotonic clock jumps forward, then renewal scheduling advances based on monotonic time without over-renewing.",
      "intent": "Confirm renewal scheduling relies on monotonic time even across simulated pauses.",
      "scenario": "Given a LeaseRunner using a FakeMonotonicClock and reflection to inspect the next renewal timestamp.",
      "behavior": "Then the scheduled renewal time increases after the pause and remains stable on an immediate retry.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/LeaseRunnerTests.cs",
        "line": 328,
        "member": "Incursa.Platform.Tests.LeaseRunnerTests.RenewTimer_UsesMonotonicClockAcrossClockSkewAndGcPauses"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.LeaseRunnerTests.ThrowIfLost_WhenLeaseIsValid_DoesNotThrow",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a lease is still valid, then ThrowIfLost does not throw.",
      "intent": "Ensure the guard does not falsely signal a lost lease.",
      "scenario": "Given a LeaseRunner acquired with a valid lease and no renewal failures.",
      "behavior": "Then calling ThrowIfLost completes without exception.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/LeaseRunnerTests.cs",
        "line": 201,
        "member": "Incursa.Platform.Tests.LeaseRunnerTests.ThrowIfLost_WhenLeaseIsValid_DoesNotThrow"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.LeaseRunnerTests.TryRenewNowAsync_WithValidRunner_SucceedsAndExtendsLease",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When TryRenewNowAsync is called on a valid runner, then renewal succeeds and the lease is not lost.",
      "intent": "Confirm manual renewal succeeds for a current lease owner.",
      "scenario": "Given a LeaseRunner acquired with a valid lease and owner.",
      "behavior": "Then TryRenewNowAsync returns true and IsLost remains false.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/LeaseRunnerTests.cs",
        "line": 157,
        "member": "Incursa.Platform.Tests.LeaseRunnerTests.TryRenewNowAsync_WithValidRunner_SucceedsAndExtendsLease"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.LeaseTests.AcquireAsync_WithExpiredLease_SucceedsAndReturnsNewExpiry",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a prior lease has expired, then a new owner can acquire it and receives a fresh expiry.",
      "intent": "Confirm expired leases can be reacquired by another owner.",
      "scenario": "Given a short lease acquired by owner1 and allowed to expire before owner2 acquires it.",
      "behavior": "Then AcquireAsync returns acquired true with a new lease expiry after server time.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/LeaseTests.cs",
        "line": 120,
        "member": "Incursa.Platform.Tests.LeaseTests.AcquireAsync_WithExpiredLease_SucceedsAndReturnsNewExpiry"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.LeaseTests.AcquireAsync_WithFreeResource_SucceedsAndReturnsServerTime",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a free lease is acquired, then the acquisition succeeds and returns server time with a calculated expiry.",
      "intent": "Verify successful acquisition returns timing data from the server.",
      "scenario": "Given a new lease name, owner, and lease duration against the lease schema.",
      "behavior": "Then AcquireAsync returns acquired true with a non-default server time and an expiry near the expected duration.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/LeaseTests.cs",
        "line": 52,
        "member": "Incursa.Platform.Tests.LeaseTests.AcquireAsync_WithFreeResource_SucceedsAndReturnsServerTime"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.LeaseTests.AcquireAsync_WithOccupiedResource_FailsAndReturnsServerTime",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a lease is already held, then a second acquisition attempt fails and returns server time without an expiry.",
      "intent": "Ensure AcquireAsync reports contention without granting a lease.",
      "scenario": "Given owner1 acquires the lease and owner2 attempts to acquire it before expiry.",
      "behavior": "Then AcquireAsync returns acquired false with server time set and a null lease expiry.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/LeaseTests.cs",
        "line": 86,
        "member": "Incursa.Platform.Tests.LeaseTests.AcquireAsync_WithOccupiedResource_FailsAndReturnsServerTime"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.LeaseTests.RenewAsync_WithExpiredLease_FailsAndReturnsServerTime",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a lease has already expired, then renewal fails and no expiry is returned.",
      "intent": "Ensure expired leases cannot be renewed.",
      "scenario": "Given a short lease for an owner that is allowed to expire before renewal.",
      "behavior": "Then RenewAsync returns renewed false with server time set and a null lease expiry.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/LeaseTests.cs",
        "line": 230,
        "member": "Incursa.Platform.Tests.LeaseTests.RenewAsync_WithExpiredLease_FailsAndReturnsServerTime"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.LeaseTests.RenewAsync_WithValidOwner_SucceedsAndExtendsLease",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the current lease owner renews, then the lease is extended and server time advances.",
      "intent": "Validate successful renewals extend the lease window.",
      "scenario": "Given a lease acquired by a specific owner and a short delay before renewal.",
      "behavior": "Then RenewAsync returns renewed true with a later server time and a later lease expiry.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/LeaseTests.cs",
        "line": 158,
        "member": "Incursa.Platform.Tests.LeaseTests.RenewAsync_WithValidOwner_SucceedsAndExtendsLease"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.LeaseTests.RenewAsync_WithWrongOwner_FailsAndReturnsServerTime",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a non-owner attempts to renew a lease, then renewal fails and no expiry is returned.",
      "intent": "Prevent renewals from unauthorized owners.",
      "scenario": "Given owner1 acquires the lease and owner2 attempts to renew it.",
      "behavior": "Then RenewAsync returns renewed false with server time set and a null lease expiry.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/LeaseTests.cs",
        "line": 196,
        "member": "Incursa.Platform.Tests.LeaseTests.RenewAsync_WithWrongOwner_FailsAndReturnsServerTime"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.ManualSchemaExportTests.DeploySchemaAndExportToSqlProject",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "This manual test deploys all platform schemas to a fresh SQL Server container and then uses SqlPackage to extract the schema and update the SQL Server project. This test creates two separate databases and two separate dacpac files: 1. Control Plane database - contains Central Metrics schema 2. Multi-Database schema - contains Outbox, Inbox, Scheduler, Lease, Fanout, Metrics, and DistributedLock schemas Note: This test is skipped by default to prevent it from running in CI. To run it, remove the Skip parameter or run it explicitly using the test filter.",
      "intent": "Provide a manual workflow for updating the SQL Server project from deployed schema.",
      "scenario": "Given an initialized SQL Server container and a valid connection string for schema deployment.",
      "behavior": "Then control plane and multi-database schemas are deployed and the extraction steps complete without error.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/ManualSchemaExportTests.cs",
        "line": 91,
        "member": "Incursa.Platform.Tests.ManualSchemaExportTests.DeploySchemaAndExportToSqlProject"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.MetricsSchemaTests.MetricDef_Table_Should_Exist",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the metrics schema is deployed, then the MetricDef table exists in the infra schema.",
      "intent": "Verify the schema deployment creates the metric definition table.",
      "scenario": "Given EnsureMetricsSchemaAsync has run and a SQL connection is open.",
      "behavior": "Then the information schema query returns one MetricDef table.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/MetricsSchemaTests.cs",
        "line": 44,
        "member": "Incursa.Platform.Tests.MetricsSchemaTests.MetricDef_Table_Should_Exist"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.MetricsSchemaTests.MetricPointMinute_Table_Should_Exist",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the metrics schema is deployed, then the MetricPointMinute table exists in the infra schema.",
      "intent": "Verify the schema deployment creates the minute-bucket metric points table.",
      "scenario": "Given EnsureMetricsSchemaAsync has run and a SQL connection is open.",
      "behavior": "Then the information schema query returns one MetricPointMinute table.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/MetricsSchemaTests.cs",
        "line": 76,
        "member": "Incursa.Platform.Tests.MetricsSchemaTests.MetricPointMinute_Table_Should_Exist"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.MetricsSchemaTests.MetricSeries_Table_Should_Exist",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the metrics schema is deployed, then the MetricSeries table exists in the infra schema.",
      "intent": "Verify the schema deployment creates the metric series table.",
      "scenario": "Given EnsureMetricsSchemaAsync has run and a SQL connection is open.",
      "behavior": "Then the information schema query returns one MetricSeries table.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/MetricsSchemaTests.cs",
        "line": 60,
        "member": "Incursa.Platform.Tests.MetricsSchemaTests.MetricSeries_Table_Should_Exist"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.MetricsSchemaTests.SpUpsertMetricPointMinute_Should_Insert_And_Update",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When SpUpsertMetricPointMinute is called twice for the same bucket, then the row is updated additively.",
      "intent": "Validate the minute-bucket upsert merges sums, counts, and min/max/last values.",
      "scenario": "Given an existing series id and two upserts for the same bucket start time.",
      "behavior": "Then the MetricPointMinute row reflects summed counts, min/max, and last value.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/MetricsSchemaTests.cs",
        "line": 119,
        "member": "Incursa.Platform.Tests.MetricsSchemaTests.SpUpsertMetricPointMinute_Should_Insert_And_Update"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.MetricsSchemaTests.SpUpsertSeries_Should_Create_Series",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When SpUpsertSeries executes with a new series definition, then it returns a positive series id.",
      "intent": "Confirm the series upsert procedure creates or locates a series record.",
      "scenario": "Given a SQL connection and parameters for a new metric series.",
      "behavior": "Then the output @SeriesId is greater than zero.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/MetricsSchemaTests.cs",
        "line": 92,
        "member": "Incursa.Platform.Tests.MetricsSchemaTests.SpUpsertSeries_Should_Create_Series"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.ListRegistration_WiresControlPlaneAndDiscoversDatabases",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When list-based control plane registration is built, then configuration and discovery expose all tenant databases.",
      "intent": "Validate list-based control plane wiring and tenant discovery.",
      "scenario": "Given two tenant databases, a control plane database, and services configured with list-based registration.",
      "behavior": "Then the configuration reflects control plane settings and discovery/store providers return all tenants.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 56,
        "member": "Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.ListRegistration_WiresControlPlaneAndDiscoversDatabases"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_Discovery_MultipleTenants",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When discovery-based multi-tenant outbox dispatch runs, then one message is processed per tenant.",
      "intent": "Validate outbox dispatch for discovery-based registration across multiple tenants.",
      "scenario": "Given two tenant databases, a control plane database, and a host configured with discovery-based registration.",
      "behavior": "Then each tenant outbox marks one message as processed after dispatch.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 174,
        "member": "Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_Discovery_MultipleTenants"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_Discovery_SingleTenant",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When discovery-based outbox dispatch runs for a single tenant, then the message is processed once.",
      "intent": "Confirm outbox dispatch works for a single tenant using discovery-based registration.",
      "scenario": "Given one tenant database, a control plane database, and a host configured with discovery-based registration.",
      "behavior": "Then the tenant outbox contains one processed message.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 212,
        "member": "Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_Discovery_SingleTenant"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_List_MultipleTenants",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When list-based multi-tenant outbox dispatch runs, then one message is processed per tenant.",
      "intent": "Ensure outbox dispatch processes tenant messages with list-based registration.",
      "scenario": "Given two tenant databases, a control plane database, and a host with a CapturingOutboxHandler sink.",
      "behavior": "Then each tenant payload is handled and each tenant outbox marks one row as processed.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 100,
        "member": "Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_List_MultipleTenants"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_List_SingleTenant",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When list-based outbox dispatch runs for a single tenant, then the message is processed once.",
      "intent": "Confirm outbox dispatch works for a single tenant using list-based registration.",
      "scenario": "Given one tenant database, a control plane database, and a host with a CapturingOutboxHandler sink.",
      "behavior": "Then the tenant outbox contains one processed message.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 139,
        "member": "Incursa.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_List_SingleTenant"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.MultiInboxDispatcherLeaseTests.MultiInboxDispatcher_WithLease_PreventsConcurrentProcessing",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When two dispatchers share a lease router, then only one processes all inbox messages while the other is blocked.",
      "intent": "Confirm that lease-based coordination prevents concurrent processing across dispatchers.",
      "scenario": "Given an inbox table with five messages, a TestLeaseRouter, and two MultiInboxDispatcher instances using the same store.",
      "behavior": "Then one dispatcher processes all five messages and the other processes none, with a total of five processed.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/MultiInboxDispatcherLeaseTests.cs",
        "line": 52,
        "member": "Incursa.Platform.Tests.MultiInboxDispatcherLeaseTests.MultiInboxDispatcher_WithLease_PreventsConcurrentProcessing"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.MultiInboxDispatcherLeaseTests.MultiInboxDispatcher_WithoutLease_AllowsProcessing",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a dispatcher has no lease router, then it processes all available inbox messages.",
      "intent": "Validate that processing is unrestricted when lease coordination is disabled.",
      "scenario": "Given an inbox table with three messages and a MultiInboxDispatcher configured with a null lease router.",
      "behavior": "Then RunOnceAsync returns a count of three and the handler records three processed messages.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/MultiInboxDispatcherLeaseTests.cs",
        "line": 172,
        "member": "Incursa.Platform.Tests.MultiInboxDispatcherLeaseTests.MultiInboxDispatcher_WithoutLease_AllowsProcessing"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.MultiOutboxDispatcherLeaseTests.MultiOutboxDispatcher_WithLease_PreventsConcurrentProcessing",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When two dispatchers run with a shared lease router, then only one processes the queued messages.",
      "intent": "Verify the lease gate prevents concurrent processing of the same outbox.",
      "scenario": "Given an outbox table with five messages, a lease router, and two dispatchers running concurrently.",
      "behavior": "Then one dispatcher processes all messages while the other processes none.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/MultiOutboxDispatcherLeaseTests.cs",
        "line": 44,
        "member": "Incursa.Platform.Tests.MultiOutboxDispatcherLeaseTests.MultiOutboxDispatcher_WithLease_PreventsConcurrentProcessing"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.MultiOutboxDispatcherLeaseTests.MultiOutboxDispatcher_WithoutLease_AllowsProcessing",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the dispatcher runs without a lease router, then it processes all available messages.",
      "intent": "Ensure outbox processing proceeds without lease coordination when disabled.",
      "scenario": "Given an outbox table with three messages and a dispatcher with no lease router.",
      "behavior": "Then RunOnceAsync returns three and all messages are handled.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/MultiOutboxDispatcherLeaseTests.cs",
        "line": 155,
        "member": "Incursa.Platform.Tests.MultiOutboxDispatcherLeaseTests.MultiOutboxDispatcher_WithoutLease_AllowsProcessing"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.MultiOutboxDispatcherTests.MultiOutboxDispatcher_ProcessesMessagesFromMultipleStores",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the dispatcher runs across multiple stores, then it processes messages from each store.",
      "intent": "Validate multi-store dispatching with round-robin selection.",
      "scenario": "Given two outbox schemas with one ready message each and a round-robin strategy.",
      "behavior": "Then two runs process both messages and mark them as processed in each schema.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/MultiOutboxDispatcherTests.cs",
        "line": 43,
        "member": "Incursa.Platform.Tests.MultiOutboxDispatcherTests.MultiOutboxDispatcher_ProcessesMessagesFromMultipleStores"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.MultiOutboxDispatcherTests.MultiOutboxDispatcher_WithDrainFirstStrategy_DrainsOneStoreBeforeMoving",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When using the drain-first strategy, then the dispatcher drains one store before moving on.",
      "intent": "Verify drain-first selection keeps working a store until it is empty.",
      "scenario": "Given a store with three ready messages and drain-first selection with batch size one.",
      "behavior": "Then successive runs process three messages and the fourth run returns zero.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/MultiOutboxDispatcherTests.cs",
        "line": 157,
        "member": "Incursa.Platform.Tests.MultiOutboxDispatcherTests.MultiOutboxDispatcher_WithDrainFirstStrategy_DrainsOneStoreBeforeMoving"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OptionsValidationTests.AddSqlFanout_ThrowsForMissingConnectionString",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlFanout is called with a missing connection string, then it throws an OptionsValidationException.",
      "intent": "Ensure fanout registration validates required connection string settings.",
      "scenario": "Given a ServiceCollection and SqlFanoutOptions with a whitespace ConnectionString.",
      "behavior": "Then AddSqlFanout throws OptionsValidationException.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OptionsValidationTests.cs",
        "line": 129,
        "member": "Incursa.Platform.Tests.OptionsValidationTests.AddSqlFanout_ThrowsForMissingConnectionString"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OptionsValidationTests.AddSqlFanout_ThrowsForMissingSchemaName",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlFanout is called with a missing schema name, then it throws an OptionsValidationException.",
      "intent": "Ensure fanout registration requires a non-empty schema name.",
      "scenario": "Given SqlFanoutOptions with a valid connection string and an empty SchemaName.",
      "behavior": "Then AddSqlFanout throws OptionsValidationException.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OptionsValidationTests.cs",
        "line": 145,
        "member": "Incursa.Platform.Tests.OptionsValidationTests.AddSqlFanout_ThrowsForMissingSchemaName"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OptionsValidationTests.AddSqlInbox_ThrowsForMissingConnectionString",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlInbox is called with a missing connection string, then it throws an OptionsValidationException.",
      "intent": "Ensure inbox registration validates required connection string settings.",
      "scenario": "Given a ServiceCollection and SqlInboxOptions with an empty ConnectionString.",
      "behavior": "Then AddSqlInbox throws OptionsValidationException.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OptionsValidationTests.cs",
        "line": 79,
        "member": "Incursa.Platform.Tests.OptionsValidationTests.AddSqlInbox_ThrowsForMissingConnectionString"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OptionsValidationTests.AddSqlInbox_ThrowsForMissingSchemaName",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlInbox is called with a missing schema name, then it throws an OptionsValidationException.",
      "intent": "Ensure inbox registration requires a non-empty schema name.",
      "scenario": "Given SqlInboxOptions with a valid connection string and an empty SchemaName.",
      "behavior": "Then AddSqlInbox throws OptionsValidationException.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OptionsValidationTests.cs",
        "line": 95,
        "member": "Incursa.Platform.Tests.OptionsValidationTests.AddSqlInbox_ThrowsForMissingSchemaName"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OptionsValidationTests.AddSqlInbox_ThrowsForZeroCleanupInterval",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlInbox is called with cleanup enabled and a zero interval, then it throws an OptionsValidationException.",
      "intent": "Validate inbox cleanup interval must be greater than zero when enabled.",
      "scenario": "Given SqlInboxOptions with EnableAutomaticCleanup true and CleanupInterval set to TimeSpan.Zero.",
      "behavior": "Then AddSqlInbox throws OptionsValidationException.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OptionsValidationTests.cs",
        "line": 43,
        "member": "Incursa.Platform.Tests.OptionsValidationTests.AddSqlInbox_ThrowsForZeroCleanupInterval"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OptionsValidationTests.AddSqlOutbox_ThrowsForMissingConnectionString",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlOutbox is called with a missing connection string, then it throws an OptionsValidationException.",
      "intent": "Ensure outbox registration validates required connection string settings.",
      "scenario": "Given a ServiceCollection and SqlOutboxOptions with an empty ConnectionString.",
      "behavior": "Then AddSqlOutbox throws OptionsValidationException.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OptionsValidationTests.cs",
        "line": 27,
        "member": "Incursa.Platform.Tests.OptionsValidationTests.AddSqlOutbox_ThrowsForMissingConnectionString"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OptionsValidationTests.AddSqlOutbox_ThrowsForMissingSchemaName",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlOutbox is called with a missing schema name, then it throws an OptionsValidationException.",
      "intent": "Ensure outbox registration requires a non-empty schema name.",
      "scenario": "Given SqlOutboxOptions with a valid connection string and an empty SchemaName.",
      "behavior": "Then AddSqlOutbox throws OptionsValidationException.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OptionsValidationTests.cs",
        "line": 112,
        "member": "Incursa.Platform.Tests.OptionsValidationTests.AddSqlOutbox_ThrowsForMissingSchemaName"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OptionsValidationTests.AddSqlOutbox_ThrowsForZeroCleanupInterval",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlOutbox is called with cleanup enabled and a zero interval, then it throws an OptionsValidationException.",
      "intent": "Validate outbox cleanup interval must be greater than zero when enabled.",
      "scenario": "Given SqlOutboxOptions with EnableAutomaticCleanup true and CleanupInterval set to TimeSpan.Zero.",
      "behavior": "Then AddSqlOutbox throws OptionsValidationException.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OptionsValidationTests.cs",
        "line": 61,
        "member": "Incursa.Platform.Tests.OptionsValidationTests.AddSqlOutbox_ThrowsForZeroCleanupInterval"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxCleanupTests.CleanupService_GracefullyHandles_MissingStoredProcedure",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the cleanup stored procedure is missing, then the cleanup service runs without crashing.",
      "intent": "Ensure the outbox cleanup service tolerates missing schema deployment.",
      "scenario": "Given the cleanup procedure dropped and a short cleanup interval.",
      "behavior": "Then StartAsync completes without throwing and the procedure remains missing.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxCleanupTests.cs",
        "line": 221,
        "member": "Incursa.Platform.Tests.OutboxCleanupTests.CleanupService_GracefullyHandles_MissingStoredProcedure"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxCleanupTests.Cleanup_DeletesOldProcessedMessages",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When cleanup runs with a retention window, then only processed outbox rows older than the window are deleted.",
      "intent": "Verify the outbox cleanup procedure removes stale processed rows.",
      "scenario": "Given old processed, recent processed, and unprocessed outbox rows before cleanup.",
      "behavior": "Then only the old processed message is deleted and other rows remain.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxCleanupTests.cs",
        "line": 45,
        "member": "Incursa.Platform.Tests.OutboxCleanupTests.Cleanup_DeletesOldProcessedMessages"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxCleanupTests.Cleanup_RespectsRetentionPeriod",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When cleanup runs with a 10-day retention period, then only rows older than 10 days are deleted.",
      "intent": "Confirm retention period filtering for outbox cleanup.",
      "scenario": "Given processed outbox rows at 30, 15, 7, 3, and 1 days old.",
      "behavior": "Then only the 30- and 15-day rows are deleted and newer rows remain.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxCleanupTests.cs",
        "line": 163,
        "member": "Incursa.Platform.Tests.OutboxCleanupTests.Cleanup_RespectsRetentionPeriod"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxCleanupTests.Cleanup_WithNoOldMessages_DeletesNothing",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When cleanup runs and no processed rows are older than retention, then nothing is deleted.",
      "intent": "Ensure cleanup is a no-op when no rows qualify for deletion.",
      "scenario": "Given only a recent processed outbox row before cleanup.",
      "behavior": "Then the cleanup procedure deletes zero rows and the message remains.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxCleanupTests.cs",
        "line": 122,
        "member": "Incursa.Platform.Tests.OutboxCleanupTests.Cleanup_WithNoOldMessages_DeletesNothing"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithAllParameters_EnqueuesCorrectMessage",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When EnqueueJoinWaitAsync is called with all parameters, then the join.wait payload persists those values.",
      "intent": "Verify join wait enqueue serializes all provided topics, payloads, and flags.",
      "scenario": "Given an outbox service with join support and explicit on-complete/on-fail details.",
      "behavior": "Then the persisted join.wait payload matches all provided parameters.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxExtensionsTests.cs",
        "line": 66,
        "member": "Incursa.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithAllParameters_EnqueuesCorrectMessage"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithFailIfAnyStepFailedFalse_EnqueuesCorrectMessage",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When failIfAnyStepFailed is false, then the payload preserves the false flag and provided completion topic.",
      "intent": "Ensure the fail-if-any-step flag is stored as provided.",
      "scenario": "Given an outbox service and EnqueueJoinWaitAsync called with failIfAnyStepFailed = false.",
      "behavior": "Then the join.wait payload has FailIfAnyStepFailed = false and the completion topic set.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxExtensionsTests.cs",
        "line": 141,
        "member": "Incursa.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithFailIfAnyStepFailedFalse_EnqueuesCorrectMessage"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithMinimalParameters_EnqueuesCorrectMessage",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When EnqueueJoinWaitAsync is called with only a join id, then defaults are applied in the payload.",
      "intent": "Confirm minimal arguments still produce a valid join.wait payload.",
      "scenario": "Given an outbox service and a generated JoinIdentifier.",
      "behavior": "Then the payload has FailIfAnyStepFailed = true and null on-complete/on-fail fields.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxExtensionsTests.cs",
        "line": 108,
        "member": "Incursa.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithMinimalParameters_EnqueuesCorrectMessage"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_DefaultBackoff_ExponentialWithJitter",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When DefaultBackoff is computed for increasing attempts, then delays grow with jitter and are capped.",
      "intent": "Verify the default backoff function uses exponential growth with jitter bounds.",
      "scenario": "Given multiple attempt values passed to MultiOutboxDispatcher.DefaultBackoff.",
      "behavior": "Then delays fall within expected ranges and do not exceed the maximum cap.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxHandlerTests.cs",
        "line": 398,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_DefaultBackoff_ExponentialWithJitter"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_HandlerThrows_ReschedulesWithBackoff",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a handler throws, then the dispatcher reschedules the message with a backoff delay.",
      "intent": "Verify failing handlers trigger reschedule with an error message.",
      "scenario": "Given a TestHandler configured to throw and a message with RetryCount > 0.",
      "behavior": "Then the store records a reschedule with a positive delay and the handler error.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxHandlerTests.cs",
        "line": 177,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_HandlerThrows_ReschedulesWithBackoff"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsAtCorrectLevels",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When processing both a handled and an unhandled message, then logs are emitted at expected levels.",
      "intent": "Validate dispatcher logging includes information, debug, and warning entries.",
      "scenario": "Given a capturing logger, one message with a handler, and one without a handler.",
      "behavior": "Then log entries include Information for batch, Debug for processing, and Warning for no handler.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxHandlerTests.cs",
        "line": 329,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsAtCorrectLevels"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a message is processed successfully, then the dispatcher completes and dispatches it.",
      "intent": "Confirm the successful path results in handler execution and dispatch.",
      "scenario": "Given a TestOutboxStore with one message and a matching handler.",
      "behavior": "Then the handler is invoked once and the message is marked dispatched.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxHandlerTests.cs",
        "line": 255,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsErrors_WhenHandlerFails",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a handler fails, then the dispatcher records an error and reschedules the message.",
      "intent": "Ensure handler exceptions result in reschedule entries with errors.",
      "scenario": "Given a TestHandler that throws and a TestOutboxStore with one message.",
      "behavior": "Then the handler is invoked and the reschedule error contains the exception message.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxHandlerTests.cs",
        "line": 292,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsErrors_WhenHandlerFails"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_NoHandler_MarksAsFailed",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When no handler exists for a message topic, then the dispatcher marks the message as failed.",
      "intent": "Ensure unknown topics fail fast instead of being rescheduled.",
      "scenario": "Given a TestOutboxStore with one message and an empty resolver.",
      "behavior": "Then RunOnceAsync records a failed message with a no-handler error.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxHandlerTests.cs",
        "line": 144,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_NoHandler_MarksAsFailed"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_ProcessSingleMessage_Success",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a single outbox message has a matching handler, then it is processed and dispatched.",
      "intent": "Verify successful message handling marks the item as dispatched.",
      "scenario": "Given a TestOutboxStore with one message and a handler for its topic.",
      "behavior": "Then RunOnceAsync returns 1 and the store records a dispatched id.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxHandlerTests.cs",
        "line": 109,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_ProcessSingleMessage_Success"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_WithPoisonMessage_FailsWhenMaxAttemptsReached",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a message hits max attempts, then the dispatcher fails it instead of rescheduling.",
      "intent": "Ensure poison messages are failed when retries are exhausted.",
      "scenario": "Given a message with RetryCount = 2 and maxAttempts = 3 with a failing handler.",
      "behavior": "Then the message is added to FailedMessages and not rescheduled.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxHandlerTests.cs",
        "line": 216,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_WithPoisonMessage_FailsWhenMaxAttemptsReached"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxHandlerTests.OutboxHandlerResolver_CaseInsensitive",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When handler topics are looked up with different casing, then the resolver still matches them.",
      "intent": "Ensure topic matching is case-insensitive.",
      "scenario": "Given a resolver with a handler for \"Email.Send\" and lookups using different casing.",
      "behavior": "Then TryGet succeeds for lower-case and upper-case topic strings.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxHandlerTests.cs",
        "line": 90,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.OutboxHandlerResolver_CaseInsensitive"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxHandlerTests.OutboxHandlerResolver_WithHandlers_ResolvesCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the resolver is given handlers, then it resolves matching topics and rejects unknown ones.",
      "intent": "Validate handler lookup works for registered topics.",
      "scenario": "Given an OutboxHandlerResolver initialized with three TestHandler instances.",
      "behavior": "Then TryGet returns true for known topics and false for an unknown topic.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxHandlerTests.cs",
        "line": 63,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.OutboxHandlerResolver_WithHandlers_ResolvesCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxHandlerTests.ServiceCollection_AddOutboxHandler_Factory_RegistersHandler",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddOutboxHandler is called with a factory, then it registers a singleton IOutboxHandler factory.",
      "intent": "Confirm DI registration for factory-based handler creation.",
      "scenario": "Given a ServiceCollection and AddOutboxHandler with a factory delegate.",
      "behavior": "Then the service descriptor contains an implementation factory with singleton lifetime.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxHandlerTests.cs",
        "line": 449,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.ServiceCollection_AddOutboxHandler_Factory_RegistersHandler"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxHandlerTests.ServiceCollection_AddOutboxHandler_RegistersHandler",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddOutboxHandler is called with a handler type, then it registers a singleton IOutboxHandler.",
      "intent": "Confirm DI registration for handler types.",
      "scenario": "Given a ServiceCollection and AddOutboxHandler<TestHandler> invocation.",
      "behavior": "Then the service descriptor registers TestHandler as a singleton IOutboxHandler.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxHandlerTests.cs",
        "line": 428,
        "member": "Incursa.Platform.Tests.OutboxHandlerTests.ServiceCollection_AddOutboxHandler_RegistersHandler"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxJoinTests.AttachMessageToJoinAsync_CalledTwice_IsIdempotent",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When attaching the same message twice, then only one join-member row exists.",
      "intent": "Ensure attaching a message is idempotent.",
      "scenario": "Create a join and message, then call AttachMessageToJoinAsync twice.",
      "behavior": "The OutboxJoinMember table still contains a single row for the pair.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxJoinTests.cs",
        "line": 192,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.AttachMessageToJoinAsync_CalledTwice_IsIdempotent"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxJoinTests.AttachMessageToJoinAsync_WithValidIds_CreatesAssociation",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When attaching an outbox message to a join, then a join-member row is created.",
      "intent": "Verify join-member mappings are persisted.",
      "scenario": "Create a join and an outbox message, then attach the message to the join.",
      "behavior": "The OutboxJoinMember table contains one row for the join/message pair.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxJoinTests.cs",
        "line": 160,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.AttachMessageToJoinAsync_WithValidIds_CreatesAssociation"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxJoinTests.CompleteJoinWorkflow_WithAllStepsCompleted_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When all steps complete and status is set to Completed, then the join shows all completed and no failures.",
      "intent": "Verify end-to-end completion updates counts and status.",
      "scenario": "Create a join with three steps, attach three messages, increment completed for each, then set status to Completed.",
      "behavior": "The final join has Status Completed, CompletedSteps 3, and FailedSteps 0.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxJoinTests.cs",
        "line": 356,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.CompleteJoinWorkflow_WithAllStepsCompleted_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxJoinTests.CompleteJoinWorkflow_WithSomeStepsFailed_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When some steps fail and status is set to Failed, then the join records completed and failed counts.",
      "intent": "Verify mixed completion and failure tracking.",
      "scenario": "Create a join with three steps, complete two, fail one, then set status to Failed.",
      "behavior": "The final join has Status Failed, CompletedSteps 2, and FailedSteps 1.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxJoinTests.cs",
        "line": 404,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.CompleteJoinWorkflow_WithSomeStepsFailed_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxJoinTests.CreateJoinAsync_WithValidParameters_CreatesJoin",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When creating a join with tenant, expected steps, and metadata, then the join is pending with zero counts.",
      "intent": "Verify CreateJoinAsync persists default join state.",
      "scenario": "Create a join with tenantId 12345, expectedSteps 5, and metadata.",
      "behavior": "The join has a non-empty id, pending status, zero completed/failed, metadata, and a recent CreatedUtc.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxJoinTests.cs",
        "line": 83,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.CreateJoinAsync_WithValidParameters_CreatesJoin"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxJoinTests.GetJoinAsync_WithExistingJoin_ReturnsJoin",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a join exists, then GetJoinAsync returns it with the expected steps.",
      "intent": "Ensure joins can be retrieved by id.",
      "scenario": "Create a join with expectedSteps 3 and fetch by JoinId.",
      "behavior": "The returned join is not null and matches JoinId and ExpectedSteps.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxJoinTests.cs",
        "line": 116,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.GetJoinAsync_WithExistingJoin_ReturnsJoin"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxJoinTests.GetJoinAsync_WithNonExistentJoin_ReturnsNull",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a join id is unknown, then GetJoinAsync returns null.",
      "intent": "Confirm missing joins return no result.",
      "scenario": "Generate a new JoinIdentifier without creating a join.",
      "behavior": "The retrieved join is null.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxJoinTests.cs",
        "line": 141,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.GetJoinAsync_WithNonExistentJoin_ReturnsNull"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxJoinTests.GetJoinMessagesAsync_WithMultipleMessages_ReturnsAllMessageIds",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When multiple messages are attached to a join, then GetJoinMessagesAsync returns all message ids.",
      "intent": "Ensure join-member retrieval returns every attached message.",
      "scenario": "Create a join, attach three messages, then query join messages.",
      "behavior": "The result contains three ids including the attached message ids.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxJoinTests.cs",
        "line": 322,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.GetJoinMessagesAsync_WithMultipleMessages_ReturnsAllMessageIds"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_CalledTwiceForSameMessage_IsIdempotent",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IncrementCompletedAsync is called twice for the same message, then the completed count increases only once.",
      "intent": "Ensure completed increments are idempotent per message.",
      "scenario": "Create a join, attach a message, then call IncrementCompletedAsync twice.",
      "behavior": "The join reports CompletedSteps 1 and FailedSteps 0.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxJoinTests.cs",
        "line": 445,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_CalledTwiceForSameMessage_IsIdempotent"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_WhenTotalWouldExceedExpected_DoesNotOverCount",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When completed increments exceed expected steps, then the completed count stops at the expected total.",
      "intent": "Ensure completed steps are capped by expected steps.",
      "scenario": "Create a join expecting two steps, attach three messages, then increment completed for all three.",
      "behavior": "The join reports CompletedSteps 2 and FailedSteps 0.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxJoinTests.cs",
        "line": 501,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_WhenTotalWouldExceedExpected_DoesNotOverCount"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_WithValidMessage_IncrementsCount",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a joined message is marked completed, then CompletedSteps increments and FailedSteps stays zero.",
      "intent": "Verify completed step increments update the join counters.",
      "scenario": "Create a join with expected steps, attach a message, then increment completed.",
      "behavior": "The join reports CompletedSteps 1, FailedSteps 0, and a newer LastUpdatedUtc.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxJoinTests.cs",
        "line": 229,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_WithValidMessage_IncrementsCount"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxJoinTests.IncrementFailedAsync_CalledTwiceForSameMessage_IsIdempotent",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IncrementFailedAsync is called twice for the same message, then the failed count increases only once.",
      "intent": "Ensure failed increments are idempotent per message.",
      "scenario": "Create a join, attach a message, then call IncrementFailedAsync twice.",
      "behavior": "The join reports FailedSteps 1 and CompletedSteps 0.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxJoinTests.cs",
        "line": 473,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.IncrementFailedAsync_CalledTwiceForSameMessage_IsIdempotent"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxJoinTests.IncrementFailedAsync_WithValidMessage_IncrementsCount",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a joined message is marked failed, then FailedSteps increments and CompletedSteps stays zero.",
      "intent": "Verify failed step increments update the join counters.",
      "scenario": "Create a join with expected steps, attach a message, then increment failed.",
      "behavior": "The join reports FailedSteps 1, CompletedSteps 0, and a newer LastUpdatedUtc.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxJoinTests.cs",
        "line": 261,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.IncrementFailedAsync_WithValidMessage_IncrementsCount"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxJoinTests.OutboxAck_AutomaticallyReportsJoinCompletion",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When outbox messages are acknowledged, then join completed counts increment per message.",
      "intent": "Verify outbox ack integration updates join progress.",
      "scenario": "Create a join with two messages, claim and ack each via stored procedures.",
      "behavior": "CompletedSteps increases to 1 after the first ack and to 2 after the second with no failures.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxJoinTests.cs",
        "line": 538,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.OutboxAck_AutomaticallyReportsJoinCompletion"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxJoinTests.OutboxAck_MultipleAcksForSameMessage_IsIdempotent",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the same message is acknowledged twice, then the join completed count does not increment again.",
      "intent": "Ensure duplicate acks do not double-count join completion.",
      "scenario": "Create a join with one message, ack it once, then ack it again with the same owner token.",
      "behavior": "The join still reports CompletedSteps 1 and FailedSteps 0 after the second ack.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxJoinTests.cs",
        "line": 620,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.OutboxAck_MultipleAcksForSameMessage_IsIdempotent"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxJoinTests.OutboxFail_AutomaticallyReportsJoinFailure",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an outbox message is failed, then join failure count increments alongside completed work.",
      "intent": "Verify outbox failure integration updates join failure counts.",
      "scenario": "Create a join with two messages, ack the first, then fail the second via stored procedure.",
      "behavior": "The join reports CompletedSteps 1 and FailedSteps 1.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxJoinTests.cs",
        "line": 582,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.OutboxFail_AutomaticallyReportsJoinFailure"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxJoinTests.UpdateStatusAsync_WithValidStatus_UpdatesJoinStatus",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When updating join status, then the stored join status changes to the new value.",
      "intent": "Verify UpdateStatusAsync persists status changes.",
      "scenario": "Create a join, update status to Completed, then fetch the join.",
      "behavior": "The retrieved join has Status set to Completed.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxJoinTests.cs",
        "line": 293,
        "member": "Incursa.Platform.Tests.OutboxJoinTests.UpdateStatusAsync_WithValidStatus_UpdatesJoinStatus"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxRouterIntegrationTests.DynamicDiscovery_RoutesToCorrectDatabase",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When dynamic discovery loads tenants, then the router resolves distinct outboxes per tenant.",
      "intent": "Validate dynamic discovery works with outbox routing.",
      "scenario": "Given a SampleOutboxDatabaseDiscovery with two tenants and an initial provider refresh.",
      "behavior": "Then GetOutbox returns non-null, distinct outboxes for both tenant identifiers.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxRouterIntegrationTests.cs",
        "line": 91,
        "member": "Incursa.Platform.Tests.OutboxRouterIntegrationTests.DynamicDiscovery_RoutesToCorrectDatabase"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxRouterIntegrationTests.MultiTenantScenario_CreateMessagesInDifferentDatabases",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When tenant keys are routed, then each key resolves to a distinct outbox instance.",
      "intent": "Demonstrate multi-tenant routing for configured outbox stores.",
      "scenario": "Given two SqlOutboxOptions entries and a ConfiguredOutboxStoreProvider with FakeTimeProvider.",
      "behavior": "Then the router returns non-null, distinct outboxes for Tenant1 and Tenant2.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxRouterIntegrationTests.cs",
        "line": 46,
        "member": "Incursa.Platform.Tests.OutboxRouterIntegrationTests.MultiTenantScenario_CreateMessagesInDifferentDatabases"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxRouterIntegrationTests.TypicalApplicationUsage_DemonstratesPattern",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a typical application requests outboxes by tenant, then it receives distinct tenant outboxes.",
      "intent": "Illustrate the routing pattern used by application services.",
      "scenario": "Given an OrderService using an OutboxRouter backed by configured tenant options.",
      "behavior": "Then TenantA and TenantB resolve to different outbox instances.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxRouterIntegrationTests.cs",
        "line": 139,
        "member": "Incursa.Platform.Tests.OutboxRouterIntegrationTests.TypicalApplicationUsage_DemonstratesPattern"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxRouterTests.DynamicProvider_AfterRefresh_NewOutboxIsAvailable",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When discovery is refreshed after adding a tenant, then the new outbox becomes available.",
      "intent": "Ensure provider refresh picks up newly discovered databases.",
      "scenario": "Given a DynamicOutboxStoreProvider that refreshes after adding Tenant2.",
      "behavior": "Then GetOutbox returns a non-null outbox for the new tenant.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxRouterTests.cs",
        "line": 241,
        "member": "Incursa.Platform.Tests.OutboxRouterTests.DynamicProvider_AfterRefresh_NewOutboxIsAvailable"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxRouterTests.DynamicProvider_GetOutboxByKey_ReturnsCorrectOutbox",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When dynamic discovery is used, then routing returns distinct outboxes per discovered tenant.",
      "intent": "Verify DynamicOutboxStoreProvider works with the router after discovery.",
      "scenario": "Given a SampleOutboxDatabaseDiscovery with two tenants and an initial provider refresh.",
      "behavior": "Then GetOutbox returns distinct non-null outboxes for both tenant identifiers.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxRouterTests.cs",
        "line": 190,
        "member": "Incursa.Platform.Tests.OutboxRouterTests.DynamicProvider_GetOutboxByKey_ReturnsCorrectOutbox"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxRouterTests.GetOutbox_GuidKeyConvertsToString_ReturnsOutbox",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a Guid key does not match any configured identifier, then GetOutbox throws with the key in the message.",
      "intent": "Verify Guid-based lookup reports missing identifiers clearly.",
      "scenario": "Given a router configured for \"Customer1\" and a different Guid key.",
      "behavior": "Then GetOutbox(Guid) throws InvalidOperationException containing the Guid string.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxRouterTests.cs",
        "line": 321,
        "member": "Incursa.Platform.Tests.OutboxRouterTests.GetOutbox_GuidKeyConvertsToString_ReturnsOutbox"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxRouterTests.GetOutbox_MultipleCallsForSameKey_ReturnsSameInstance",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When GetOutbox is called multiple times for the same key, then it returns the same instance.",
      "intent": "Confirm outbox instances are cached per key.",
      "scenario": "Given a router configured with a single tenant key.",
      "behavior": "Then repeated GetOutbox calls return the same object instance.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxRouterTests.cs",
        "line": 289,
        "member": "Incursa.Platform.Tests.OutboxRouterTests.GetOutbox_MultipleCallsForSameKey_ReturnsSameInstance"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxRouterTests.GetOutbox_WithEmptyKey_ThrowsArgumentException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an empty key is provided, then GetOutbox throws an ArgumentException.",
      "intent": "Validate input guarding for outbox routing.",
      "scenario": "Given a configured router and an empty string key.",
      "behavior": "Then GetOutbox throws ArgumentException.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxRouterTests.cs",
        "line": 164,
        "member": "Incursa.Platform.Tests.OutboxRouterTests.GetOutbox_WithEmptyKey_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxRouterTests.GetOutbox_WithGuidKey_ReturnsOutbox",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a Guid tenant key is requested, then the router resolves the matching outbox.",
      "intent": "Validate Guid overload routes by converting to string identifier.",
      "scenario": "Given a single SqlOutboxOptions entry keyed by a Guid string.",
      "behavior": "Then GetOutbox(Guid) returns a non-null outbox instance.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxRouterTests.cs",
        "line": 81,
        "member": "Incursa.Platform.Tests.OutboxRouterTests.GetOutbox_WithGuidKey_ReturnsOutbox"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxRouterTests.GetOutbox_WithNonExistentKey_ThrowsInvalidOperationException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an unknown tenant key is requested, then the router throws an InvalidOperationException.",
      "intent": "Ensure the router fails for missing outbox keys.",
      "scenario": "Given a provider with one configured tenant and a non-existent key.",
      "behavior": "Then GetOutbox throws and the message mentions the key.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxRouterTests.cs",
        "line": 111,
        "member": "Incursa.Platform.Tests.OutboxRouterTests.GetOutbox_WithNonExistentKey_ThrowsInvalidOperationException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxRouterTests.GetOutbox_WithNullKey_ThrowsArgumentException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a null key is provided, then GetOutbox throws an ArgumentException.",
      "intent": "Validate input guarding for outbox routing.",
      "scenario": "Given a configured router and a null string key.",
      "behavior": "Then GetOutbox throws ArgumentException.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxRouterTests.cs",
        "line": 138,
        "member": "Incursa.Platform.Tests.OutboxRouterTests.GetOutbox_WithNullKey_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxRouterTests.GetOutbox_WithStringKey_ReturnsOutbox",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When configured tenant keys are requested, then distinct outbox instances are returned.",
      "intent": "Verify routing by string key across multiple configured outbox stores.",
      "scenario": "Given two SqlOutboxOptions entries and a ConfiguredOutboxStoreProvider with a FakeTimeProvider.",
      "behavior": "Then GetOutbox returns non-null, distinct outbox instances for each tenant key.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxRouterTests.cs",
        "line": 43,
        "member": "Incursa.Platform.Tests.OutboxRouterTests.GetOutbox_WithStringKey_ReturnsOutbox"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxWorkQueueTests.ConcurrentClaim_MultipleWorkers_NoOverlap",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When two workers claim concurrently, then the claimed sets do not overlap.",
      "intent": "Validate exclusive claiming across concurrent workers.",
      "scenario": "Given ten ready items and two ClaimAsync calls with different owner tokens.",
      "behavior": "Then the combined results have no overlapping ids.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxWorkQueueTests.cs",
        "line": 175,
        "member": "Incursa.Platform.Tests.OutboxWorkQueueTests.ConcurrentClaim_MultipleWorkers_NoOverlap"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxWorkQueueTests.InvalidOwnerOperations_DoNotAffectItems",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a non-owner tries to acknowledge items, then the items remain InProgress.",
      "intent": "Ensure owner token enforcement prevents unauthorized updates.",
      "scenario": "Given claimed items and AckAsync called with a different owner token.",
      "behavior": "Then the items remain in Status = InProgress.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxWorkQueueTests.cs",
        "line": 203,
        "member": "Incursa.Platform.Tests.OutboxWorkQueueTests.InvalidOwnerOperations_DoNotAffectItems"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxAbandon_WithValidOwner_ReturnsToReady",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AbandonAsync is called by the owner, then outbox items return to Ready status.",
      "intent": "Ensure abandoned items are made available for reprocessing.",
      "scenario": "Given claimed outbox items and the owning token.",
      "behavior": "Then the items have Status = Ready.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxWorkQueueTests.cs",
        "line": 115,
        "member": "Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxAbandon_WithValidOwner_ReturnsToReady"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxAck_WithValidOwner_MarksDoneAndProcessed",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AckAsync is called by the owner, then outbox items are marked Done and processed.",
      "intent": "Verify successful acknowledgements update outbox status and processed flag.",
      "scenario": "Given claimed outbox items and the owning token.",
      "behavior": "Then the items have Status = Done and IsProcessed = true.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxWorkQueueTests.cs",
        "line": 95,
        "member": "Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxAck_WithValidOwner_MarksDoneAndProcessed"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxClaim_WithBatchSize_RespectsLimit",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When ClaimAsync is called with a batch size, then it limits the number of claimed ids.",
      "intent": "Ensure batch size is respected in outbox claims.",
      "scenario": "Given five ready outbox rows and a batch size of two.",
      "behavior": "Then ClaimAsync returns exactly two ids.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxWorkQueueTests.cs",
        "line": 77,
        "member": "Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxClaim_WithBatchSize_RespectsLimit"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxClaim_WithReadyItems_ReturnsClaimedIds",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When ready outbox items exist, then ClaimAsync returns their ids.",
      "intent": "Verify work-queue claims return the ready items.",
      "scenario": "Given three outbox rows in Ready status and a generated owner token.",
      "behavior": "Then ClaimAsync returns three ids from the inserted set.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxWorkQueueTests.cs",
        "line": 57,
        "member": "Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxClaim_WithReadyItems_ReturnsClaimedIds"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxFail_WithValidOwner_MarksAsFailed",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When FailAsync is called by the owner, then outbox items are marked Failed.",
      "intent": "Verify failure paths update status correctly.",
      "scenario": "Given claimed outbox items and the owning token.",
      "behavior": "Then the items have Status = Failed.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxWorkQueueTests.cs",
        "line": 134,
        "member": "Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxFail_WithValidOwner_MarksAsFailed"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxReapExpired_WithExpiredItems_ReturnsToReady",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When leases expire, then ReapExpiredAsync returns items to Ready status.",
      "intent": "Ensure expired claims are reaped and made available again.",
      "scenario": "Given a claimed item with a 1-second lease and a delay past expiry.",
      "behavior": "Then the item status is reset to Ready after reaping.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxWorkQueueTests.cs",
        "line": 153,
        "member": "Incursa.Platform.Tests.OutboxWorkQueueTests.OutboxReapExpired_WithExpiredItems_ReturnsToReady"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxWorkerTests.Manual_AbandonOperation_Works",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AbandonAsync is called manually, then claimed items return to Ready.",
      "intent": "Ensure manual abandon resets outbox item state.",
      "scenario": "Given claimed outbox items and the owning token.",
      "behavior": "Then the items have Status = Ready.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxWorkerTests.cs",
        "line": 183,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.Manual_AbandonOperation_Works"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_ConcurrentClaims_NoOverlap",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When multiple workers claim concurrently, then no outbox item is claimed more than once.",
      "intent": "Validate concurrency safety of the claim operation.",
      "scenario": "Given ten ready items and five concurrent ClaimAsync calls.",
      "behavior": "Then all claimed ids are unique and do not exceed available items.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxWorkerTests.cs",
        "line": 320,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_ConcurrentClaims_NoOverlap"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_EmptyIdLists_NoErrors",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AckAsync, AbandonAsync, or FailAsync are called with empty id lists, then they complete without error.",
      "intent": "Verify empty batch operations are safe no-ops.",
      "scenario": "Given an empty list of OutboxWorkItemIdentifier values.",
      "behavior": "Then the operations complete without throwing.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxWorkerTests.cs",
        "line": 303,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_EmptyIdLists_NoErrors"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_IdempotentOperations_NoErrors",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AckAsync is called multiple times for the same items, then no errors occur and status remains Done.",
      "intent": "Verify acknowledgements are idempotent.",
      "scenario": "Given claimed items and multiple AckAsync calls with the same owner token.",
      "behavior": "Then the items remain in Status = Done.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxWorkerTests.cs",
        "line": 262,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_IdempotentOperations_NoErrors"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_LeaseExpiration_AllowsReclaim",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a claim lease expires and is reaped, then another owner can reclaim the item.",
      "intent": "Verify lease expiration allows subsequent claims.",
      "scenario": "Given a 1-second lease, a reap after expiry, and a second owner token.",
      "behavior": "Then the second owner claims the same item successfully.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxWorkerTests.cs",
        "line": 204,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_LeaseExpiration_AllowsReclaim"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_RestartUsesNewOwnerTokenAfterReap",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a lease is reaped and re-claimed, then the new owner token is persisted.",
      "intent": "Ensure owner token updates after lease expiration and re-claim.",
      "scenario": "Given a claim by owner1, a reap after expiry, and a new claim by owner2.",
      "behavior": "Then the database OwnerToken reflects owner2 for the reclaimed item.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxWorkerTests.cs",
        "line": 234,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_RestartUsesNewOwnerTokenAfterReap"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_UnauthorizedOwner_CannotModify",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a non-owner tries to acknowledge items, then the items remain InProgress.",
      "intent": "Ensure owner token enforcement prevents unauthorized modifications.",
      "scenario": "Given claimed items owned by owner1 and AckAsync called by owner2.",
      "behavior": "Then the items stay InProgress under owner1.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxWorkerTests.cs",
        "line": 283,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.WorkQueue_UnauthorizedOwner_CannotModify"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxWorkerTests.Worker_ClaimsItemsCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When items are claimed directly, then they enter InProgress and the claims match existing ids.",
      "intent": "Validate ClaimAsync returns known items and updates status.",
      "scenario": "Given two ready outbox items and a generated owner token.",
      "behavior": "Then the returned ids match the inserted items and have Status = InProgress.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxWorkerTests.cs",
        "line": 162,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.Worker_ClaimsItemsCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxWorkerTests.Worker_ProcessesClaimedItems_AndAcknowledgesThem",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the worker processes claimed items, then it acknowledges them and they become Done.",
      "intent": "Validate the outbox worker completes and acknowledges messages.",
      "scenario": "Given three ready outbox items and a running TestOutboxWorker.",
      "behavior": "Then all items are processed and marked Done in the database.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxWorkerTests.cs",
        "line": 110,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.Worker_ProcessesClaimedItems_AndAcknowledgesThem"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxWorkerTests.Worker_RespectsCancellationToken",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When cancellation is requested, then the worker stops promptly.",
      "intent": "Ensure the outbox worker cooperates with cancellation tokens.",
      "scenario": "Given a TestOutboxWorker with a long processing delay and a short cancellation timeout.",
      "behavior": "Then the worker stops in under five seconds.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxWorkerTests.cs",
        "line": 348,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.Worker_RespectsCancellationToken"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.OutboxWorkerTests.Worker_WithProcessingFailure_AbandonsItems",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the worker fails to process items, then it abandons them back to Ready.",
      "intent": "Ensure failures result in abandon operations rather than acknowledgements.",
      "scenario": "Given a TestOutboxWorker configured to fail processing and a short processing delay.",
      "behavior": "Then the claimed items return to Ready status.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/OutboxWorkerTests.cs",
        "line": 136,
        "member": "Incursa.Platform.Tests.OutboxWorkerTests.Worker_WithProcessingFailure_AbandonsItems"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformFanout_RegistersPlatformProvider",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddPlatformFanout is registered, then the fanout repository provider resolves as the platform implementation.",
      "intent": "Confirm platform fanout registration binds the provider to the platform adapter.",
      "scenario": "Given a service collection configured with a stub discovery and platform configuration.",
      "behavior": "Then resolving IFanoutRepositoryProvider yields PlatformFanoutRepositoryProvider.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformFeatureAdapterTests.cs",
        "line": 78,
        "member": "Incursa.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformFanout_RegistersPlatformProvider"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformInbox_RegistersPlatformProvider",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddPlatformInbox is registered, then the inbox work store provider resolves as the platform implementation.",
      "intent": "Confirm platform inbox registration binds the provider to the platform adapter.",
      "scenario": "Given a service collection configured with a stub discovery and platform configuration.",
      "behavior": "Then resolving IInboxWorkStoreProvider yields PlatformInboxWorkStoreProvider.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformFeatureAdapterTests.cs",
        "line": 44,
        "member": "Incursa.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformInbox_RegistersPlatformProvider"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformLeases_RegistersPlatformProvider",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddPlatformLeases is registered, then the lease factory provider resolves as the platform implementation.",
      "intent": "Confirm platform lease registration binds the provider to the platform adapter.",
      "scenario": "Given a service collection configured with a stub discovery and platform configuration.",
      "behavior": "Then resolving ILeaseFactoryProvider yields PlatformLeaseFactoryProvider.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformFeatureAdapterTests.cs",
        "line": 95,
        "member": "Incursa.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformLeases_RegistersPlatformProvider"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformOutbox_RegistersPlatformProvider",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddPlatformOutbox is registered, then the outbox store provider resolves as the platform implementation.",
      "intent": "Confirm platform outbox registration binds the provider to the platform adapter.",
      "scenario": "Given a service collection configured with a stub discovery and platform configuration.",
      "behavior": "Then resolving IOutboxStoreProvider yields PlatformOutboxStoreProvider.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformFeatureAdapterTests.cs",
        "line": 27,
        "member": "Incursa.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformOutbox_RegistersPlatformProvider"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformScheduler_RegistersPlatformProvider",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddPlatformScheduler is registered, then the scheduler store provider resolves as the platform implementation.",
      "intent": "Confirm platform scheduler registration binds the provider to the platform adapter.",
      "scenario": "Given a service collection configured with a stub discovery and platform configuration.",
      "behavior": "Then resolving ISchedulerStoreProvider yields PlatformSchedulerStoreProvider.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformFeatureAdapterTests.cs",
        "line": 61,
        "member": "Incursa.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformScheduler_RegistersPlatformProvider"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithDynamicDiscoveryAndControlPlane_AndNoDatabases_DoesNotThrowException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When dynamic discovery uses a control plane and no app databases exist yet, then StartAsync fails for control plane validation rather than missing databases.",
      "intent": "Ensure control plane validation is reported distinctly from discovery emptiness.",
      "scenario": "Given UsesDiscovery true, a control plane connection string, and an EmptyDatabaseDiscovery.",
      "behavior": "Then StartAsync throws an InvalidOperationException mentioning the control plane and not the missing database requirement.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformLifecycleServiceTests.cs",
        "line": 104,
        "member": "Incursa.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithDynamicDiscoveryAndControlPlane_AndNoDatabases_DoesNotThrowException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithDynamicDiscovery_AndNoDatabases_DoesNotThrowException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When dynamic discovery is enabled and startup does not require databases, then StartAsync completes without throwing.",
      "intent": "Allow zero databases at startup for dynamic discovery.",
      "scenario": "Given a configuration with UsesDiscovery true, RequiresDatabaseAtStartup false, and an EmptyDatabaseDiscovery.",
      "behavior": "Then StartAsync returns without exceptions.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformLifecycleServiceTests.cs",
        "line": 37,
        "member": "Incursa.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithDynamicDiscovery_AndNoDatabases_DoesNotThrowException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithDynamicDiscovery_AndOneDatabase_Succeeds",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When dynamic discovery returns at least one database, then StartAsync completes without throwing.",
      "intent": "Allow startup with dynamic discovery when a database is discoverable.",
      "scenario": "Given UsesDiscovery true and a TestDatabaseDiscovery that returns one database.",
      "behavior": "Then StartAsync completes successfully.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformLifecycleServiceTests.cs",
        "line": 143,
        "member": "Incursa.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithDynamicDiscovery_AndOneDatabase_Succeeds"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithListBasedDiscovery_AndNoDatabases_ThrowsException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When list-based discovery requires databases but none are found, then StartAsync throws with a missing database message.",
      "intent": "Enforce startup database requirements for list-based discovery.",
      "scenario": "Given UsesDiscovery false, RequiresDatabaseAtStartup true, and an EmptyDatabaseDiscovery.",
      "behavior": "Then StartAsync throws an InvalidOperationException containing \"At least one database is required\".",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformLifecycleServiceTests.cs",
        "line": 69,
        "member": "Incursa.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithListBasedDiscovery_AndNoDatabases_ThrowsException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithListBasedDiscovery_AndOneDatabase_Succeeds",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When list-based discovery provides at least one database, then StartAsync completes without throwing.",
      "intent": "Allow startup with list-based discovery when a database is configured.",
      "scenario": "Given UsesDiscovery false and a TestDatabaseDiscovery that returns one database.",
      "behavior": "Then StartAsync completes successfully.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformLifecycleServiceTests.cs",
        "line": 183,
        "member": "Incursa.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithListBasedDiscovery_AndOneDatabase_Succeeds"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformRegistrationTests.AddSqlPlatformMultiDatabaseWithControlPlaneAndDiscovery_ThrowsWhenDirectInboxStoreRegistered",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When control-plane discovery registration finds a direct IInboxWorkStore registration, then it throws an InvalidOperationException.",
      "intent": "Prevent mixing direct inbox store registrations with platform discovery mode.",
      "scenario": "Given a service collection with a discovery implementation and a dummy IInboxWorkStore registered.",
      "behavior": "Then AddSqlPlatformMultiDatabaseWithControlPlaneAndDiscovery throws with a message about direct stores.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformRegistrationTests.cs",
        "line": 248,
        "member": "Incursa.Platform.Tests.PlatformRegistrationTests.AddSqlPlatformMultiDatabaseWithControlPlaneAndDiscovery_ThrowsWhenDirectInboxStoreRegistered"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformRegistrationTests.AddSqlPlatformMultiDatabaseWithControlPlaneAndDiscovery_ThrowsWhenDirectOutboxRegistered",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When control-plane discovery registration finds a direct IOutbox registration, then it throws an InvalidOperationException.",
      "intent": "Ensure direct outbox services are not registered alongside platform discovery.",
      "scenario": "Given a service collection with a discovery implementation and a dummy IOutbox registered.",
      "behavior": "Then AddSqlPlatformMultiDatabaseWithControlPlaneAndDiscovery throws with a message about direct outboxes.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformRegistrationTests.cs",
        "line": 272,
        "member": "Incursa.Platform.Tests.PlatformRegistrationTests.AddSqlPlatformMultiDatabaseWithControlPlaneAndDiscovery_ThrowsWhenDirectOutboxRegistered"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformRegistrationTests.AddSqlPlatformMultiDatabaseWithControlPlaneAndDiscovery_ThrowsWhenDirectOutboxStoreRegistered",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When control-plane discovery registration finds a direct IOutboxStore registration, then it throws an InvalidOperationException.",
      "intent": "Prevent mixing direct outbox store registrations with platform discovery mode.",
      "scenario": "Given a service collection with a discovery implementation and a dummy IOutboxStore registered.",
      "behavior": "Then AddSqlPlatformMultiDatabaseWithControlPlaneAndDiscovery throws with a message about direct stores.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformRegistrationTests.cs",
        "line": 224,
        "member": "Incursa.Platform.Tests.PlatformRegistrationTests.AddSqlPlatformMultiDatabaseWithControlPlaneAndDiscovery_ThrowsWhenDirectOutboxStoreRegistered"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformRegistrationTests.AddSqlPlatformMultiDatabaseWithDiscovery_RegistersRequiredServices",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlPlatformMultiDatabaseWithDiscovery is used, then configuration is set for discovery-based multi-database mode.",
      "intent": "Verify discovery-based registration flips the UsesDiscovery flag.",
      "scenario": "Given a service collection with a test IPlatformDatabaseDiscovery implementation.",
      "behavior": "Then PlatformConfiguration indicates multi-database without control and UsesDiscovery is true.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformRegistrationTests.cs",
        "line": 154,
        "member": "Incursa.Platform.Tests.PlatformRegistrationTests.AddSqlPlatformMultiDatabaseWithDiscovery_RegistersRequiredServices"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformRegistrationTests.AddSqlPlatformMultiDatabaseWithList_CalledTwice_ThrowsException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlPlatformMultiDatabaseWithList is called twice, then it throws an InvalidOperationException.",
      "intent": "Prevent duplicate multi-database list registration.",
      "scenario": "Given a service collection that already called AddSqlPlatformMultiDatabaseWithList once.",
      "behavior": "Then the second call throws and the message mentions it was already called.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformRegistrationTests.cs",
        "line": 64,
        "member": "Incursa.Platform.Tests.PlatformRegistrationTests.AddSqlPlatformMultiDatabaseWithList_CalledTwice_ThrowsException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformRegistrationTests.AddSqlPlatformMultiDatabaseWithList_DuplicateNames_ThrowsException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlPlatformMultiDatabaseWithList receives duplicate database names, then it throws an ArgumentException.",
      "intent": "Ensure database identifiers are unique in list-based registration.",
      "scenario": "Given two PlatformDatabase entries with the same Name value.",
      "behavior": "Then AddSqlPlatformMultiDatabaseWithList throws during discovery setup.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformRegistrationTests.cs",
        "line": 134,
        "member": "Incursa.Platform.Tests.PlatformRegistrationTests.AddSqlPlatformMultiDatabaseWithList_DuplicateNames_ThrowsException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformRegistrationTests.AddSqlPlatformMultiDatabaseWithList_EmptyList_ThrowsException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlPlatformMultiDatabaseWithList receives an empty list, then it throws an ArgumentException.",
      "intent": "Guard against registering multi-database services without any databases.",
      "scenario": "Given an empty PlatformDatabase array passed to AddSqlPlatformMultiDatabaseWithList.",
      "behavior": "Then an ArgumentException is thrown with a message indicating the list must not be empty.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformRegistrationTests.cs",
        "line": 116,
        "member": "Incursa.Platform.Tests.PlatformRegistrationTests.AddSqlPlatformMultiDatabaseWithList_EmptyList_ThrowsException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformRegistrationTests.AddSqlPlatformMultiDatabaseWithList_RegistersRequiredServices",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When multiple databases are registered via AddSqlPlatformMultiDatabaseWithList, then platform configuration and discovery are registered.",
      "intent": "Ensure list-based registration sets multi-database configuration without discovery mode.",
      "scenario": "Given two PlatformDatabase entries passed to AddSqlPlatformMultiDatabaseWithList.",
      "behavior": "Then PlatformConfiguration is set for multi-database without control and discovery resolves.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformRegistrationTests.cs",
        "line": 88,
        "member": "Incursa.Platform.Tests.PlatformRegistrationTests.AddSqlPlatformMultiDatabaseWithList_RegistersRequiredServices"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformRegistrationTests.AddSqlPlatformMultiDatabaseWithList_SingleDatabase_RegistersRequiredServices",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a single database is registered via AddSqlPlatformMultiDatabaseWithList, then core configuration and time abstractions are registered.",
      "intent": "Verify the multi-database list registration sets configuration, discovery, and timing services.",
      "scenario": "Given a service collection configured with one PlatformDatabase entry.",
      "behavior": "Then PlatformConfiguration, IPlatformDatabaseDiscovery, TimeProvider, and IMonotonicClock resolve with expected flags.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformRegistrationTests.cs",
        "line": 29,
        "member": "Incursa.Platform.Tests.PlatformRegistrationTests.AddSqlPlatformMultiDatabaseWithList_SingleDatabase_RegistersRequiredServices"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.PlatformRegistrationTests.ListBasedDatabaseDiscovery_ReturnsConfiguredDatabasesAsync",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When ListBasedDatabaseDiscovery is queried, then it returns the configured databases as-is.",
      "intent": "Confirm list-based discovery surfaces the configured database metadata.",
      "scenario": "Given a ListBasedDatabaseDiscovery initialized with two database entries.",
      "behavior": "Then DiscoverDatabasesAsync returns both entries with matching names and connection strings.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/PlatformRegistrationTests.cs",
        "line": 177,
        "member": "Incursa.Platform.Tests.PlatformRegistrationTests.ListBasedDatabaseDiscovery_ReturnsConfiguredDatabasesAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SchedulerRouterTests.SchedulerRouter_WithGuidKey_ReturnsSchedulerClient",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a Guid key is requested, then the router returns a scheduler client for the matching identifier string.",
      "intent": "Verify Guid overload routes by string conversion.",
      "scenario": "Given a scheduler config with an Identifier set to a Guid string.",
      "behavior": "Then GetSchedulerClient returns a SqlSchedulerClient for that Guid.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SchedulerRouterTests.cs",
        "line": 133,
        "member": "Incursa.Platform.Tests.SchedulerRouterTests.SchedulerRouter_WithGuidKey_ReturnsSchedulerClient"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SchedulerRouterTests.SchedulerRouter_WithInvalidKey_ThrowsException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an unknown scheduler key is requested, then the router throws an InvalidOperationException.",
      "intent": "Ensure invalid identifiers fail fast when no scheduler is configured.",
      "scenario": "Given a ConfiguredSchedulerStoreProvider with one configured database.",
      "behavior": "Then GetSchedulerClient throws for an unknown key.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SchedulerRouterTests.cs",
        "line": 77,
        "member": "Incursa.Platform.Tests.SchedulerRouterTests.SchedulerRouter_WithInvalidKey_ThrowsException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SchedulerRouterTests.SchedulerRouter_WithNullKey_ThrowsException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an empty scheduler key is requested, then the router throws an ArgumentException.",
      "intent": "Validate key input guarding for scheduler routing.",
      "scenario": "Given a router configured with one scheduler store.",
      "behavior": "Then GetSchedulerClient throws for an empty string key.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SchedulerRouterTests.cs",
        "line": 105,
        "member": "Incursa.Platform.Tests.SchedulerRouterTests.SchedulerRouter_WithNullKey_ThrowsException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SchedulerRouterTests.SchedulerRouter_WithValidKey_ReturnsSchedulerClient",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a known scheduler key is requested, then the router returns a scheduler client.",
      "intent": "Verify routing to a configured scheduler store by string key.",
      "scenario": "Given a ConfiguredSchedulerStoreProvider with two database configs and a test logger.",
      "behavior": "Then GetSchedulerClient returns a SqlSchedulerClient for the matching identifier.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SchedulerRouterTests.cs",
        "line": 40,
        "member": "Incursa.Platform.Tests.SchedulerRouterTests.SchedulerRouter_WithValidKey_ReturnsSchedulerClient"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SchemaVersionSnapshotTests.SchemaVersions_MatchSnapshot",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the schema snapshot is captured, then it matches the stored snapshot file.",
      "intent": "Verify schema version snapshots remain consistent across runs.",
      "scenario": "Given a captured schema snapshot and the existing snapshot file (or a refreshed snapshot).",
      "behavior": "Then the captured snapshot equals the stored snapshot content.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SchemaVersionSnapshotTests.cs",
        "line": 27,
        "member": "Incursa.Platform.Tests.SchemaVersionSnapshotTests.SchemaVersions_MatchSnapshot"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlAuditAdapterTests.WriteAndQueryByAnchorRoundTrip",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When write And Query By Anchor Round Trip, then it behaves as expected.",
      "intent": "Document expected behavior for write And Query By Anchor Round Trip.",
      "scenario": "Given write And Query By Anchor Round Trip.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlAuditAdapterTests.cs",
        "line": 43,
        "member": "Incursa.Platform.Tests.SqlAuditAdapterTests.WriteAndQueryByAnchorRoundTrip"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlEmailOutboxStoreTests.Dequeue_ReturnsPendingItemsInOrder",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When dequeue Returns Pending Items In Order, then it behaves as expected.",
      "intent": "Document expected behavior for dequeue Returns Pending Items In Order.",
      "scenario": "Given dequeue Returns Pending Items In Order.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlEmailOutboxStoreTests.cs",
        "line": 85,
        "member": "Incursa.Platform.Tests.SqlEmailOutboxStoreTests.Dequeue_ReturnsPendingItemsInOrder"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlEmailOutboxStoreTests.Enqueue_IsIdempotentForProviderAndMessageKey",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When enqueue Is Idempotent For Provider And Message Key, then it behaves as expected.",
      "intent": "Document expected behavior for enqueue Is Idempotent For Provider And Message Key.",
      "scenario": "Given enqueue Is Idempotent For Provider And Message Key.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlEmailOutboxStoreTests.cs",
        "line": 121,
        "member": "Incursa.Platform.Tests.SqlEmailOutboxStoreTests.Enqueue_IsIdempotentForProviderAndMessageKey"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlEmailOutboxStoreTests.Enqueue_MarksMessageKey",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When enqueue Marks Message Key, then it behaves as expected.",
      "intent": "Document expected behavior for enqueue Marks Message Key.",
      "scenario": "Given enqueue Marks Message Key.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlEmailOutboxStoreTests.cs",
        "line": 59,
        "member": "Incursa.Platform.Tests.SqlEmailOutboxStoreTests.Enqueue_MarksMessageKey"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithHash_StoresHashCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AlreadyProcessedAsync is called with a hash, then the hash is persisted in the inbox row.",
      "intent": "Verify the optional hash is stored for deduplication checks.",
      "scenario": "Given a message id, source, and a 32-byte hash.",
      "behavior": "Then the stored Hash column matches the provided bytes.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlInboxServiceTests.cs",
        "line": 219,
        "member": "Incursa.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithHash_StoresHashCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithInvalidMessageId_ThrowsArgumentException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an invalid message id is provided, then AlreadyProcessedAsync throws an ArgumentException.",
      "intent": "Ensure inbox checks validate message id inputs.",
      "scenario": "Given null or empty message id values.",
      "behavior": "Then AlreadyProcessedAsync throws ArgumentException.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlInboxServiceTests.cs",
        "line": 248,
        "member": "Incursa.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithInvalidMessageId_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithInvalidSource_ThrowsArgumentException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an invalid source is provided, then AlreadyProcessedAsync throws an ArgumentException.",
      "intent": "Ensure inbox checks validate source inputs.",
      "scenario": "Given null or empty source values.",
      "behavior": "Then AlreadyProcessedAsync throws ArgumentException.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlInboxServiceTests.cs",
        "line": 265,
        "member": "Incursa.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithInvalidSource_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithNewMessage_ReturnsFalseAndRecordsMessage",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a new message id is checked, then AlreadyProcessedAsync returns false and records it.",
      "intent": "Verify first-time inbox checks persist the message record.",
      "scenario": "Given a SqlInboxService and a new message id/source pair.",
      "behavior": "Then AlreadyProcessedAsync returns false and a row exists in infra.Inbox.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlInboxServiceTests.cs",
        "line": 37,
        "member": "Incursa.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithNewMessage_ReturnsFalseAndRecordsMessage"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithProcessedMessage_ReturnsTrue",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a message has been marked processed, then AlreadyProcessedAsync returns true.",
      "intent": "Confirm processed messages are reported as already processed.",
      "scenario": "Given a message recorded and marked processed via MarkProcessedAsync.",
      "behavior": "Then a subsequent AlreadyProcessedAsync returns true.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlInboxServiceTests.cs",
        "line": 66,
        "member": "Incursa.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithProcessedMessage_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlInboxServiceTests.ConcurrentAlreadyProcessedAsync_WithSameMessage_HandledCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AlreadyProcessedAsync is called concurrently for the same message, then one row is created and attempts increment.",
      "intent": "Ensure concurrent checks remain idempotent and track attempts.",
      "scenario": "Given five concurrent AlreadyProcessedAsync calls for the same message id.",
      "behavior": "Then all calls return false, only one row exists, and Attempts equals five.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlInboxServiceTests.cs",
        "line": 177,
        "member": "Incursa.Platform.Tests.SqlInboxServiceTests.ConcurrentAlreadyProcessedAsync_WithSameMessage_HandledCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlInboxServiceTests.MarkDeadAsync_UpdatesStatus",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When MarkDeadAsync is called, then the message status becomes Dead.",
      "intent": "Confirm dead-lettering updates the status field.",
      "scenario": "Given a recorded inbox message.",
      "behavior": "Then the database row status is Dead.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlInboxServiceTests.cs",
        "line": 148,
        "member": "Incursa.Platform.Tests.SqlInboxServiceTests.MarkDeadAsync_UpdatesStatus"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlInboxServiceTests.MarkProcessedAsync_SetsProcessedUtcAndStatus",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When MarkProcessedAsync is called, then ProcessedUtc is set and status becomes Done.",
      "intent": "Verify processed state updates both timestamp and status.",
      "scenario": "Given a recorded inbox message.",
      "behavior": "Then the database row has non-null ProcessedUtc and Status = Done.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlInboxServiceTests.cs",
        "line": 89,
        "member": "Incursa.Platform.Tests.SqlInboxServiceTests.MarkProcessedAsync_SetsProcessedUtcAndStatus"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlInboxServiceTests.MarkProcessingAsync_UpdatesStatus",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When MarkProcessingAsync is called, then the message status becomes Processing.",
      "intent": "Confirm processing state transitions update the status field.",
      "scenario": "Given a recorded inbox message.",
      "behavior": "Then the database row status is Processing.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlInboxServiceTests.cs",
        "line": 119,
        "member": "Incursa.Platform.Tests.SqlInboxServiceTests.MarkProcessingAsync_UpdatesStatus"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlOperationAdapterTests.StartUpdateCompleteRoundTrip",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When start Update Complete Round Trip, then it behaves as expected.",
      "intent": "Document expected behavior for start Update Complete Round Trip.",
      "scenario": "Given start Update Complete Round Trip.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlOperationAdapterTests.cs",
        "line": 44,
        "member": "Incursa.Platform.Tests.SqlOperationAdapterTests.StartUpdateCompleteRoundTrip"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlOperationAdapterTests.WatcherFindsAndMarksStalled",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When watcher Finds And Marks Stalled, then it behaves as expected.",
      "intent": "Document expected behavior for watcher Finds And Marks Stalled.",
      "scenario": "Given watcher Finds And Marks Stalled.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlOperationAdapterTests.cs",
        "line": 98,
        "member": "Incursa.Platform.Tests.SqlOperationAdapterTests.WatcherFindsAndMarksStalled"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlOutboxServiceTests.Constructor_CreatesInstance",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When constructing the outbox service, then it provides an IOutbox implementation.",
      "intent": "Verify SqlOutboxService instantiation succeeds.",
      "scenario": "Create a SqlOutboxService with default options and a null logger.",
      "behavior": "The service is not null and is assignable to IOutbox.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlOutboxServiceTests.cs",
        "line": 49,
        "member": "Incursa.Platform.Tests.SqlOutboxServiceTests.Constructor_CreatesInstance"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_MultipleMessages_AllInsertedSuccessfully",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When enqueueing multiple messages in one transaction, then all rows are inserted.",
      "intent": "Verify batch inserts within a transaction.",
      "scenario": "Enqueue three messages using the same transaction.",
      "behavior": "The outbox table contains three rows.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlOutboxServiceTests.cs",
        "line": 228,
        "member": "Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_MultipleMessages_AllInsertedSuccessfully"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_Standalone_EnsuresTableExists",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When standalone enqueue targets a missing table, then the table is created and the message is inserted.",
      "intent": "Ensure standalone enqueue creates the outbox table if needed.",
      "scenario": "Drop the custom table, then enqueue using a service pointing at that table.",
      "behavior": "The custom table exists and contains one matching row.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlOutboxServiceTests.cs",
        "line": 391,
        "member": "Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_Standalone_EnsuresTableExists"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_Standalone_MultipleMessages_AllInsertedSuccessfully",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When enqueueing multiple standalone messages, then all rows are inserted.",
      "intent": "Verify standalone enqueue handles multiple writes.",
      "scenario": "Enqueue three messages with unique topic/payload suffixes.",
      "behavior": "The outbox table contains three matching rows.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlOutboxServiceTests.cs",
        "line": 349,
        "member": "Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_Standalone_MultipleMessages_AllInsertedSuccessfully"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_Standalone_WithNullCorrelationId_InsertsMessageSuccessfully",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When standalone enqueue uses a null correlation id, then the message is inserted.",
      "intent": "Allow null correlation ids in standalone enqueue.",
      "scenario": "Call EnqueueAsync with topic, payload, and a null correlation id.",
      "behavior": "The outbox table contains one matching row.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlOutboxServiceTests.cs",
        "line": 314,
        "member": "Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_Standalone_WithNullCorrelationId_InsertsMessageSuccessfully"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_Standalone_WithValidParameters_InsertsMessageToDatabase",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When enqueueing without an explicit transaction, then the message is inserted.",
      "intent": "Verify standalone enqueue creates an outbox record.",
      "scenario": "Call EnqueueAsync with topic, payload, and correlation id.",
      "behavior": "The outbox table contains one matching row.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlOutboxServiceTests.cs",
        "line": 277,
        "member": "Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_Standalone_WithValidParameters_InsertsMessageToDatabase"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithCustomSchemaAndTable_InsertsMessageToCorrectTable",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When using custom schema and table options, then the message is inserted into that table.",
      "intent": "Ensure custom outbox table routing is honored.",
      "scenario": "Create a custom schema/table and enqueue a message using a custom outbox service.",
      "behavior": "The custom table contains one matching row.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlOutboxServiceTests.cs",
        "line": 98,
        "member": "Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithCustomSchemaAndTable_InsertsMessageToCorrectTable"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithNullCorrelationId_InsertsMessageSuccessfully",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When enqueueing with a null correlation id, then the message is still inserted.",
      "intent": "Allow null correlation ids during transactional enqueue.",
      "scenario": "Enqueue a message with topic and payload and a null correlation id.",
      "behavior": "The outbox table contains one matching row.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlOutboxServiceTests.cs",
        "line": 150,
        "member": "Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithNullCorrelationId_InsertsMessageSuccessfully"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithNullTransaction_ThrowsNullReferenceException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the transaction is null, then EnqueueAsync throws ArgumentNullException.",
      "intent": "Enforce a non-null transaction for transactional enqueue.",
      "scenario": "Call EnqueueAsync with a null IDbTransaction.",
      "behavior": "An ArgumentNullException is thrown.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlOutboxServiceTests.cs",
        "line": 257,
        "member": "Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithNullTransaction_ThrowsNullReferenceException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithValidParameters_InsertsMessageToDatabase",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When enqueueing with a transaction, then a matching outbox row is inserted.",
      "intent": "Validate enqueue persists messages within a transaction.",
      "scenario": "Open a SQL transaction, enqueue a message with topic, payload, and correlation id.",
      "behavior": "The outbox table contains exactly one matching row.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlOutboxServiceTests.cs",
        "line": 64,
        "member": "Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithValidParameters_InsertsMessageToDatabase"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithValidParameters_SetsDefaultValues",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When enqueueing a message, then default outbox columns are initialized.",
      "intent": "Verify insert defaults for processing metadata.",
      "scenario": "Enqueue a message in a transaction and read the inserted row.",
      "behavior": "IsProcessed is false, ProcessedAt is null, RetryCount is 0, CreatedAt is recent, and MessageId is set.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlOutboxServiceTests.cs",
        "line": 183,
        "member": "Incursa.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithValidParameters_SetsDefaultValues"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlOutboxStoreWhiteBoxTests.FailAsync_SetsFailureMetadata",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When fail Async Sets Failure Metadata, then it behaves as expected.",
      "intent": "Document expected behavior for fail Async Sets Failure Metadata.",
      "scenario": "Given fail Async Sets Failure Metadata.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlOutboxStoreWhiteBoxTests.cs",
        "line": 79,
        "member": "Incursa.Platform.Tests.SqlOutboxStoreWhiteBoxTests.FailAsync_SetsFailureMetadata"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlOutboxStoreWhiteBoxTests.MarkDispatchedAsync_SetsProcessedFlags",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When mark Dispatched Async Sets Processed Flags, then it behaves as expected.",
      "intent": "Document expected behavior for mark Dispatched Async Sets Processed Flags.",
      "scenario": "Given mark Dispatched Async Sets Processed Flags.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlOutboxStoreWhiteBoxTests.cs",
        "line": 52,
        "member": "Incursa.Platform.Tests.SqlOutboxStoreWhiteBoxTests.MarkDispatchedAsync_SetsProcessedFlags"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlOutboxStoreWhiteBoxTests.RescheduleAsync_IncrementsRetryCountAndSetsError",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When reschedule Async Increments Retry Count And Sets Error, then it behaves as expected.",
      "intent": "Document expected behavior for reschedule Async Increments Retry Count And Sets Error.",
      "scenario": "Given reschedule Async Increments Retry Count And Sets Error.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlOutboxStoreWhiteBoxTests.cs",
        "line": 108,
        "member": "Incursa.Platform.Tests.SqlOutboxStoreWhiteBoxTests.RescheduleAsync_IncrementsRetryCountAndSetsError"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlPlatformRegistrationTests.AddSqlPlatform_RegistersCoreDependencies",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlPlatform is called, core SQL Server storage dependencies should be registered.",
      "intent": "Verify the all-at-once SQL Server registration wires the required services.",
      "scenario": "Given a service collection configured with AddSqlPlatform.",
      "behavior": "Then outbox, inbox, audit, operations, and metrics dependencies resolve.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlPlatformRegistrationTests.cs",
        "line": 31,
        "member": "Incursa.Platform.Tests.SqlPlatformRegistrationTests.AddSqlPlatform_RegistersCoreDependencies"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlSchedulerClientTests.CancelTimerAsync_WithNonexistentTimerId_ReturnsFalse",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When cancelling a missing timer id, then CancelTimerAsync returns false.",
      "intent": "Confirm cancel is a no-op for unknown timers.",
      "scenario": "Call CancelTimerAsync with a random Guid string.",
      "behavior": "The result is false.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlSchedulerClientTests.cs",
        "line": 212,
        "member": "Incursa.Platform.Tests.SqlSchedulerClientTests.CancelTimerAsync_WithNonexistentTimerId_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlSchedulerClientTests.CancelTimerAsync_WithValidTimerId_UpdatesTimerStatus",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When cancelling an existing timer, then CancelTimerAsync returns true and status is Cancelled.",
      "intent": "Verify cancellation updates stored timer status.",
      "scenario": "Schedule a timer, then cancel it by id.",
      "behavior": "CancelTimerAsync returns true and the timer status is Cancelled.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlSchedulerClientTests.cs",
        "line": 181,
        "member": "Incursa.Platform.Tests.SqlSchedulerClientTests.CancelTimerAsync_WithValidTimerId_UpdatesTimerStatus"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlSchedulerClientTests.Constructor_WithValidConnectionString_CreatesInstance",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When constructing the scheduler client, then it provides an ISchedulerClient implementation.",
      "intent": "Verify SqlSchedulerClient instantiation succeeds.",
      "scenario": "Create a SqlSchedulerClient with default options and TimeProvider.System.",
      "behavior": "The client is not null and is assignable to ISchedulerClient.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlSchedulerClientTests.cs",
        "line": 47,
        "member": "Incursa.Platform.Tests.SqlSchedulerClientTests.Constructor_WithValidConnectionString_CreatesInstance"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlSchedulerClientTests.CreateOrUpdateJobAsync_ExistingJob_UpdatesJob",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a job already exists, then CreateOrUpdateJobAsync updates it without duplication.",
      "intent": "Verify upsert behavior for existing jobs.",
      "scenario": "Create a job, then call CreateOrUpdateJobAsync again with a new topic.",
      "behavior": "The job count remains one and the topic is updated.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlSchedulerClientTests.cs",
        "line": 286,
        "member": "Incursa.Platform.Tests.SqlSchedulerClientTests.CreateOrUpdateJobAsync_ExistingJob_UpdatesJob"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlSchedulerClientTests.CreateOrUpdateJobAsync_WithNullPayload_InsertsJobSuccessfully",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When creating a job with a null payload, then the stored payload remains null.",
      "intent": "Allow null payloads when defining jobs.",
      "scenario": "Create a job with payload set to null.",
      "behavior": "The payload column is DBNull for the job.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlSchedulerClientTests.cs",
        "line": 260,
        "member": "Incursa.Platform.Tests.SqlSchedulerClientTests.CreateOrUpdateJobAsync_WithNullPayload_InsertsJobSuccessfully"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlSchedulerClientTests.CreateOrUpdateJobAsync_WithValidParameters_InsertsJobToDatabase",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When creating a job, then a job row is inserted with name, topic, and cron schedule.",
      "intent": "Validate CreateOrUpdateJobAsync persists new jobs.",
      "scenario": "Create a job with name, topic, cron, and payload.",
      "behavior": "The jobs table contains one matching row.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlSchedulerClientTests.cs",
        "line": 230,
        "member": "Incursa.Platform.Tests.SqlSchedulerClientTests.CreateOrUpdateJobAsync_WithValidParameters_InsertsJobToDatabase"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlSchedulerClientTests.DeleteJobAsync_WithValidJobName_RemovesJob",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When deleting an existing job, then the job row is removed.",
      "intent": "Verify DeleteJobAsync removes jobs by name.",
      "scenario": "Create a job and then delete it by name.",
      "behavior": "The jobs table contains zero matching rows.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlSchedulerClientTests.cs",
        "line": 324,
        "member": "Incursa.Platform.Tests.SqlSchedulerClientTests.DeleteJobAsync_WithValidJobName_RemovesJob"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlSchedulerClientTests.ScheduleTimerAsync_WithCustomTableNames_InsertsToCorrectTable",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When custom scheduler table names are used, then timers are stored in the custom table.",
      "intent": "Ensure ScheduleTimerAsync honors custom table options.",
      "scenario": "Create custom schema/tables and schedule a timer with the custom client.",
      "behavior": "The custom timers table contains one matching row.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlSchedulerClientTests.cs",
        "line": 94,
        "member": "Incursa.Platform.Tests.SqlSchedulerClientTests.ScheduleTimerAsync_WithCustomTableNames_InsertsToCorrectTable"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlSchedulerClientTests.ScheduleTimerAsync_WithValidParameters_InsertsTimerToDatabase",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When scheduling a timer, then a timer row with the topic is inserted.",
      "intent": "Validate ScheduleTimerAsync persists timers.",
      "scenario": "Schedule a timer with topic, payload, and due time.",
      "behavior": "The returned id is a Guid and one matching timer row exists.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlSchedulerClientTests.cs",
        "line": 63,
        "member": "Incursa.Platform.Tests.SqlSchedulerClientTests.ScheduleTimerAsync_WithValidParameters_InsertsTimerToDatabase"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlSchedulerClientTests.ScheduleTimerAsync_WithValidParameters_SetsCorrectDefaults",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When scheduling a timer, then default timer columns are initialized.",
      "intent": "Verify default status and metadata values on insert.",
      "scenario": "Schedule a timer and read the stored row.",
      "behavior": "Status is Pending, ClaimedBy/ClaimedAt are null, RetryCount is 0, and CreatedAt is recent.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlSchedulerClientTests.cs",
        "line": 146,
        "member": "Incursa.Platform.Tests.SqlSchedulerClientTests.ScheduleTimerAsync_WithValidParameters_SetsCorrectDefaults"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlSchedulerClientTests.TriggerJobAsync_WithValidJobName_CreatesJobRun",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When triggering a job, then a job run is created for that job.",
      "intent": "Ensure TriggerJobAsync records a job run.",
      "scenario": "Create a job and trigger it by name.",
      "behavior": "The job runs table contains at least one row for the job.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlSchedulerClientTests.cs",
        "line": 352,
        "member": "Incursa.Platform.Tests.SqlSchedulerClientTests.TriggerJobAsync_WithValidJobName_CreatesJobRun"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SqlScriptDeploymentTests.SqlArtifacts_DeployInOrder",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When SQL artifacts are applied in order, then all scripts execute without errors.",
      "intent": "Verify the ordered SQL script set can be deployed sequentially.",
      "scenario": "Given a new test database and the ordered SQL script list from the database folder.",
      "behavior": "Then each script batch executes successfully in sequence.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SqlScriptDeploymentTests.cs",
        "line": 37,
        "member": "Incursa.Platform.Tests.SqlScriptDeploymentTests.SqlArtifacts_DeployInOrder"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_AfterLeaseReleased_CanAcquireAgain",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a lease is released, then the resource can be acquired again with a higher fencing token.",
      "intent": "Validate lease release frees the resource for subsequent acquisition.",
      "scenario": "Given a resource acquired once, then disposed, and acquired again.",
      "behavior": "Then the second lease succeeds and has a higher fencing token.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SystemLeaseTests.cs",
        "line": 107,
        "member": "Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_AfterLeaseReleased_CanAcquireAgain"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_ReentrantWithSameOwnerToken_Succeeds",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the same owner token acquires a lease twice, then both acquisitions succeed with increasing fencing tokens.",
      "intent": "Validate re-entrant acquisition with the same owner token.",
      "scenario": "Given two AcquireAsync calls for the same resource using the same OwnerToken.",
      "behavior": "Then both leases are non-null and the second fencing token is greater than the first.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SystemLeaseTests.cs",
        "line": 237,
        "member": "Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_ReentrantWithSameOwnerToken_Succeeds"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_SameResourceTwice_SecondCallReturnsNull",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AcquireAsync is called twice for the same resource, then the second call returns null.",
      "intent": "Ensure a lease cannot be acquired concurrently for the same resource.",
      "scenario": "Given a SqlLeaseFactory and two sequential AcquireAsync calls for the same resource.",
      "behavior": "Then the first lease is non-null and the second result is null.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SystemLeaseTests.cs",
        "line": 84,
        "member": "Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_SameResourceTwice_SecondCallReturnsNull"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_WithCustomOwnerToken_UsesProvidedToken",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a custom owner token is provided, then the acquired lease uses that token.",
      "intent": "Verify custom owner tokens are honored by AcquireAsync.",
      "scenario": "Given AcquireAsync invoked with a specific OwnerToken value.",
      "behavior": "Then the lease OwnerToken equals the supplied token.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SystemLeaseTests.cs",
        "line": 212,
        "member": "Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_WithCustomOwnerToken_UsesProvidedToken"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_WithDifferentResources_BothSucceed",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When acquiring leases for different resources, then both acquisitions succeed independently.",
      "intent": "Ensure leases are isolated per resource name.",
      "scenario": "Given two distinct resource names acquired sequentially.",
      "behavior": "Then both leases are non-null with matching resource names and distinct owner tokens.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SystemLeaseTests.cs",
        "line": 184,
        "member": "Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_WithDifferentResources_BothSucceed"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_WithValidResource_CanAcquireLease",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a lease is acquired for a new resource, then a valid lease instance is returned.",
      "intent": "Verify AcquireAsync produces a lease with expected identifiers and fencing token.",
      "scenario": "Given a SqlLeaseFactory and a unique resource name.",
      "behavior": "Then the lease has a non-empty owner token, positive fencing token, and matching resource name.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SystemLeaseTests.cs",
        "line": 59,
        "member": "Incursa.Platform.Tests.SystemLeaseTests.AcquireAsync_WithValidResource_CanAcquireLease"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SystemLeaseTests.ThrowIfLost_WhenLeaseIsValid_DoesNotThrow",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a lease is still valid, then ThrowIfLost does not throw.",
      "intent": "Verify lost-lease guard does not trigger for active leases.",
      "scenario": "Given an acquired lease that has not expired or been released.",
      "behavior": "Then calling ThrowIfLost completes without exception.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SystemLeaseTests.cs",
        "line": 163,
        "member": "Incursa.Platform.Tests.SystemLeaseTests.ThrowIfLost_WhenLeaseIsValid_DoesNotThrow"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.SqlServer.Tests:Incursa.Platform.Tests.SystemLeaseTests.TryRenewNowAsync_WithValidLease_SucceedsAndIncrementsFencingToken",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When TryRenewNowAsync is called on an active lease, then it succeeds and increments the fencing token.",
      "intent": "Ensure renewals advance the fencing token for valid leases.",
      "scenario": "Given an acquired lease and its initial fencing token value.",
      "behavior": "Then TryRenewNowAsync returns true and the fencing token increases.",
      "source": {
        "file": "tests/Incursa.Platform.SqlServer.Tests/SystemLeaseTests.cs",
        "line": 136,
        "member": "Incursa.Platform.Tests.SystemLeaseTests.TryRenewNowAsync_WithValidLease_SucceedsAndIncrementsFencingToken"
      },
      "status": "compliant",
      "project": "Incursa.Platform.SqlServer.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.CachedHealthCheckTests.BuilderRegistersCachedCheck_WithOptionsPerName",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a cached check is registered with per-name options, then the configured cache durations are honored.",
      "intent": "Ensure AddCachedCheck applies custom options for the named check.",
      "scenario": "Given a ServiceCollection with a FakeTimeProvider and a CountingHealthCheck registered via AddCachedCheck.",
      "behavior": "Then repeated health checks within the cache window do not re-invoke the inner check.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/CachedHealthCheckTests.cs",
        "line": 152,
        "member": "Incursa.Platform.Tests.CachedHealthCheckTests.BuilderRegistersCachedCheck_WithOptionsPerName"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.CachedHealthCheckTests.BuilderRegistersDelegateBasedCachedCheck_WithCaching",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a delegate-based cached check is registered, then caching reduces delegate invocations.",
      "intent": "Validate AddCachedCheck with a delegate honors the healthy cache duration.",
      "scenario": "Given a cached check delegate that increments a counter and a FakeTimeProvider.",
      "behavior": "Then three health checks result in two delegate invocations after time advances.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/CachedHealthCheckTests.cs",
        "line": 196,
        "member": "Incursa.Platform.Tests.CachedHealthCheckTests.BuilderRegistersDelegateBasedCachedCheck_WithCaching"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.CachedHealthCheckTests.CachesDegradedResults_UntilDurationExpires",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a degraded result is cached, then repeated checks within the degraded cache window reuse the result.",
      "intent": "Verify degraded results are cached for the configured duration.",
      "scenario": "Given a CachedHealthCheck with a FakeTimeProvider and a CountingHealthCheck returning Degraded.",
      "behavior": "Then the inner check runs twice across three calls as time advances past the cache duration.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/CachedHealthCheckTests.cs",
        "line": 116,
        "member": "Incursa.Platform.Tests.CachedHealthCheckTests.CachesDegradedResults_UntilDurationExpires"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.CachedHealthCheckTests.CachesHealthyResults_UntilDurationExpires",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a healthy result is cached, then repeated checks within the cache window reuse the result.",
      "intent": "Verify healthy results are cached for the configured duration.",
      "scenario": "Given a CachedHealthCheck with a FakeTimeProvider and a CountingHealthCheck returning Healthy.",
      "behavior": "Then the inner check runs twice across three calls separated by time advances.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/CachedHealthCheckTests.cs",
        "line": 40,
        "member": "Incursa.Platform.Tests.CachedHealthCheckTests.CachesHealthyResults_UntilDurationExpires"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.CachedHealthCheckTests.OptionsValidator_AcceptsValidOptions",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When cache durations are non-negative, then validation succeeds.",
      "intent": "Confirm valid CachedHealthCheckOptions pass validation.",
      "scenario": "Given options with positive healthy/degraded durations and zero unhealthy duration.",
      "behavior": "Then validation succeeds.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/CachedHealthCheckTests.cs",
        "line": 308,
        "member": "Incursa.Platform.Tests.CachedHealthCheckTests.OptionsValidator_AcceptsValidOptions"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.CachedHealthCheckTests.OptionsValidator_RejectsNegativeDegradedCacheDuration",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When DegradedCacheDuration is negative, then validation fails.",
      "intent": "Enforce non-negative degraded cache durations.",
      "scenario": "Given CachedHealthCheckOptions with a negative DegradedCacheDuration.",
      "behavior": "Then validation fails and references DegradedCacheDuration in the message.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/CachedHealthCheckTests.cs",
        "line": 262,
        "member": "Incursa.Platform.Tests.CachedHealthCheckTests.OptionsValidator_RejectsNegativeDegradedCacheDuration"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.CachedHealthCheckTests.OptionsValidator_RejectsNegativeHealthyCacheDuration",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When HealthyCacheDuration is negative, then validation fails.",
      "intent": "Enforce non-negative healthy cache durations.",
      "scenario": "Given CachedHealthCheckOptions with a negative HealthyCacheDuration.",
      "behavior": "Then validation fails and references HealthyCacheDuration in the message.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/CachedHealthCheckTests.cs",
        "line": 239,
        "member": "Incursa.Platform.Tests.CachedHealthCheckTests.OptionsValidator_RejectsNegativeHealthyCacheDuration"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.CachedHealthCheckTests.OptionsValidator_RejectsNegativeUnhealthyCacheDuration",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When UnhealthyCacheDuration is negative, then validation fails.",
      "intent": "Enforce non-negative unhealthy cache durations.",
      "scenario": "Given CachedHealthCheckOptions with a negative UnhealthyCacheDuration.",
      "behavior": "Then validation fails and references UnhealthyCacheDuration in the message.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/CachedHealthCheckTests.cs",
        "line": 285,
        "member": "Incursa.Platform.Tests.CachedHealthCheckTests.OptionsValidator_RejectsNegativeUnhealthyCacheDuration"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.CachedHealthCheckTests.RechecksImmediately_WhenUnhealthy",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an unhealthy result is returned with zero unhealthy cache duration, then the next check re-evaluates immediately.",
      "intent": "Ensure unhealthy results do not get cached when configured for immediate rechecks.",
      "scenario": "Given a SequenceHealthCheck that returns Unhealthy then Healthy with UnhealthyCacheDuration set to zero.",
      "behavior": "Then the second call invokes the inner check again and returns Healthy.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/CachedHealthCheckTests.cs",
        "line": 77,
        "member": "Incursa.Platform.Tests.CachedHealthCheckTests.RechecksImmediately_WhenUnhealthy"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.DrainFirstSelectionStrategyTests.SelectNext_MixedBehavior",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When processed counts vary across calls, then SelectNext sticks to busy stores and advances when empty.",
      "intent": "Validate mixed drain-first behavior across multiple stores.",
      "scenario": "Given three mock stores with alternating non-zero and zero processed counts.",
      "behavior": "Then SelectNext stays on active stores and moves on when processed count is zero.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/DrainFirstSelectionStrategyTests.cs",
        "line": 110,
        "member": "Incursa.Platform.Tests.DrainFirstSelectionStrategyTests.SelectNext_MixedBehavior"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.DrainFirstSelectionStrategyTests.SelectNext_MovesToNextStoreWhenNoMessagesProcessed",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When no messages are processed, then SelectNext advances to the next store.",
      "intent": "Verify drain-first advances when a store has no work.",
      "scenario": "Given three mock stores and zero processed counts on each call.",
      "behavior": "Then SelectNext moves to the next store and wraps around.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/DrainFirstSelectionStrategyTests.cs",
        "line": 83,
        "member": "Incursa.Platform.Tests.DrainFirstSelectionStrategyTests.SelectNext_MovesToNextStoreWhenNoMessagesProcessed"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.DrainFirstSelectionStrategyTests.SelectNext_SticksToSameStoreWhenMessagesProcessed",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a store processes messages, then SelectNext keeps returning the same store.",
      "intent": "Ensure drain-first strategy sticks to the current store while work is processed.",
      "scenario": "Given three mock stores and non-zero processed counts for the current store.",
      "behavior": "Then SelectNext continues to return the first store.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/DrainFirstSelectionStrategyTests.cs",
        "line": 61,
        "member": "Incursa.Platform.Tests.DrainFirstSelectionStrategyTests.SelectNext_SticksToSameStoreWhenMessagesProcessed"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.DrainFirstSelectionStrategyTests.SelectNext_WithNoStores_ReturnsNull",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When SelectNext is called with no stores, then it returns null.",
      "intent": "Verify drain-first selection handles empty inputs safely.",
      "scenario": "Given an empty store list and a new DrainFirstOutboxSelectionStrategy.",
      "behavior": "Then SelectNext returns null.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/DrainFirstSelectionStrategyTests.cs",
        "line": 43,
        "member": "Incursa.Platform.Tests.DrainFirstSelectionStrategyTests.SelectNext_WithNoStores_ReturnsNull"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.EngineRefactoringTests.Discovery_service_filters_engines",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When engines are listed and resolved with filters, then discovery returns the expected UI and webhook descriptors.",
      "intent": "Validate engine discovery filtering and webhook resolution by provider and event.",
      "scenario": "Given a ModuleEngineDiscoveryService built from FakeEngineModule descriptors.",
      "behavior": "Then UI and webhook engines are found via filters and ResolveWebhookEngine returns the expected module key.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/EngineRefactoringTests.cs",
        "line": 244,
        "member": "Incursa.Platform.Tests.EngineRefactoringTests.Discovery_service_filters_engines"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.EngineRefactoringTests.Ui_adapter_throws_when_engine_contract_is_mismatched",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a UI adapter targets an engine with a non-UI contract, then ExecuteAsync throws.",
      "intent": "Prevent UI adapters from invoking engines with mismatched contracts.",
      "scenario": "Given a UiEngineAdapter and a request for a webhook engine ID.",
      "behavior": "Then ExecuteAsync throws InvalidOperationException indicating the UI contract mismatch.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/EngineRefactoringTests.cs",
        "line": 220,
        "member": "Incursa.Platform.Tests.EngineRefactoringTests.Ui_adapter_throws_when_engine_contract_is_mismatched"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.EngineRefactoringTests.Ui_adapter_throws_when_engine_is_not_registered",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a UI engine is not registered for the requested engine ID, then ExecuteAsync throws.",
      "intent": "Ensure missing UI engines surface a clear error.",
      "scenario": "Given a UiEngineAdapter and a request targeting an unknown UI engine ID.",
      "behavior": "Then ExecuteAsync throws InvalidOperationException with a \"No UI engine registered\" message.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/EngineRefactoringTests.cs",
        "line": 196,
        "member": "Incursa.Platform.Tests.EngineRefactoringTests.Ui_adapter_throws_when_engine_is_not_registered"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.EngineRefactoringTests.Ui_engine_exception_propagates_to_adapter",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the UI engine throws during execution, then the adapter propagates the exception.",
      "intent": "Ensure engine exceptions are not swallowed by the adapter.",
      "scenario": "Given a LoginCommand with a missing username that triggers an ArgumentException in the engine.",
      "behavior": "Then ExecuteAsync throws ArgumentException.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/EngineRefactoringTests.cs",
        "line": 174,
        "member": "Incursa.Platform.Tests.EngineRefactoringTests.Ui_engine_exception_propagates_to_adapter"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.EngineRefactoringTests.Ui_engine_invocation_returns_view_model_and_navigation_tokens",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the UI engine executes a valid login command, then it returns a view model and navigation tokens.",
      "intent": "Verify UI engine execution returns expected view model data and navigation metadata.",
      "scenario": "Given a UiEngineAdapter wired with FakeEngineModule and a LoginCommand with credentials.",
      "behavior": "Then the response contains the username, a dashboard navigation token, and a login event.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/EngineRefactoringTests.cs",
        "line": 48,
        "member": "Incursa.Platform.Tests.EngineRefactoringTests.Ui_engine_invocation_returns_view_model_and_navigation_tokens"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.EngineRefactoringTests.Webhook_pipeline_authenticates_and_dispatches",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a webhook request has a valid event type, then the handler is invoked.",
      "intent": "Verify webhook classification and handler dispatch for accepted requests.",
      "scenario": "Given a Postmark webhook envelope with the expected event type header.",
      "behavior": "Then classification accepts the request and the handler processes the webhook.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/EngineRefactoringTests.cs",
        "line": 78,
        "member": "Incursa.Platform.Tests.EngineRefactoringTests.Webhook_pipeline_authenticates_and_dispatches"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.EngineRefactoringTests.Webhook_pipeline_requires_event_type_header",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the event type header is missing, then classification rejects the request.",
      "intent": "Ensure webhook classification requires an explicit event type header.",
      "scenario": "Given a webhook envelope without the event type header.",
      "behavior": "Then classification returns a rejected decision with a failure reason.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/EngineRefactoringTests.cs",
        "line": 136,
        "member": "Incursa.Platform.Tests.EngineRefactoringTests.Webhook_pipeline_requires_event_type_header"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExactlyOnceExecutorTests.ExecuteAsync_PermanentFailure_CompletesIdempotency",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When execute Async Permanent Failure Completes Idempotency, then it behaves as expected.",
      "intent": "Document expected behavior for execute Async Permanent Failure Completes Idempotency.",
      "scenario": "Given execute Async Permanent Failure Completes Idempotency.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExactlyOnceExecutorTests.cs",
        "line": 92,
        "member": "Incursa.Platform.Tests.ExactlyOnceExecutorTests.ExecuteAsync_PermanentFailure_CompletesIdempotency"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExactlyOnceExecutorTests.ExecuteAsync_ProbeConfirmation_CompletesAfterFailure",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When execute Async Probe Confirmation Completes After Failure, then it behaves as expected.",
      "intent": "Document expected behavior for execute Async Probe Confirmation Completes After Failure.",
      "scenario": "Given execute Async Probe Confirmation Completes After Failure.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExactlyOnceExecutorTests.cs",
        "line": 111,
        "member": "Incursa.Platform.Tests.ExactlyOnceExecutorTests.ExecuteAsync_ProbeConfirmation_CompletesAfterFailure"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExactlyOnceExecutorTests.ExecuteAsync_Success_CompletesIdempotency",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When execute Async Success Completes Idempotency, then it behaves as expected.",
      "intent": "Document expected behavior for execute Async Success Completes Idempotency.",
      "scenario": "Given execute Async Success Completes Idempotency.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExactlyOnceExecutorTests.cs",
        "line": 54,
        "member": "Incursa.Platform.Tests.ExactlyOnceExecutorTests.ExecuteAsync_Success_CompletesIdempotency"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExactlyOnceExecutorTests.ExecuteAsync_SuppressesDuplicateWithoutExecuting",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When execute Async Suppresses Duplicate Without Executing, then it behaves as expected.",
      "intent": "Document expected behavior for execute Async Suppresses Duplicate Without Executing.",
      "scenario": "Given execute Async Suppresses Duplicate Without Executing.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExactlyOnceExecutorTests.cs",
        "line": 29,
        "member": "Incursa.Platform.Tests.ExactlyOnceExecutorTests.ExecuteAsync_SuppressesDuplicateWithoutExecuting"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExactlyOnceExecutorTests.ExecuteAsync_TransientFailure_FailsIdempotency",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When execute Async Transient Failure Fails Idempotency, then it behaves as expected.",
      "intent": "Document expected behavior for execute Async Transient Failure Fails Idempotency.",
      "scenario": "Given execute Async Transient Failure Fails Idempotency.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExactlyOnceExecutorTests.cs",
        "line": 73,
        "member": "Incursa.Platform.Tests.ExactlyOnceExecutorTests.ExecuteAsync_TransientFailure_FailsIdempotency"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExactlyOnceHandlerTests.InboxHandler_PermanentFailure_ThrowsPermanentException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When inbox Handler Permanent Failure Throws Permanent Exception, then it behaves as expected.",
      "intent": "Document expected behavior for inbox Handler Permanent Failure Throws Permanent Exception.",
      "scenario": "Given inbox Handler Permanent Failure Throws Permanent Exception.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExactlyOnceHandlerTests.cs",
        "line": 87,
        "member": "Incursa.Platform.Tests.ExactlyOnceHandlerTests.InboxHandler_PermanentFailure_ThrowsPermanentException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExactlyOnceHandlerTests.InboxHandler_Suppressed_DoesNotExecute",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When inbox Handler Suppressed Does Not Execute, then it behaves as expected.",
      "intent": "Document expected behavior for inbox Handler Suppressed Does Not Execute.",
      "scenario": "Given inbox Handler Suppressed Does Not Execute.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExactlyOnceHandlerTests.cs",
        "line": 101,
        "member": "Incursa.Platform.Tests.ExactlyOnceHandlerTests.InboxHandler_Suppressed_DoesNotExecute"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExactlyOnceHandlerTests.InboxHandler_TransientFailure_ThrowsForRetry",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When inbox Handler Transient Failure Throws For Retry, then it behaves as expected.",
      "intent": "Document expected behavior for inbox Handler Transient Failure Throws For Retry.",
      "scenario": "Given inbox Handler Transient Failure Throws For Retry.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExactlyOnceHandlerTests.cs",
        "line": 74,
        "member": "Incursa.Platform.Tests.ExactlyOnceHandlerTests.InboxHandler_TransientFailure_ThrowsForRetry"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExactlyOnceHandlerTests.OutboxHandler_PermanentFailure_ThrowsPermanentException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When outbox Handler Permanent Failure Throws Permanent Exception, then it behaves as expected.",
      "intent": "Document expected behavior for outbox Handler Permanent Failure Throws Permanent Exception.",
      "scenario": "Given outbox Handler Permanent Failure Throws Permanent Exception.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExactlyOnceHandlerTests.cs",
        "line": 60,
        "member": "Incursa.Platform.Tests.ExactlyOnceHandlerTests.OutboxHandler_PermanentFailure_ThrowsPermanentException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExactlyOnceHandlerTests.OutboxHandler_Suppressed_DoesNotExecute",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When outbox Handler Suppressed Does Not Execute, then it behaves as expected.",
      "intent": "Document expected behavior for outbox Handler Suppressed Does Not Execute.",
      "scenario": "Given outbox Handler Suppressed Does Not Execute.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExactlyOnceHandlerTests.cs",
        "line": 30,
        "member": "Incursa.Platform.Tests.ExactlyOnceHandlerTests.OutboxHandler_Suppressed_DoesNotExecute"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExactlyOnceHandlerTests.OutboxHandler_TransientFailure_ThrowsForRetry",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When outbox Handler Transient Failure Throws For Retry, then it behaves as expected.",
      "intent": "Document expected behavior for outbox Handler Transient Failure Throws For Retry.",
      "scenario": "Given outbox Handler Transient Failure Throws For Retry.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExactlyOnceHandlerTests.cs",
        "line": 47,
        "member": "Incursa.Platform.Tests.ExactlyOnceHandlerTests.OutboxHandler_TransientFailure_ThrowsForRetry"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.ExceptionFilter_InRealCatchBlock_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsCatchable is used in a real catch filter, then it catches the regular exception.",
      "intent": "Demonstrate catch-filter usage with the exception filter.",
      "scenario": "Given a thrown InvalidOperationException inside a try/catch with ExceptionFilter.IsCatchable.",
      "behavior": "Then the exception is caught and recorded in the list.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 524,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.ExceptionFilter_InRealCatchBlock_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.ExceptionFilter_WithCriticalException_DoesNotCatch",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a critical exception is thrown, then the catch filter does not intercept it.",
      "intent": "Ensure critical exceptions bypass catchable filters.",
      "scenario": "Given an OutOfMemoryException thrown inside a try/catch with ExceptionFilter.IsCatchable.",
      "behavior": "Then the filter does not catch the exception and the flag remains false.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 556,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.ExceptionFilter_WithCriticalException_DoesNotCatch"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_RealWorldScenario_SqlExceptions",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When evaluating a catchable SQL-like exception versus a critical one, then only the catchable exception returns true.",
      "intent": "Demonstrate real-world filtering that excludes critical exceptions.",
      "scenario": "Given an InvalidOperationException representing a SQL error and an OutOfMemoryException representing a critical error.",
      "behavior": "Then IsCatchableAndExpected returns true for the SQL-like exception and false for the critical exception.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 652,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_RealWorldScenario_SqlExceptions"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_WithCatchableAndExpected_ReturnsTrue",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an exception is both catchable and expected, then IsCatchableAndExpected returns true.",
      "intent": "Validate combined catchable and expected filtering logic.",
      "scenario": "Given an InvalidOperationException and expected type InvalidOperationException.",
      "behavior": "Then IsCatchableAndExpected returns true.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 424,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_WithCatchableAndExpected_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_WithCatchableButNotExpected_ReturnsFalse",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an exception is catchable but not expected, then IsCatchableAndExpected returns false.",
      "intent": "Ensure expected-type filtering is enforced even for catchable exceptions.",
      "scenario": "Given an InvalidOperationException and an expected type of ArgumentException.",
      "behavior": "Then IsCatchableAndExpected returns false.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 478,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_WithCatchableButNotExpected_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_WithCriticalButExpected_ReturnsFalse",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an exception is critical even if expected, then IsCatchableAndExpected returns false.",
      "intent": "Ensure critical exceptions are never treated as catchable.",
      "scenario": "Given an OutOfMemoryException and expected type OutOfMemoryException.",
      "behavior": "Then IsCatchableAndExpected returns false.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 451,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_WithCriticalButExpected_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_WithNullException_ThrowsArgumentNullException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsCatchableAndExpected is called with a null exception, then it throws ArgumentNullException.",
      "intent": "Guard against null exception inputs for combined filtering.",
      "scenario": "Given a null exception argument.",
      "behavior": "Then an ArgumentNullException is thrown.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 505,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_WithNullException_ThrowsArgumentNullException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsCatchable_WithNullException_ThrowsArgumentNullException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsCatchable is called with a null exception, then it throws ArgumentNullException.",
      "intent": "Guard against null exception inputs.",
      "scenario": "Given a null exception argument.",
      "behavior": "Then an ArgumentNullException is thrown with parameter name \"exception\".",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 108,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsCatchable_WithNullException_ThrowsArgumentNullException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsCatchable_WithOutOfMemoryException_ReturnsFalse",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsCatchable is given an OutOfMemoryException, then it returns false.",
      "intent": "Ensure critical exceptions are not marked catchable.",
      "scenario": "Given an OutOfMemoryException instance.",
      "behavior": "Then IsCatchable returns false.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 58,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsCatchable_WithOutOfMemoryException_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsCatchable_WithRegularException_ReturnsTrue",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsCatchable is given a regular exception, then it returns true.",
      "intent": "Verify non-critical exceptions are considered catchable.",
      "scenario": "Given an InvalidOperationException instance.",
      "behavior": "Then IsCatchable returns true.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 33,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsCatchable_WithRegularException_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsCatchable_WithStackOverflowException_ReturnsFalse",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsCatchable is given a StackOverflowException, then it returns false.",
      "intent": "Ensure stack overflow is treated as non-catchable.",
      "scenario": "Given a StackOverflowException instance.",
      "behavior": "Then IsCatchable returns false.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 83,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsCatchable_WithStackOverflowException_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsCatchable_WithVariousCommonExceptions_ReturnsTrue",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsCatchable is evaluated for common exception types, then it returns true.",
      "intent": "Validate catchable classification for typical application exceptions.",
      "scenario": "Given an exception instance created from each common exception type in the data set.",
      "behavior": "Then IsCatchable returns true for each provided type.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 601,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsCatchable_WithVariousCommonExceptions_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsCritical_WithNullException_ThrowsArgumentNullException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsCritical is called with a null exception, then it throws ArgumentNullException.",
      "intent": "Guard against null exception inputs for critical checks.",
      "scenario": "Given a null exception argument.",
      "behavior": "Then an ArgumentNullException is thrown with parameter name \"exception\".",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 203,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsCritical_WithNullException_ThrowsArgumentNullException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsCritical_WithOutOfMemoryException_ReturnsTrue",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsCritical is given an OutOfMemoryException, then it returns true.",
      "intent": "Classify out-of-memory conditions as critical.",
      "scenario": "Given an OutOfMemoryException instance.",
      "behavior": "Then IsCritical returns true.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 128,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsCritical_WithOutOfMemoryException_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsCritical_WithRegularException_ReturnsFalse",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsCritical is given a regular exception, then it returns false.",
      "intent": "Ensure non-critical exceptions are not flagged as critical.",
      "scenario": "Given an ArgumentException instance.",
      "behavior": "Then IsCritical returns false.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 178,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsCritical_WithRegularException_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsCritical_WithStackOverflowException_ReturnsTrue",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsCritical is given a StackOverflowException, then it returns true.",
      "intent": "Classify stack overflow conditions as critical.",
      "scenario": "Given a StackOverflowException instance.",
      "behavior": "Then IsCritical returns true.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 153,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsCritical_WithStackOverflowException_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsExpected_WithDerivedType_ReturnsTrue",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsExpected is given a derived exception and a base expected type, then it returns true.",
      "intent": "Confirm base expected types match derived exceptions.",
      "scenario": "Given an ArgumentNullException and expected type ArgumentException.",
      "behavior": "Then IsExpected returns true.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 277,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsExpected_WithDerivedType_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsExpected_WithEmptyExpectedTypes_ReturnsFalse",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsExpected is called with no expected types, then it returns false.",
      "intent": "Ensure empty expected type lists do not match any exception.",
      "scenario": "Given an InvalidOperationException and an empty expected type list.",
      "behavior": "Then IsExpected returns false.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 370,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsExpected_WithEmptyExpectedTypes_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsExpected_WithMatchingType_ReturnsTrue",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsExpected is given a matching exception type, then it returns true.",
      "intent": "Confirm exact type matches are treated as expected.",
      "scenario": "Given an InvalidOperationException and an expected type of InvalidOperationException.",
      "behavior": "Then IsExpected returns true.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 223,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsExpected_WithMatchingType_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsExpected_WithMultipleTypesAndMatch_ReturnsTrue",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsExpected is given multiple expected types including a base type, then it returns true for a derived exception.",
      "intent": "Validate derived exceptions match any compatible expected type.",
      "scenario": "Given an ArgumentNullException and expected types that include ArgumentException.",
      "behavior": "Then IsExpected returns true.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 248,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsExpected_WithMultipleTypesAndMatch_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsExpected_WithNonMatchingType_ReturnsFalse",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsExpected is given a non-matching expected type, then it returns false.",
      "intent": "Ensure unrelated exception types are not marked expected.",
      "scenario": "Given an InvalidOperationException and expected type ArgumentException.",
      "behavior": "Then IsExpected returns false.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 302,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsExpected_WithNonMatchingType_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsExpected_WithNullException_ThrowsArgumentNullException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsExpected is called with a null exception, then it throws ArgumentNullException.",
      "intent": "Guard against null exception inputs for expected checks.",
      "scenario": "Given a null exception argument.",
      "behavior": "Then an ArgumentNullException is thrown with parameter name \"exception\".",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 327,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsExpected_WithNullException_ThrowsArgumentNullException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsExpected_WithNullExpectedTypes_ThrowsArgumentNullException",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsExpected is called with null expected types, then it throws ArgumentNullException.",
      "intent": "Guard against null expected type arrays.",
      "scenario": "Given a non-null exception and a null expectedTypes array.",
      "behavior": "Then an ArgumentNullException is thrown with parameter name \"expectedTypes\".",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 347,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsExpected_WithNullExpectedTypes_ThrowsArgumentNullException"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsExpected_WithNullTypeInArray_IgnoresNullAndContinues",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsExpected encounters null entries in expected types, then it ignores them and still matches valid types.",
      "intent": "Verify null expected types do not break matching.",
      "scenario": "Given an ArgumentException and expected types containing nulls and ArgumentException.",
      "behavior": "Then IsExpected returns true.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 395,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsExpected_WithNullTypeInArray_IgnoresNullAndContinues"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ExceptionFilterTests.IsExpected_WithOperationCanceledException_WorksCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When IsExpected is given an OperationCanceledException and matching expected type, then it returns true.",
      "intent": "Confirm cancellation exceptions are matched when expected.",
      "scenario": "Given an OperationCanceledException and expected type OperationCanceledException.",
      "behavior": "Then IsExpected returns true.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ExceptionFilterTests.cs",
        "line": 627,
        "member": "Incursa.Platform.Tests.ExceptionFilterTests.IsExpected_WithOperationCanceledException_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.FanoutSystemTests.FanoutDispatcher_ShouldCreateCorrectTopicName",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a fanout topic name is constructed, then it follows the \"fanout:{fanoutTopic}:{workKey}\" convention.",
      "intent": "Document the fanout topic naming pattern used by the dispatcher.",
      "scenario": "Given a fanout topic of \"etl\" and a work key of \"payments\".",
      "behavior": "Then the expected topic is \"fanout:etl:payments\".",
      "source": {
        "file": "tests/Incursa.Platform.Tests/FanoutSystemTests.cs",
        "line": 71,
        "member": "Incursa.Platform.Tests.FanoutSystemTests.FanoutDispatcher_ShouldCreateCorrectTopicName"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.FanoutSystemTests.FanoutSlice_ShouldSerializeCorrectly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a FanoutSlice is serialized and deserialized, then its fields are preserved.",
      "intent": "Ensure FanoutSlice JSON round-trips correctly.",
      "scenario": "Given a FanoutSlice with explicit topic, shard key, work key, window start, and correlation ID.",
      "behavior": "Then the deserialized slice matches the original field values.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/FanoutSystemTests.cs",
        "line": 35,
        "member": "Incursa.Platform.Tests.FanoutSystemTests.FanoutSlice_ShouldSerializeCorrectly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.FanoutSystemTests.FanoutTopicOptions_ShouldHaveCorrectDefaults",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When FanoutTopicOptions is created with a fanout topic, then its default scheduling values are set.",
      "intent": "Verify default values for fanout scheduling configuration.",
      "scenario": "Given a FanoutTopicOptions instance with FanoutTopic set and no other overrides.",
      "behavior": "Then work key is null and cron, interval, jitter, and lease defaults are populated.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/FanoutSystemTests.cs",
        "line": 94,
        "member": "Incursa.Platform.Tests.FanoutSystemTests.FanoutTopicOptions_ShouldHaveCorrectDefaults"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.InboxSelectionStrategyTests.DrainFirst_HandlesEmptyStoreList",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the drain-first strategy is given no stores, then it returns null.",
      "intent": "Ensure empty store lists are handled safely in drain-first selection.",
      "scenario": "Given an empty list of IInboxWorkStore and a DrainFirstInboxSelectionStrategy.",
      "behavior": "Then SelectNext returns null.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/InboxSelectionStrategyTests.cs",
        "line": 158,
        "member": "Incursa.Platform.Tests.InboxSelectionStrategyTests.DrainFirst_HandlesEmptyStoreList"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.InboxSelectionStrategyTests.DrainFirst_MovesToNextStoreWhenEmpty",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a store processes zero messages, then the drain-first strategy advances to the next store.",
      "intent": "Verify drain-first moves on when the current store is empty.",
      "scenario": "Given two MockInboxWorkStore instances and zero processed counts.",
      "behavior": "Then SelectNext advances to the next store and wraps when needed.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/InboxSelectionStrategyTests.cs",
        "line": 127,
        "member": "Incursa.Platform.Tests.InboxSelectionStrategyTests.DrainFirst_MovesToNextStoreWhenEmpty"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.InboxSelectionStrategyTests.DrainFirst_ResetReturnsToFirstStore",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When Reset is called, then drain-first selection starts from the first store again.",
      "intent": "Validate reset clears the drain-first cursor.",
      "scenario": "Given a strategy that has advanced to the second store.",
      "behavior": "Then SelectNext returns the first store after Reset.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/InboxSelectionStrategyTests.cs",
        "line": 176,
        "member": "Incursa.Platform.Tests.InboxSelectionStrategyTests.DrainFirst_ResetReturnsToFirstStore"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.InboxSelectionStrategyTests.DrainFirst_StaysOnStoreWithMessages",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When messages are processed from a store, then the drain-first strategy stays on that store.",
      "intent": "Ensure drain-first keeps selecting the active store while work is processed.",
      "scenario": "Given two MockInboxWorkStore instances and non-zero processed counts.",
      "behavior": "Then SelectNext returns the current store repeatedly.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/InboxSelectionStrategyTests.cs",
        "line": 101,
        "member": "Incursa.Platform.Tests.InboxSelectionStrategyTests.DrainFirst_StaysOnStoreWithMessages"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.InboxSelectionStrategyTests.RoundRobin_CyclesThroughStoresEvenly",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When SelectNext is called repeatedly, then the round-robin strategy cycles through stores and wraps.",
      "intent": "Verify round-robin selection advances in order across inbox stores.",
      "scenario": "Given three MockInboxWorkStore instances and successive SelectNext calls.",
      "behavior": "Then the strategy returns store1, store2, store3, then wraps to store1.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/InboxSelectionStrategyTests.cs",
        "line": 27,
        "member": "Incursa.Platform.Tests.InboxSelectionStrategyTests.RoundRobin_CyclesThroughStoresEvenly"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.InboxSelectionStrategyTests.RoundRobin_HandlesEmptyStoreList",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the round-robin strategy is given no stores, then it returns null.",
      "intent": "Ensure empty store lists are handled safely.",
      "scenario": "Given an empty list of IInboxWorkStore and a RoundRobinInboxSelectionStrategy.",
      "behavior": "Then SelectNext returns null.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/InboxSelectionStrategyTests.cs",
        "line": 57,
        "member": "Incursa.Platform.Tests.InboxSelectionStrategyTests.RoundRobin_HandlesEmptyStoreList"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.InboxSelectionStrategyTests.RoundRobin_ResetReturnsToFirstStore",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When Reset is called, then round-robin selection starts from the first store again.",
      "intent": "Validate reset clears the round-robin cursor.",
      "scenario": "Given a strategy that has already advanced to a later store.",
      "behavior": "Then SelectNext returns the first store after Reset.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/InboxSelectionStrategyTests.cs",
        "line": 75,
        "member": "Incursa.Platform.Tests.InboxSelectionStrategyTests.RoundRobin_ResetReturnsToFirstStore"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Calculate_Percentiles",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a distribution of values is recorded, then percentile estimates are populated and within expected ranges.",
      "intent": "Validate percentile calculation for a known 1..100 data set.",
      "scenario": "Given a MetricAggregator that records integers 1 through 100.",
      "behavior": "Then P50, P95, and P99 are non-null and fall within expected ranges.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/MetricAggregatorTests.cs",
        "line": 86,
        "member": "Incursa.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Calculate_Percentiles"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Calculate_Sum_And_Count",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When values are recorded, then the snapshot returns the correct sum and count.",
      "intent": "Verify aggregation totals across multiple recorded values.",
      "scenario": "Given a MetricAggregator that records three numeric values.",
      "behavior": "Then GetSnapshotAndReset reports sum 60 and count 3.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/MetricAggregatorTests.cs",
        "line": 29,
        "member": "Incursa.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Calculate_Sum_And_Count"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Handle_Empty_State",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When no values are recorded, then the snapshot reports zeros and null percentiles.",
      "intent": "Verify the empty state snapshot uses default aggregate values.",
      "scenario": "Given a new MetricAggregator with no recorded values.",
      "behavior": "Then GetSnapshotAndReset returns zero sum/count and null min/max/percentiles.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/MetricAggregatorTests.cs",
        "line": 141,
        "member": "Incursa.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Handle_Empty_State"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Reset_After_Snapshot",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a snapshot is taken, then the aggregator resets its state for subsequent readings.",
      "intent": "Ensure GetSnapshotAndReset clears accumulated values.",
      "scenario": "Given a MetricAggregator that records two values and then snapshots twice.",
      "behavior": "Then the second snapshot returns zeros and nulls for all aggregates.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/MetricAggregatorTests.cs",
        "line": 117,
        "member": "Incursa.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Reset_After_Snapshot"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Track_Last_Value",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When values are recorded, then the snapshot keeps the last recorded value.",
      "intent": "Verify the aggregator tracks the most recent observation.",
      "scenario": "Given a MetricAggregator that records 10, 20, then 15.",
      "behavior": "Then GetSnapshotAndReset returns Last = 15.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/MetricAggregatorTests.cs",
        "line": 68,
        "member": "Incursa.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Track_Last_Value"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Track_Min_And_Max",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When values are recorded, then the snapshot reports the minimum and maximum correctly.",
      "intent": "Ensure min/max tracking reflects the recorded range.",
      "scenario": "Given a MetricAggregator that records values 5, 15, 3, and 20.",
      "behavior": "Then GetSnapshotAndReset returns Min = 3 and Max = 20.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/MetricAggregatorTests.cs",
        "line": 48,
        "member": "Incursa.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Track_Min_And_Max"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.MetricRegistrarTests.IsTagAllowed_WithRegisteredMetricAndAllowedTag_ReturnsTrue",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a registered metric allows a tag, then IsTagAllowed returns true.",
      "intent": "Confirm allowed tags are honored for registered metrics.",
      "scenario": "Given a registered metric that includes the \"allowed_tag\" value.",
      "behavior": "Then IsTagAllowed returns true for that tag.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/MetricRegistrarTests.cs",
        "line": 109,
        "member": "Incursa.Platform.Tests.MetricRegistrarTests.IsTagAllowed_WithRegisteredMetricAndAllowedTag_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.MetricRegistrarTests.IsTagAllowed_WithRegisteredMetricAndDisallowedTag_ReturnsFalse",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a registered metric does not allow a tag, then IsTagAllowed returns false.",
      "intent": "Ensure disallowed tags are rejected even for registered metrics.",
      "scenario": "Given a registered metric that only allows \"allowed_tag\".",
      "behavior": "Then IsTagAllowed returns false for a different tag value.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/MetricRegistrarTests.cs",
        "line": 134,
        "member": "Incursa.Platform.Tests.MetricRegistrarTests.IsTagAllowed_WithRegisteredMetricAndDisallowedTag_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.MetricRegistrarTests.IsTagAllowed_WithUnregisteredMetric_ReturnsFalse",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a metric is not registered, then IsTagAllowed returns false for any tag.",
      "intent": "Verify tag checks fail for unknown metrics.",
      "scenario": "Given a MetricRegistrar with no registration for \"unknown.metric\".",
      "behavior": "Then IsTagAllowed returns false for the requested tag.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/MetricRegistrarTests.cs",
        "line": 159,
        "member": "Incursa.Platform.Tests.MetricRegistrarTests.IsTagAllowed_WithUnregisteredMetric_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.MetricRegistrarTests.RegisterRange_WithMultipleMetrics_AddsAllToRegistry",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When multiple metrics are registered in bulk, then all of them appear in the registry.",
      "intent": "Verify RegisterRange registers each provided metric.",
      "scenario": "Given three MetricRegistration instances passed to RegisterRange.",
      "behavior": "Then GetAll returns three entries matching the metric names.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/MetricRegistrarTests.cs",
        "line": 81,
        "member": "Incursa.Platform.Tests.MetricRegistrarTests.RegisterRange_WithMultipleMetrics_AddsAllToRegistry"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.MetricRegistrarTests.Register_WithDuplicateMetric_LogsWarning",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the same metric is registered twice, then the registry keeps a single entry.",
      "intent": "Ensure duplicate registration does not create duplicate entries.",
      "scenario": "Given a MetricRegistrar that registers the same metric twice.",
      "behavior": "Then GetAll returns one registration for the metric.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/MetricRegistrarTests.cs",
        "line": 55,
        "member": "Incursa.Platform.Tests.MetricRegistrarTests.Register_WithDuplicateMetric_LogsWarning"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.MetricRegistrarTests.Register_WithValidMetric_AddsToRegistry",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a valid metric is registered, then it appears in the registry.",
      "intent": "Verify MetricRegistrar stores new metric registrations.",
      "scenario": "Given a MetricRegistrar and a MetricRegistration for \"test.metric\".",
      "behavior": "Then GetAll returns a single entry that matches the registered metric.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/MetricRegistrarTests.cs",
        "line": 29,
        "member": "Incursa.Platform.Tests.MetricRegistrarTests.Register_WithValidMetric_AddsToRegistry"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ObservabilityRegistrationTests.AddPlatformObservability_AllowsConfiguration",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddPlatformObservability is configured, then the options reflect the provided settings.",
      "intent": "Ensure custom observability options are bound into IOptions.",
      "scenario": "Given AddPlatformObservability invoked with a configuration delegate.",
      "behavior": "Then ObservabilityOptions exposes the configured metrics, logging, and scan period values.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ObservabilityRegistrationTests.cs",
        "line": 52,
        "member": "Incursa.Platform.Tests.ObservabilityRegistrationTests.AddPlatformObservability_AllowsConfiguration"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ObservabilityRegistrationTests.AddPlatformObservability_RegistersRequiredServices",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When AddPlatformObservability is called, then watchdog services are registered in DI.",
      "intent": "Verify basic observability wiring registers the watchdog and hosted service.",
      "scenario": "Given a ServiceCollection with logging and AddPlatformObservability applied.",
      "behavior": "Then IWatchdog resolves and WatchdogService is present among hosted services.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ObservabilityRegistrationTests.cs",
        "line": 29,
        "member": "Incursa.Platform.Tests.ObservabilityRegistrationTests.AddPlatformObservability_RegistersRequiredServices"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ObservabilityRegistrationTests.ObservabilityBuilder_CanAddAlertSink",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When an alert sink is added via the builder, then it is registered for resolution.",
      "intent": "Verify watchdog alert sinks can be registered through the builder.",
      "scenario": "Given AddPlatformObservability followed by AddWatchdogAlertSink with a delegate.",
      "behavior": "Then IWatchdogAlertSink services are present in DI.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ObservabilityRegistrationTests.cs",
        "line": 80,
        "member": "Incursa.Platform.Tests.ObservabilityRegistrationTests.ObservabilityBuilder_CanAddAlertSink"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ObservabilityRegistrationTests.ObservabilityBuilder_CanAddHealthChecks",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When platform health checks are added via the builder, then the health check service is registered.",
      "intent": "Confirm health check registration is wired through observability setup.",
      "scenario": "Given AddPlatformObservability followed by AddPlatformHealthChecks.",
      "behavior": "Then HealthCheckService resolves from the service provider.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ObservabilityRegistrationTests.cs",
        "line": 127,
        "member": "Incursa.Platform.Tests.ObservabilityRegistrationTests.ObservabilityBuilder_CanAddHealthChecks"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ObservabilityRegistrationTests.ObservabilityBuilder_CanAddHeartbeatSink",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a heartbeat sink is added via the builder, then it is registered for resolution.",
      "intent": "Verify heartbeat sinks can be registered through the observability builder.",
      "scenario": "Given AddPlatformObservability followed by AddHeartbeatSink with a delegate.",
      "behavior": "Then IHeartbeatSink services are present in DI.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ObservabilityRegistrationTests.cs",
        "line": 105,
        "member": "Incursa.Platform.Tests.ObservabilityRegistrationTests.ObservabilityBuilder_CanAddHeartbeatSink"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ObservabilityRegistrationTests.WatchdogAlertContext_ContainsAllRequiredFields",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a WatchdogAlertContext is created, then all supplied fields are preserved.",
      "intent": "Verify alert context carries kind, component, timestamps, and attributes.",
      "scenario": "Given a WatchdogAlertContext constructed with explicit values and attributes.",
      "behavior": "Then the properties match the provided inputs, including attribute entries.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ObservabilityRegistrationTests.cs",
        "line": 150,
        "member": "Incursa.Platform.Tests.ObservabilityRegistrationTests.WatchdogAlertContext_ContainsAllRequiredFields"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.ObservabilityRegistrationTests.WatchdogSnapshot_ContainsAlerts",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a WatchdogSnapshot is created with alerts, then those alerts are retained.",
      "intent": "Ensure watchdog snapshots surface alert payloads and timestamps.",
      "scenario": "Given a WatchdogSnapshot constructed with one ActiveAlert and timestamps.",
      "behavior": "Then the snapshot contains the alert and preserves LastScanAt/LastHeartbeatAt.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/ObservabilityRegistrationTests.cs",
        "line": 184,
        "member": "Incursa.Platform.Tests.ObservabilityRegistrationTests.WatchdogSnapshot_ContainsAlerts"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.OutboxMessageTests.OutboxMessage_IsPublicSealedRecord",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When OutboxMessage is inspected, then it is a public sealed record-like class.",
      "intent": "Verify the OutboxMessage type characteristics (public, sealed, record semantics).",
      "scenario": "Given reflection checks against the OutboxMessage type.",
      "behavior": "Then the type is public, sealed, class-based, and has a virtual ToString.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/OutboxMessageTests.cs",
        "line": 86,
        "member": "Incursa.Platform.Tests.OutboxMessageTests.OutboxMessage_IsPublicSealedRecord"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.OutboxMessageTests.OutboxMessage_IsRecord_WithCorrectProperties",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the OutboxMessage type is inspected, then it exposes the expected core properties.",
      "intent": "Confirm the record exposes required outbox fields with correct types.",
      "scenario": "Given reflection over the OutboxMessage type.",
      "behavior": "Then Id, Topic, Payload, and CorrelationId properties exist with expected types.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/OutboxMessageTests.cs",
        "line": 26,
        "member": "Incursa.Platform.Tests.OutboxMessageTests.OutboxMessage_IsRecord_WithCorrectProperties"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.OutboxMessageTests.OutboxMessage_Properties_HaveExpectedTypes",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When OutboxMessage properties are reflected, then each property has the expected CLR type.",
      "intent": "Validate type metadata for outbox message properties.",
      "scenario": "Given reflection over all OutboxMessage properties.",
      "behavior": "Then the property types match the expected identifier, string, and timestamp types.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/OutboxMessageTests.cs",
        "line": 62,
        "member": "Incursa.Platform.Tests.OutboxMessageTests.OutboxMessage_Properties_HaveExpectedTypes"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.PlatformMetricCatalogTests.All_ContainsDlqMetrics",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the platform metric catalog is enumerated, then it contains the expected DLQ metrics.",
      "intent": "Verify that dead-letter queue metrics are registered in the catalog.",
      "scenario": "Given PlatformMetricCatalog.All is evaluated.",
      "behavior": "Then the list includes DLQ depth and oldest age metrics.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/PlatformMetricCatalogTests.cs",
        "line": 109,
        "member": "Incursa.Platform.Tests.PlatformMetricCatalogTests.All_ContainsDlqMetrics"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.PlatformMetricCatalogTests.All_ContainsInboxMetrics",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the platform metric catalog is enumerated, then it contains the expected inbox metrics.",
      "intent": "Verify that inbox metrics are registered in the catalog.",
      "scenario": "Given PlatformMetricCatalog.All is evaluated.",
      "behavior": "Then the list includes inbox processed, retry, failed, and processing latency metrics.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/PlatformMetricCatalogTests.cs",
        "line": 84,
        "member": "Incursa.Platform.Tests.PlatformMetricCatalogTests.All_ContainsInboxMetrics"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.PlatformMetricCatalogTests.All_ContainsOutboxMetrics",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the platform metric catalog is enumerated, then it contains the expected outbox metrics.",
      "intent": "Verify that outbox metrics are registered in the catalog.",
      "scenario": "Given PlatformMetricCatalog.All is evaluated.",
      "behavior": "Then the list includes outbox published, pending, oldest age, and latency metrics.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/PlatformMetricCatalogTests.cs",
        "line": 59,
        "member": "Incursa.Platform.Tests.PlatformMetricCatalogTests.All_ContainsOutboxMetrics"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.PlatformMetricCatalogTests.All_CounterMetricsHaveCountUnit",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When counter metrics are selected from the catalog, then their units are count except for latency or age metrics.",
      "intent": "Validate unit conventions for counter metrics.",
      "scenario": "Given PlatformMetricCatalog.All is filtered to counter aggregation metrics.",
      "behavior": "Then non-latency and non-age counters use the Count unit.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/PlatformMetricCatalogTests.cs",
        "line": 163,
        "member": "Incursa.Platform.Tests.PlatformMetricCatalogTests.All_CounterMetricsHaveCountUnit"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.PlatformMetricCatalogTests.All_HistogramMetricsHaveTimeUnits",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When histogram metrics are selected from the catalog, then their units are time-based.",
      "intent": "Ensure histogram metrics report timing in milliseconds or seconds.",
      "scenario": "Given PlatformMetricCatalog.All is filtered to histogram aggregation metrics.",
      "behavior": "Then each histogram metric uses Milliseconds or Seconds units.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/PlatformMetricCatalogTests.cs",
        "line": 195,
        "member": "Incursa.Platform.Tests.PlatformMetricCatalogTests.All_HistogramMetricsHaveTimeUnits"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.PlatformMetricCatalogTests.All_MetricsHaveValidProperties",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the platform metric catalog is enumerated, then each metric has required metadata populated.",
      "intent": "Ensure metric definitions have valid names, units, descriptions, tags, and aggregation kinds.",
      "scenario": "Given PlatformMetricCatalog.All is evaluated.",
      "behavior": "Then each metric has non-empty name/unit/description, non-null tags, and a defined aggregation kind.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/PlatformMetricCatalogTests.cs",
        "line": 132,
        "member": "Incursa.Platform.Tests.PlatformMetricCatalogTests.All_MetricsHaveValidProperties"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.PlatformMetricCatalogTests.All_ReturnsNonEmptyList",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the platform metric catalog is enumerated, then it returns a non-empty list.",
      "intent": "Ensure the catalog exposes at least one metric.",
      "scenario": "Given PlatformMetricCatalog.All is accessed without additional setup.",
      "behavior": "Then the returned list is not null and contains entries.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/PlatformMetricCatalogTests.cs",
        "line": 36,
        "member": "Incursa.Platform.Tests.PlatformMetricCatalogTests.All_ReturnsNonEmptyList"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.RoundRobinSelectionStrategyTests.Reset_ResetsToFirstStore",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When Reset is called, then the next selection starts from the first store.",
      "intent": "Validate that reset clears the round-robin cursor.",
      "scenario": "Given a strategy that has already advanced through mock stores.",
      "behavior": "Then SelectNext returns the first store after Reset.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/RoundRobinSelectionStrategyTests.cs",
        "line": 86,
        "member": "Incursa.Platform.Tests.RoundRobinSelectionStrategyTests.Reset_ResetsToFirstStore"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.RoundRobinSelectionStrategyTests.SelectNext_CyclesThroughStores",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When SelectNext is called repeatedly, then it cycles through stores in order and wraps around.",
      "intent": "Ensure round-robin selection advances deterministically through the store list.",
      "scenario": "Given three mock stores and successive SelectNext calls with the previously selected store.",
      "behavior": "Then the strategy returns store1, store2, store3, then wraps back to store1.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/RoundRobinSelectionStrategyTests.cs",
        "line": 61,
        "member": "Incursa.Platform.Tests.RoundRobinSelectionStrategyTests.SelectNext_CyclesThroughStores"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.RoundRobinSelectionStrategyTests.SelectNext_WithNoStores_ReturnsNull",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When SelectNext is called with no stores, then it returns null.",
      "intent": "Verify the round-robin strategy handles empty inputs safely.",
      "scenario": "Given an empty store list and a new RoundRobinOutboxSelectionStrategy instance.",
      "behavior": "Then SelectNext returns null.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/RoundRobinSelectionStrategyTests.cs",
        "line": 43,
        "member": "Incursa.Platform.Tests.RoundRobinSelectionStrategyTests.SelectNext_WithNoStores_ReturnsNull"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.SchedulerMetricsTests.WorkQueueMetrics_Should_Be_Registered",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When SchedulerMetrics is referenced, then all work-queue metric definitions are initialized.",
      "intent": "Verify scheduler work-queue metrics are registered and available.",
      "scenario": "Given access to the SchedulerMetrics static properties.",
      "behavior": "Then all inbox/outbox and timing metrics are non-null.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/SchedulerMetricsTests.cs",
        "line": 24,
        "member": "Incursa.Platform.Tests.SchedulerMetricsTests.WorkQueueMetrics_Should_Be_Registered"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.StartupCheckLiveHealthEndpointTests.LiveEndpoint_Returns503WhileStartupChecksRun",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When live Endpoint Returns503 While Startup Checks Run, then it behaves as expected.",
      "intent": "Document expected behavior for live Endpoint Returns503 While Startup Checks Run.",
      "scenario": "Given live Endpoint Returns503 While Startup Checks Run.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/StartupCheckLiveHealthEndpointTests.cs",
        "line": 32,
        "member": "Incursa.Platform.Tests.StartupCheckLiveHealthEndpointTests.LiveEndpoint_Returns503WhileStartupChecksRun"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.StartupCheckRunnerHostedServiceTests.StartAsync_CriticalFailureStopsFurtherChecks",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When start Async Critical Failure Stops Further Checks, then it behaves as expected.",
      "intent": "Document expected behavior for start Async Critical Failure Stops Further Checks.",
      "scenario": "Given start Async Critical Failure Stops Further Checks.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/StartupCheckRunnerHostedServiceTests.cs",
        "line": 78,
        "member": "Incursa.Platform.Tests.StartupCheckRunnerHostedServiceTests.StartAsync_CriticalFailureStopsFurtherChecks"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.StartupCheckRunnerHostedServiceTests.StartAsync_ExecutesChecksInOrder",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When start Async Executes Checks In Order, then it behaves as expected.",
      "intent": "Document expected behavior for start Async Executes Checks In Order.",
      "scenario": "Given start Async Executes Checks In Order.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/StartupCheckRunnerHostedServiceTests.cs",
        "line": 28,
        "member": "Incursa.Platform.Tests.StartupCheckRunnerHostedServiceTests.StartAsync_ExecutesChecksInOrder"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.StartupCheckRunnerHostedServiceTests.StartAsync_NonCriticalFailureLogsAndContinues",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When start Async Non Critical Failure Logs And Continues, then it behaves as expected.",
      "intent": "Document expected behavior for start Async Non Critical Failure Logs And Continues.",
      "scenario": "Given start Async Non Critical Failure Logs And Continues.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/StartupCheckRunnerHostedServiceTests.cs",
        "line": 103,
        "member": "Incursa.Platform.Tests.StartupCheckRunnerHostedServiceTests.StartAsync_NonCriticalFailureLogsAndContinues"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.StartupCheckRunnerHostedServiceTests.StartAsync_ThrowsWhenDuplicateNames",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When start Async Throws When Duplicate Names, then it behaves as expected.",
      "intent": "Document expected behavior for start Async Throws When Duplicate Names.",
      "scenario": "Given start Async Throws When Duplicate Names.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/StartupCheckRunnerHostedServiceTests.cs",
        "line": 54,
        "member": "Incursa.Platform.Tests.StartupCheckRunnerHostedServiceTests.StartAsync_ThrowsWhenDuplicateNames"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.StartupCheckValidatorTests.ValidateUniqueNames_ThrowsOnDuplicates",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When validate Unique Names Throws On Duplicates, then it behaves as expected.",
      "intent": "Document expected behavior for validate Unique Names Throws On Duplicates.",
      "scenario": "Given validate Unique Names Throws On Duplicates.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/StartupCheckValidatorTests.cs",
        "line": 41,
        "member": "Incursa.Platform.Tests.StartupCheckValidatorTests.ValidateUniqueNames_ThrowsOnDuplicates"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.StartupCheckValidatorTests.Validate_ThrowsWhenNameMissing",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When validate Throws When Name Missing, then it behaves as expected.",
      "intent": "Document expected behavior for validate Throws When Name Missing.",
      "scenario": "Given validate Throws When Name Missing.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/StartupCheckValidatorTests.cs",
        "line": 29,
        "member": "Incursa.Platform.Tests.StartupCheckValidatorTests.Validate_ThrowsWhenNameMissing"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.StartupLatchHealthCheckTests.CheckHealthAsync_ReturnsHealthy_WhenLatchIsReady",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When check Health Async Returns Healthy When Latch Is Ready, then it behaves as expected.",
      "intent": "Document expected behavior for check Health Async Returns Healthy When Latch Is Ready.",
      "scenario": "Given check Health Async Returns Healthy When Latch Is Ready.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/StartupLatchHealthCheckTests.cs",
        "line": 28,
        "member": "Incursa.Platform.Tests.StartupLatchHealthCheckTests.CheckHealthAsync_ReturnsHealthy_WhenLatchIsReady"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.StartupLatchHealthCheckTests.CheckHealthAsync_ReturnsUnhealthy_WhenLatchIsNotReady",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When check Health Async Returns Unhealthy When Latch Is Not Ready, then it behaves as expected.",
      "intent": "Document expected behavior for check Health Async Returns Unhealthy When Latch Is Not Ready.",
      "scenario": "Given check Health Async Returns Unhealthy When Latch Is Not Ready.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/StartupLatchHealthCheckTests.cs",
        "line": 46,
        "member": "Incursa.Platform.Tests.StartupLatchHealthCheckTests.CheckHealthAsync_ReturnsUnhealthy_WhenLatchIsNotReady"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.StartupLatchLiveHealthEndpointTests.LiveEndpoint_Returns503UntilStartupCompletes",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When live Endpoint Returns503 Until Startup Completes, then it behaves as expected.",
      "intent": "Document expected behavior for live Endpoint Returns503 Until Startup Completes.",
      "scenario": "Given live Endpoint Returns503 Until Startup Completes.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/StartupLatchLiveHealthEndpointTests.cs",
        "line": 31,
        "member": "Incursa.Platform.Tests.StartupLatchLiveHealthEndpointTests.LiveEndpoint_Returns503UntilStartupCompletes"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.StartupLatchTests.Concurrency_SanityCheck",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When concurrency Sanity Check, then it behaves as expected.",
      "intent": "Document expected behavior for concurrency Sanity Check.",
      "scenario": "Given concurrency Sanity Check.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/StartupLatchTests.cs",
        "line": 104,
        "member": "Incursa.Platform.Tests.StartupLatchTests.Concurrency_SanityCheck"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.StartupLatchTests.DisposingTwice_IsSafe",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When disposing Twice Is Safe, then it behaves as expected.",
      "intent": "Document expected behavior for disposing Twice Is Safe.",
      "scenario": "Given disposing Twice Is Safe.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/StartupLatchTests.cs",
        "line": 88,
        "member": "Incursa.Platform.Tests.StartupLatchTests.DisposingTwice_IsSafe"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.StartupLatchTests.IsReady_BecomesFalseAfterRegister",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When is Ready Becomes False After Register, then it behaves as expected.",
      "intent": "Document expected behavior for is Ready Becomes False After Register.",
      "scenario": "Given is Ready Becomes False After Register.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/StartupLatchTests.cs",
        "line": 38,
        "member": "Incursa.Platform.Tests.StartupLatchTests.IsReady_BecomesFalseAfterRegister"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.StartupLatchTests.IsReady_BecomesTrueAfterDispose",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When is Ready Becomes True After Dispose, then it behaves as expected.",
      "intent": "Document expected behavior for is Ready Becomes True After Dispose.",
      "scenario": "Given is Ready Becomes True After Dispose.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/StartupLatchTests.cs",
        "line": 52,
        "member": "Incursa.Platform.Tests.StartupLatchTests.IsReady_BecomesTrueAfterDispose"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.StartupLatchTests.IsReady_IsTrueInitially",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When is Ready Is True Initially, then it behaves as expected.",
      "intent": "Document expected behavior for is Ready Is True Initially.",
      "scenario": "Given is Ready Is True Initially.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/StartupLatchTests.cs",
        "line": 26,
        "member": "Incursa.Platform.Tests.StartupLatchTests.IsReady_IsTrueInitially"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.StartupLatchTests.MultipleSteps_AreRequiredBeforeReady",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When multiple Steps Are Required Before Ready, then it behaves as expected.",
      "intent": "Document expected behavior for multiple Steps Are Required Before Ready.",
      "scenario": "Given multiple Steps Are Required Before Ready.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/StartupLatchTests.cs",
        "line": 67,
        "member": "Incursa.Platform.Tests.StartupLatchTests.MultipleSteps_AreRequiredBeforeReady"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.TimeAbstractionTests.FakeTimeProvider_CanBeUsedForTesting",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When FakeTimeProvider is advanced, then GetUtcNow reflects the new time.",
      "intent": "Demonstrate deterministic time control with FakeTimeProvider.",
      "scenario": "Given a FakeTimeProvider initialized to a fixed instant.",
      "behavior": "Then advancing by one hour updates GetUtcNow by one hour.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/TimeAbstractionTests.cs",
        "line": 99,
        "member": "Incursa.Platform.Tests.TimeAbstractionTests.FakeTimeProvider_CanBeUsedForTesting"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.TimeAbstractionTests.MonoDeadline_Expired_ReturnsFalseWhenNotReached",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a deadline is in the future, then Expired returns false.",
      "intent": "Verify MonoDeadline reports not expired before the deadline.",
      "scenario": "Given a MonoDeadline one hour in the future and the same clock.",
      "behavior": "Then Expired returns false.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/TimeAbstractionTests.cs",
        "line": 63,
        "member": "Incursa.Platform.Tests.TimeAbstractionTests.MonoDeadline_Expired_ReturnsFalseWhenNotReached"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.TimeAbstractionTests.MonoDeadline_Expired_ReturnsTrueWhenReached",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a deadline is in the past, then Expired returns true.",
      "intent": "Verify MonoDeadline reports expired once the deadline is reached.",
      "scenario": "Given a MonoDeadline set to one second before the current clock time.",
      "behavior": "Then Expired returns true.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/TimeAbstractionTests.cs",
        "line": 81,
        "member": "Incursa.Platform.Tests.TimeAbstractionTests.MonoDeadline_Expired_ReturnsTrueWhenReached"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.TimeAbstractionTests.MonoDeadline_WorksWithFakeMonotonicClock",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a fake monotonic clock advances past a deadline, then Expired flips to true.",
      "intent": "Verify MonoDeadline works with a controllable monotonic clock.",
      "scenario": "Given a FakeMonotonicClock and a deadline 10 seconds in the future.",
      "behavior": "Then Expired is false before the advance and true after advancing 15 seconds.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/TimeAbstractionTests.cs",
        "line": 119,
        "member": "Incursa.Platform.Tests.TimeAbstractionTests.MonoDeadline_WorksWithFakeMonotonicClock"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.TimeAbstractionTests.MonotonicClock_Seconds_ReturnsPositiveValue",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When MonotonicClock seconds are read, then the value is positive.",
      "intent": "Ensure the monotonic clock exposes a positive elapsed seconds value.",
      "scenario": "Given a new MonotonicClock instance.",
      "behavior": "Then Seconds is greater than zero.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/TimeAbstractionTests.cs",
        "line": 46,
        "member": "Incursa.Platform.Tests.TimeAbstractionTests.MonotonicClock_Seconds_ReturnsPositiveValue"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.TimeAbstractionTests.MonotonicClock_Ticks_ReturnsIncreasingValues",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When MonotonicClock ticks are read twice, then the second value is not less than the first.",
      "intent": "Verify monotonic ticks do not move backwards.",
      "scenario": "Given a new MonotonicClock instance.",
      "behavior": "Then the second tick reading is greater than or equal to the first.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/TimeAbstractionTests.cs",
        "line": 28,
        "member": "Incursa.Platform.Tests.TimeAbstractionTests.MonotonicClock_Ticks_ReturnsIncreasingValues"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.WatchdogServiceTests.GetSnapshot_ReturnsInitialState",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When a new WatchdogService is created, then its snapshot is empty and timestamps equal the initial time.",
      "intent": "Verify the watchdog snapshot starts with no alerts.",
      "scenario": "Given a WatchdogService configured with a FakeTimeProvider and no sinks.",
      "behavior": "Then GetSnapshot returns empty alerts and timestamps equal the initial fake time.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/WatchdogServiceTests.cs",
        "line": 31,
        "member": "Incursa.Platform.Tests.WatchdogServiceTests.GetSnapshot_ReturnsInitialState"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.WatchdogServiceTests.WatchdogHealthCheck_ReturnsHealthy_WhenNoAlertsAsync",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When no alerts are present, then the watchdog health check reports Healthy.",
      "intent": "Validate health check status reflects an alert-free snapshot.",
      "scenario": "Given a WatchdogService with no alert sinks and no active alerts.",
      "behavior": "Then WatchdogHealthCheck returns Healthy.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/WatchdogServiceTests.cs",
        "line": 190,
        "member": "Incursa.Platform.Tests.WatchdogServiceTests.WatchdogHealthCheck_ReturnsHealthy_WhenNoAlertsAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.WatchdogServiceTests.WatchdogService_DetectsOverdueJobs",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When overdue jobs are reported by the scheduler state, then the watchdog emits an overdue-job alert.",
      "intent": "Verify job-overdue detection triggers alert sinks.",
      "scenario": "Given a FakeSchedulerState with an overdue job and a DelegateAlertSink.",
      "behavior": "Then an OverdueJob alert is emitted with the job id.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/WatchdogServiceTests.cs",
        "line": 127,
        "member": "Incursa.Platform.Tests.WatchdogServiceTests.WatchdogService_DetectsOverdueJobs"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.WatchdogServiceTests.WatchdogService_EmitsHeartbeat",
      "category": "Incursa.Platform.Tests",
      "tags": [],
      "summary": "When the heartbeat period elapses, then the watchdog emits a heartbeat to sinks.",
      "intent": "Ensure heartbeat scheduling triggers sink callbacks.",
      "scenario": "Given a WatchdogService with a DelegateHeartbeatSink and FakeTimeProvider advanced past heartbeat period.",
      "behavior": "Then the heartbeat sink is invoked with a sequence number.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/WatchdogServiceTests.cs",
        "line": 66,
        "member": "Incursa.Platform.Tests.WatchdogServiceTests.WatchdogService_EmitsHeartbeat"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Webhooks.AspNetCore.Tests:Incursa.Platform.Webhooks.AspNetCore.Tests.WebhookEndpointTests.AcceptedReturns202AndCallsIngestorAsync",
      "category": "Incursa.Platform.Webhooks",
      "tags": [],
      "summary": "When accepted Returns202 And Calls Ingestor Async, then it behaves as expected.",
      "intent": "Document expected behavior for accepted Returns202 And Calls Ingestor Async.",
      "scenario": "Given accepted Returns202 And Calls Ingestor Async.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Webhooks.AspNetCore.Tests/WebhookEndpointTests.cs",
        "line": 32,
        "member": "Incursa.Platform.Webhooks.AspNetCore.Tests.WebhookEndpointTests.AcceptedReturns202AndCallsIngestorAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Webhooks.AspNetCore.Tests"
    },
    {
      "testId": "Incursa.Platform.Webhooks.AspNetCore.Tests:Incursa.Platform.Webhooks.AspNetCore.Tests.WebhookEndpointTests.LoggingCallbacksEmitEvents",
      "category": "Incursa.Platform.Webhooks",
      "tags": [],
      "summary": "When logging Callbacks Emit Events, then it behaves as expected.",
      "intent": "Document expected behavior for logging Callbacks Emit Events.",
      "scenario": "Given logging Callbacks Emit Events.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Webhooks.AspNetCore.Tests/WebhookEndpointTests.cs",
        "line": 76,
        "member": "Incursa.Platform.Webhooks.AspNetCore.Tests.WebhookEndpointTests.LoggingCallbacksEmitEvents"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Webhooks.AspNetCore.Tests"
    },
    {
      "testId": "Incursa.Platform.Webhooks.AspNetCore.Tests:Incursa.Platform.Webhooks.AspNetCore.Tests.WebhookEndpointTests.RejectedReturns401Async",
      "category": "Incursa.Platform.Webhooks",
      "tags": [],
      "summary": "When rejected Returns401 Async, then it behaves as expected.",
      "intent": "Document expected behavior for rejected Returns401 Async.",
      "scenario": "Given rejected Returns401 Async.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Webhooks.AspNetCore.Tests/WebhookEndpointTests.cs",
        "line": 57,
        "member": "Incursa.Platform.Webhooks.AspNetCore.Tests.WebhookEndpointTests.RejectedReturns401Async"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Webhooks.AspNetCore.Tests"
    },
    {
      "testId": "Incursa.Platform.Webhooks.AspNetCore.Tests:Incursa.Platform.Webhooks.AspNetCore.Tests.WebhookProcessingHostedServiceTests.HostedServiceInvokesProcessorAsync",
      "category": "Incursa.Platform.Webhooks",
      "tags": [],
      "summary": "When hosted Service Invokes Processor Async, then it behaves as expected.",
      "intent": "Document expected behavior for hosted Service Invokes Processor Async.",
      "scenario": "Given hosted Service Invokes Processor Async.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Webhooks.AspNetCore.Tests/WebhookProcessingHostedServiceTests.cs",
        "line": 28,
        "member": "Incursa.Platform.Webhooks.AspNetCore.Tests.WebhookProcessingHostedServiceTests.HostedServiceInvokesProcessorAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Webhooks.AspNetCore.Tests"
    },
    {
      "testId": "Incursa.Platform.Webhooks.Tests:Incursa.Platform.Webhooks.Tests.WebhookIngestorTests.AcceptedStoresExactlyOnceAsync",
      "category": "Incursa.Platform.Webhooks",
      "tags": [],
      "summary": "When accepted Stores Exactly Once Async, then it behaves as expected.",
      "intent": "Document expected behavior for accepted Stores Exactly Once Async.",
      "scenario": "Given accepted Stores Exactly Once Async.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Webhooks.Tests/WebhookIngestorTests.cs",
        "line": 75,
        "member": "Incursa.Platform.Webhooks.Tests.WebhookIngestorTests.AcceptedStoresExactlyOnceAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Webhooks.Tests"
    },
    {
      "testId": "Incursa.Platform.Webhooks.Tests:Incursa.Platform.Webhooks.Tests.WebhookIngestorTests.AuthFailureReturnsRejectedAndDoesNotStoreAsync",
      "category": "Incursa.Platform.Webhooks",
      "tags": [],
      "summary": "When auth Failure Returns Rejected And Does Not Store Async, then it behaves as expected.",
      "intent": "Document expected behavior for auth Failure Returns Rejected And Does Not Store Async.",
      "scenario": "Given auth Failure Returns Rejected And Does Not Store Async.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Webhooks.Tests/WebhookIngestorTests.cs",
        "line": 31,
        "member": "Incursa.Platform.Webhooks.Tests.WebhookIngestorTests.AuthFailureReturnsRejectedAndDoesNotStoreAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Webhooks.Tests"
    },
    {
      "testId": "Incursa.Platform.Webhooks.Tests:Incursa.Platform.Webhooks.Tests.WebhookIngestorTests.CallbacksInvokedForRejectedAsync",
      "category": "Incursa.Platform.Webhooks",
      "tags": [],
      "summary": "When callbacks Invoked For Rejected Async, then it behaves as expected.",
      "intent": "Document expected behavior for callbacks Invoked For Rejected Async.",
      "scenario": "Given callbacks Invoked For Rejected Async.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Webhooks.Tests/WebhookIngestorTests.cs",
        "line": 126,
        "member": "Incursa.Platform.Webhooks.Tests.WebhookIngestorTests.CallbacksInvokedForRejectedAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Webhooks.Tests"
    },
    {
      "testId": "Incursa.Platform.Webhooks.Tests:Incursa.Platform.Webhooks.Tests.WebhookIngestorTests.DuplicateDedupeDoesNotStoreAgainAsync",
      "category": "Incursa.Platform.Webhooks",
      "tags": [],
      "summary": "When duplicate Dedupe Does Not Store Again Async, then it behaves as expected.",
      "intent": "Document expected behavior for duplicate Dedupe Does Not Store Again Async.",
      "scenario": "Given duplicate Dedupe Does Not Store Again Async.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Webhooks.Tests/WebhookIngestorTests.cs",
        "line": 103,
        "member": "Incursa.Platform.Webhooks.Tests.WebhookIngestorTests.DuplicateDedupeDoesNotStoreAgainAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Webhooks.Tests"
    },
    {
      "testId": "Incursa.Platform.Webhooks.Tests:Incursa.Platform.Webhooks.Tests.WebhookIngestorTests.IgnoredDoesNotStoreAsync",
      "category": "Incursa.Platform.Webhooks",
      "tags": [],
      "summary": "When ignored Does Not Store Async, then it behaves as expected.",
      "intent": "Document expected behavior for ignored Does Not Store Async.",
      "scenario": "Given ignored Does Not Store Async.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Webhooks.Tests/WebhookIngestorTests.cs",
        "line": 53,
        "member": "Incursa.Platform.Webhooks.Tests.WebhookIngestorTests.IgnoredDoesNotStoreAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Webhooks.Tests"
    },
    {
      "testId": "Incursa.Platform.Webhooks.Tests:Incursa.Platform.Webhooks.Tests.WebhookProcessorTests.MaxAttemptsPoisonsMessageAsync",
      "category": "Incursa.Platform.Webhooks",
      "tags": [],
      "summary": "When max Attempts Poisons Message Async, then it behaves as expected.",
      "intent": "Document expected behavior for max Attempts Poisons Message Async.",
      "scenario": "Given max Attempts Poisons Message Async.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Webhooks.Tests/WebhookProcessorTests.cs",
        "line": 90,
        "member": "Incursa.Platform.Webhooks.Tests.WebhookProcessorTests.MaxAttemptsPoisonsMessageAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Webhooks.Tests"
    },
    {
      "testId": "Incursa.Platform.Webhooks.Tests:Incursa.Platform.Webhooks.Tests.WebhookProcessorTests.NoHandlerMarksCompletedAsync",
      "category": "Incursa.Platform.Webhooks",
      "tags": [],
      "summary": "When no Handler Marks Completed Async, then it behaves as expected.",
      "intent": "Document expected behavior for no Handler Marks Completed Async.",
      "scenario": "Given no Handler Marks Completed Async.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Webhooks.Tests/WebhookProcessorTests.cs",
        "line": 118,
        "member": "Incursa.Platform.Webhooks.Tests.WebhookProcessorTests.NoHandlerMarksCompletedAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Webhooks.Tests"
    },
    {
      "testId": "Incursa.Platform.Webhooks.Tests:Incursa.Platform.Webhooks.Tests.WebhookProcessorTests.ProcessingInvokesCallbackAsync",
      "category": "Incursa.Platform.Webhooks",
      "tags": [],
      "summary": "When processing Invokes Callback Async, then it behaves as expected.",
      "intent": "Document expected behavior for processing Invokes Callback Async.",
      "scenario": "Given processing Invokes Callback Async.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Webhooks.Tests/WebhookProcessorTests.cs",
        "line": 141,
        "member": "Incursa.Platform.Webhooks.Tests.WebhookProcessorTests.ProcessingInvokesCallbackAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Webhooks.Tests"
    },
    {
      "testId": "Incursa.Platform.Webhooks.Tests:Incursa.Platform.Webhooks.Tests.WebhookProcessorTests.SuccessfulHandlingMarksCompletedAsync",
      "category": "Incursa.Platform.Webhooks",
      "tags": [],
      "summary": "When successful Handling Marks Completed Async, then it behaves as expected.",
      "intent": "Document expected behavior for successful Handling Marks Completed Async.",
      "scenario": "Given successful Handling Marks Completed Async.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Webhooks.Tests/WebhookProcessorTests.cs",
        "line": 31,
        "member": "Incursa.Platform.Webhooks.Tests.WebhookProcessorTests.SuccessfulHandlingMarksCompletedAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Webhooks.Tests"
    },
    {
      "testId": "Incursa.Platform.Webhooks.Tests:Incursa.Platform.Webhooks.Tests.WebhookProcessorTests.TransientFailureSchedulesRetryAsync",
      "category": "Incursa.Platform.Webhooks",
      "tags": [],
      "summary": "When transient Failure Schedules Retry Async, then it behaves as expected.",
      "intent": "Document expected behavior for transient Failure Schedules Retry Async.",
      "scenario": "Given transient Failure Schedules Retry Async.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.Webhooks.Tests/WebhookProcessorTests.cs",
        "line": 58,
        "member": "Incursa.Platform.Webhooks.Tests.WebhookProcessorTests.TransientFailureSchedulesRetryAsync"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Webhooks.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.Modularity.ModuleSystemTests.Engine_descriptors_must_use_module_key",
      "category": "Modularity",
      "tags": [],
      "summary": "When an engine descriptor uses a different module key, then AddModuleServices throws.",
      "intent": "Guard against mismatched module and engine descriptor keys.",
      "scenario": "Given ModuleWithMismatchedEngineDescriptor is registered and no required configuration is needed.",
      "behavior": "Then AddModuleServices throws and the error references the engine descriptor module key.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/Modularity/ModuleSystemTests.cs",
        "line": 174,
        "member": "Incursa.Platform.Tests.Modularity.ModuleSystemTests.Engine_descriptors_must_use_module_key"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.Modularity.ModuleSystemTests.Module_keys_must_be_unique",
      "category": "Modularity",
      "tags": [],
      "summary": "When multiple modules share the same key, then AddModuleServices throws an InvalidOperationException.",
      "intent": "Enforce unique module keys during registration.",
      "scenario": "Given SampleModule and ConflictingModule are registered with the same key and required configuration is provided.",
      "behavior": "Then AddModuleServices throws due to the duplicate module key.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/Modularity/ModuleSystemTests.cs",
        "line": 110,
        "member": "Incursa.Platform.Tests.Modularity.ModuleSystemTests.Module_keys_must_be_unique"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.Modularity.ModuleSystemTests.Module_keys_must_be_url_safe",
      "category": "Modularity",
      "tags": [],
      "summary": "When a module key contains a slash, then AddModuleServices throws with a URL-safety message.",
      "intent": "Ensure module keys are URL-safe for routing and metadata.",
      "scenario": "Given ModuleWithInvalidKey is registered and its required configuration key is supplied.",
      "behavior": "Then AddModuleServices throws and the error mentions that keys cannot contain slashes.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/Modularity/ModuleSystemTests.cs",
        "line": 142,
        "member": "Incursa.Platform.Tests.Modularity.ModuleSystemTests.Module_keys_must_be_url_safe"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.Modularity.ModuleSystemTests.Modules_are_registered_in_di",
      "category": "Modularity",
      "tags": [],
      "summary": "When module services are added, then the module definition is registered in DI.",
      "intent": "Ensure module definitions are accessible through the service provider.",
      "scenario": "Given SampleModule is registered and configuration includes its required key.",
      "behavior": "Then resolving IModuleDefinition returns a module with key \"sample-module\".",
      "source": {
        "file": "tests/Incursa.Platform.Tests/Modularity/ModuleSystemTests.cs",
        "line": 77,
        "member": "Incursa.Platform.Tests.Modularity.ModuleSystemTests.Modules_are_registered_in_di"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.Modularity.ModuleSystemTests.Modules_register_services_and_health",
      "category": "Modularity",
      "tags": [],
      "summary": "When a module is registered with its required configuration, then its services and health checks are added to DI.",
      "intent": "Verify that module registration wires up services and health checks.",
      "scenario": "Given SampleModule is registered and configuration provides its required key.",
      "behavior": "Then MarkerService is resolvable and the health check registration includes \"sample_module\".",
      "source": {
        "file": "tests/Incursa.Platform.Tests/Modularity/ModuleSystemTests.cs",
        "line": 42,
        "member": "Incursa.Platform.Tests.Modularity.ModuleSystemTests.Modules_register_services_and_health"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.Modularity.ModuleSystemTests.Registering_module_type_is_idempotent",
      "category": "Modularity",
      "tags": [],
      "summary": "When the same module type is registered twice, then the second registration is ignored without error.",
      "intent": "Confirm ModuleRegistry.RegisterModule is idempotent for identical types.",
      "scenario": "Given ModuleRegistry already contains SampleModule.",
      "behavior": "Then registering SampleModule again does not throw.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/Modularity/ModuleSystemTests.cs",
        "line": 230,
        "member": "Incursa.Platform.Tests.Modularity.ModuleSystemTests.Registering_module_type_is_idempotent"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.Modularity.ModuleSystemTests.Webhook_metadata_allows_fanout",
      "category": "Modularity",
      "tags": [],
      "summary": "When two modules register identical webhook metadata, then both engines are registered for fanout.",
      "intent": "Allow multiple webhook engines to handle the same provider/event pair.",
      "scenario": "Given WebhookModuleOne and WebhookModuleTwo declare the same webhook metadata.",
      "behavior": "Then AddModuleServices succeeds and both webhook engines are discoverable.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/Modularity/ModuleSystemTests.cs",
        "line": 200,
        "member": "Incursa.Platform.Tests.Modularity.ModuleSystemTests.Webhook_metadata_allows_fanout"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.Modularity.RazorPagesConfigurationTests.ConfigureRazorModulePages_invokes_module_configuration",
      "category": "Modularity",
      "tags": [],
      "summary": "When ConfigureRazorModulePages runs for a registered module, then RazorPagesOptions can be resolved from the service provider.",
      "intent": "Confirm that module Razor configuration wires up Razor pages options in DI.",
      "scenario": "Given TestRazorModule is registered and services are configured with its required configuration key.",
      "behavior": "Then an is available from the built service provider.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/Modularity/RazorPagesConfigurationTests.cs",
        "line": 81,
        "member": "Incursa.Platform.Tests.Modularity.RazorPagesConfigurationTests.ConfigureRazorModulePages_invokes_module_configuration"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.Modularity.RazorPagesConfigurationTests.ConfigureRazorModulePages_registers_application_parts",
      "category": "Modularity",
      "tags": [],
      "summary": "When ConfigureRazorModulePages is invoked for a registered Razor module, then its assembly is added to the Razor application parts.",
      "intent": "Verify that Razor module assemblies are registered with Razor pages.",
      "scenario": "Given a module registry containing TestRazorModule and services configured with the required configuration key.",
      "behavior": "Then the MVC ApplicationPartManager includes an AssemblyPart for the module assembly.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/Modularity/RazorPagesConfigurationTests.cs",
        "line": 43,
        "member": "Incursa.Platform.Tests.Modularity.RazorPagesConfigurationTests.ConfigureRazorModulePages_registers_application_parts"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.Modularity.RequiredServiceValidationTests.Discovery_service_resolve_engine_throws_when_factory_returns_null",
      "category": "Modularity",
      "tags": [],
      "summary": "When an engine descriptor factory returns null, then ResolveEngine throws and identifies the module/engine key.",
      "intent": "Guard against null engine factories during discovery resolution.",
      "scenario": "Given a ModuleEngineDescriptor whose factory returns null and an empty service provider.",
      "behavior": "Then ResolveEngine throws an InvalidOperationException mentioning \"returned null\" and the descriptor key.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/Modularity/RequiredServiceValidationTests.cs",
        "line": 145,
        "member": "Incursa.Platform.Tests.Modularity.RequiredServiceValidationTests.Discovery_service_resolve_engine_throws_when_factory_returns_null"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.Modularity.RequiredServiceValidationTests.Ui_adapter_executes_when_required_services_are_satisfied",
      "category": "Modularity",
      "tags": [],
      "summary": "When required services are satisfied, then ExecuteAsync returns the engine result.",
      "intent": "Confirm successful execution when required services are available.",
      "scenario": "Given RequiredServiceModule is registered and a TestRequiredServiceValidator lists cache and telemetry as available.",
      "behavior": "Then the returned view model contains the expected \"ok\" value.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/Modularity/RequiredServiceValidationTests.cs",
        "line": 111,
        "member": "Incursa.Platform.Tests.Modularity.RequiredServiceValidationTests.Ui_adapter_executes_when_required_services_are_satisfied"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.Modularity.RequiredServiceValidationTests.Ui_adapter_requires_required_service_validator_when_engine_declares_required_services",
      "category": "Modularity",
      "tags": [],
      "summary": "When a UI engine declares required services and no validator is registered, then ExecuteAsync fails and mentions IRequiredServiceValidator.",
      "intent": "Ensure required service validation is enforced when engines declare dependencies.",
      "scenario": "Given RequiredServiceModule is registered and the service collection omits an IRequiredServiceValidator.",
      "behavior": "Then ExecuteAsync throws an InvalidOperationException whose message references IRequiredServiceValidator.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/Modularity/RequiredServiceValidationTests.cs",
        "line": 41,
        "member": "Incursa.Platform.Tests.Modularity.RequiredServiceValidationTests.Ui_adapter_requires_required_service_validator_when_engine_declares_required_services"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.Tests:Incursa.Platform.Tests.Modularity.RequiredServiceValidationTests.Ui_adapter_throws_when_required_services_are_missing",
      "category": "Modularity",
      "tags": [],
      "summary": "When required services are missing, then ExecuteAsync throws with missing service details.",
      "intent": "Validate that required service checks surface missing dependencies in the error message.",
      "scenario": "Given RequiredServiceModule is registered and a TestRequiredServiceValidator reports no available services.",
      "behavior": "Then ExecuteAsync throws and the message contains the missing service name and summary text.",
      "source": {
        "file": "tests/Incursa.Platform.Tests/Modularity/RequiredServiceValidationTests.cs",
        "line": 75,
        "member": "Incursa.Platform.Tests.Modularity.RequiredServiceValidationTests.Ui_adapter_throws_when_required_services_are_missing"
      },
      "status": "compliant",
      "project": "Incursa.Platform.Tests"
    },
    {
      "testId": "Incursa.Platform.TestUtilities:Incursa.Platform.Tests.TestUtilities.InboxWorkStoreBehaviorTestsBase.AbandonAsync_ReturnsMessageToQueue",
      "category": "TestUtilities",
      "tags": [],
      "summary": "When abandon Async Returns Message To Queue, then it behaves as expected.",
      "intent": "Document expected behavior for abandon Async Returns Message To Queue.",
      "scenario": "Given abandon Async Returns Message To Queue.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.TestUtilities/InboxWorkStoreBehaviorTestsBase.cs",
        "line": 159,
        "member": "Incursa.Platform.Tests.TestUtilities.InboxWorkStoreBehaviorTestsBase.AbandonAsync_ReturnsMessageToQueue"
      },
      "status": "compliant",
      "project": "Incursa.Platform.TestUtilities"
    },
    {
      "testId": "Incursa.Platform.TestUtilities:Incursa.Platform.Tests.TestUtilities.InboxWorkStoreBehaviorTestsBase.AckAsync_RemovesMessageFromClaims",
      "category": "TestUtilities",
      "tags": [],
      "summary": "When ack Async Removes Message From Claims, then it behaves as expected.",
      "intent": "Document expected behavior for ack Async Removes Message From Claims.",
      "scenario": "Given ack Async Removes Message From Claims.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.TestUtilities/InboxWorkStoreBehaviorTestsBase.cs",
        "line": 122,
        "member": "Incursa.Platform.Tests.TestUtilities.InboxWorkStoreBehaviorTestsBase.AckAsync_RemovesMessageFromClaims"
      },
      "status": "compliant",
      "project": "Incursa.Platform.TestUtilities"
    },
    {
      "testId": "Incursa.Platform.TestUtilities:Incursa.Platform.Tests.TestUtilities.InboxWorkStoreBehaviorTestsBase.ClaimAsync_WithAvailableMessage_ReturnsMessageId",
      "category": "TestUtilities",
      "tags": [],
      "summary": "When claim Async With Available Message Returns Message Id, then it behaves as expected.",
      "intent": "Document expected behavior for claim Async With Available Message Returns Message Id.",
      "scenario": "Given claim Async With Available Message Returns Message Id.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.TestUtilities/InboxWorkStoreBehaviorTestsBase.cs",
        "line": 65,
        "member": "Incursa.Platform.Tests.TestUtilities.InboxWorkStoreBehaviorTestsBase.ClaimAsync_WithAvailableMessage_ReturnsMessageId"
      },
      "status": "compliant",
      "project": "Incursa.Platform.TestUtilities"
    },
    {
      "testId": "Incursa.Platform.TestUtilities:Incursa.Platform.Tests.TestUtilities.InboxWorkStoreBehaviorTestsBase.ClaimAsync_WithFutureDueTime_ReturnsEmpty",
      "category": "TestUtilities",
      "tags": [],
      "summary": "When claim Async With Future Due Time Returns Empty, then it behaves as expected.",
      "intent": "Document expected behavior for claim Async With Future Due Time Returns Empty.",
      "scenario": "Given claim Async With Future Due Time Returns Empty.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.TestUtilities/InboxWorkStoreBehaviorTestsBase.cs",
        "line": 92,
        "member": "Incursa.Platform.Tests.TestUtilities.InboxWorkStoreBehaviorTestsBase.ClaimAsync_WithFutureDueTime_ReturnsEmpty"
      },
      "status": "compliant",
      "project": "Incursa.Platform.TestUtilities"
    },
    {
      "testId": "Incursa.Platform.TestUtilities:Incursa.Platform.Tests.TestUtilities.InboxWorkStoreBehaviorTestsBase.ClaimAsync_WithNoMessages_ReturnsEmptyList",
      "category": "TestUtilities",
      "tags": [],
      "summary": "When claim Async With No Messages Returns Empty List, then it behaves as expected.",
      "intent": "Document expected behavior for claim Async With No Messages Returns Empty List.",
      "scenario": "Given claim Async With No Messages Returns Empty List.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.TestUtilities/InboxWorkStoreBehaviorTestsBase.cs",
        "line": 47,
        "member": "Incursa.Platform.Tests.TestUtilities.InboxWorkStoreBehaviorTestsBase.ClaimAsync_WithNoMessages_ReturnsEmptyList"
      },
      "status": "compliant",
      "project": "Incursa.Platform.TestUtilities"
    },
    {
      "testId": "Incursa.Platform.TestUtilities:Incursa.Platform.Tests.TestUtilities.InboxWorkStoreBehaviorTestsBase.FailAsync_RemovesMessageFromClaims",
      "category": "TestUtilities",
      "tags": [],
      "summary": "When fail Async Removes Message From Claims, then it behaves as expected.",
      "intent": "Document expected behavior for fail Async Removes Message From Claims.",
      "scenario": "Given fail Async Removes Message From Claims.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.TestUtilities/InboxWorkStoreBehaviorTestsBase.cs",
        "line": 202,
        "member": "Incursa.Platform.Tests.TestUtilities.InboxWorkStoreBehaviorTestsBase.FailAsync_RemovesMessageFromClaims"
      },
      "status": "compliant",
      "project": "Incursa.Platform.TestUtilities"
    },
    {
      "testId": "Incursa.Platform.TestUtilities:Incursa.Platform.Tests.TestUtilities.InboxWorkStoreBehaviorTestsBase.GetAsync_ReturnsStoredMessage",
      "category": "TestUtilities",
      "tags": [],
      "summary": "When get Async Returns Stored Message, then it behaves as expected.",
      "intent": "Document expected behavior for get Async Returns Stored Message.",
      "scenario": "Given get Async Returns Stored Message.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.TestUtilities/InboxWorkStoreBehaviorTestsBase.cs",
        "line": 239,
        "member": "Incursa.Platform.Tests.TestUtilities.InboxWorkStoreBehaviorTestsBase.GetAsync_ReturnsStoredMessage"
      },
      "status": "compliant",
      "project": "Incursa.Platform.TestUtilities"
    },
    {
      "testId": "Incursa.Platform.TestUtilities:Incursa.Platform.Tests.TestUtilities.OutboxStoreBehaviorTestsBase.ClaimDueAsync_ReturnsCorrelationIdAndDueTime",
      "category": "TestUtilities",
      "tags": [],
      "summary": "When claim Due Async Returns Correlation Id And Due Time, then it behaves as expected.",
      "intent": "Document expected behavior for claim Due Async Returns Correlation Id And Due Time.",
      "scenario": "Given claim Due Async Returns Correlation Id And Due Time.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.TestUtilities/OutboxStoreBehaviorTestsBase.cs",
        "line": 98,
        "member": "Incursa.Platform.Tests.TestUtilities.OutboxStoreBehaviorTestsBase.ClaimDueAsync_ReturnsCorrelationIdAndDueTime"
      },
      "status": "compliant",
      "project": "Incursa.Platform.TestUtilities"
    },
    {
      "testId": "Incursa.Platform.TestUtilities:Incursa.Platform.Tests.TestUtilities.OutboxStoreBehaviorTestsBase.ClaimDueAsync_WithDueMessages_ReturnsMessages",
      "category": "TestUtilities",
      "tags": [],
      "summary": "When claim Due Async With Due Messages Returns Messages, then it behaves as expected.",
      "intent": "Document expected behavior for claim Due Async With Due Messages Returns Messages.",
      "scenario": "Given claim Due Async With Due Messages Returns Messages.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.TestUtilities/OutboxStoreBehaviorTestsBase.cs",
        "line": 62,
        "member": "Incursa.Platform.Tests.TestUtilities.OutboxStoreBehaviorTestsBase.ClaimDueAsync_WithDueMessages_ReturnsMessages"
      },
      "status": "compliant",
      "project": "Incursa.Platform.TestUtilities"
    },
    {
      "testId": "Incursa.Platform.TestUtilities:Incursa.Platform.Tests.TestUtilities.OutboxStoreBehaviorTestsBase.ClaimDueAsync_WithFutureMessages_ReturnsEmpty",
      "category": "TestUtilities",
      "tags": [],
      "summary": "When claim Due Async With Future Messages Returns Empty, then it behaves as expected.",
      "intent": "Document expected behavior for claim Due Async With Future Messages Returns Empty.",
      "scenario": "Given claim Due Async With Future Messages Returns Empty.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.TestUtilities/OutboxStoreBehaviorTestsBase.cs",
        "line": 81,
        "member": "Incursa.Platform.Tests.TestUtilities.OutboxStoreBehaviorTestsBase.ClaimDueAsync_WithFutureMessages_ReturnsEmpty"
      },
      "status": "compliant",
      "project": "Incursa.Platform.TestUtilities"
    },
    {
      "testId": "Incursa.Platform.TestUtilities:Incursa.Platform.Tests.TestUtilities.OutboxStoreBehaviorTestsBase.ClaimDueAsync_WithNoMessages_ReturnsEmptyList",
      "category": "TestUtilities",
      "tags": [],
      "summary": "When claim Due Async With No Messages Returns Empty List, then it behaves as expected.",
      "intent": "Document expected behavior for claim Due Async With No Messages Returns Empty List.",
      "scenario": "Given claim Due Async With No Messages Returns Empty List.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.TestUtilities/OutboxStoreBehaviorTestsBase.cs",
        "line": 48,
        "member": "Incursa.Platform.Tests.TestUtilities.OutboxStoreBehaviorTestsBase.ClaimDueAsync_WithNoMessages_ReturnsEmptyList"
      },
      "status": "compliant",
      "project": "Incursa.Platform.TestUtilities"
    },
    {
      "testId": "Incursa.Platform.TestUtilities:Incursa.Platform.Tests.TestUtilities.OutboxStoreBehaviorTestsBase.FailAsync_RemovesMessageFromClaims",
      "category": "TestUtilities",
      "tags": [],
      "summary": "When fail Async Removes Message From Claims, then it behaves as expected.",
      "intent": "Document expected behavior for fail Async Removes Message From Claims.",
      "scenario": "Given fail Async Removes Message From Claims.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.TestUtilities/OutboxStoreBehaviorTestsBase.cs",
        "line": 165,
        "member": "Incursa.Platform.Tests.TestUtilities.OutboxStoreBehaviorTestsBase.FailAsync_RemovesMessageFromClaims"
      },
      "status": "compliant",
      "project": "Incursa.Platform.TestUtilities"
    },
    {
      "testId": "Incursa.Platform.TestUtilities:Incursa.Platform.Tests.TestUtilities.OutboxStoreBehaviorTestsBase.MarkDispatchedAsync_RemovesMessageFromClaims",
      "category": "TestUtilities",
      "tags": [],
      "summary": "When mark Dispatched Async Removes Message From Claims, then it behaves as expected.",
      "intent": "Document expected behavior for mark Dispatched Async Removes Message From Claims.",
      "scenario": "Given mark Dispatched Async Removes Message From Claims.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.TestUtilities/OutboxStoreBehaviorTestsBase.cs",
        "line": 122,
        "member": "Incursa.Platform.Tests.TestUtilities.OutboxStoreBehaviorTestsBase.MarkDispatchedAsync_RemovesMessageFromClaims"
      },
      "status": "compliant",
      "project": "Incursa.Platform.TestUtilities"
    },
    {
      "testId": "Incursa.Platform.TestUtilities:Incursa.Platform.Tests.TestUtilities.OutboxStoreBehaviorTestsBase.RescheduleAsync_MakesMessageAvailableAgain",
      "category": "TestUtilities",
      "tags": [],
      "summary": "When reschedule Async Makes Message Available Again, then it behaves as expected.",
      "intent": "Document expected behavior for reschedule Async Makes Message Available Again.",
      "scenario": "Given reschedule Async Makes Message Available Again.",
      "behavior": "Then the operation matches the expected outcome.",
      "source": {
        "file": "tests/Incursa.Platform.TestUtilities/OutboxStoreBehaviorTestsBase.cs",
        "line": 142,
        "member": "Incursa.Platform.Tests.TestUtilities.OutboxStoreBehaviorTestsBase.RescheduleAsync_MakesMessageAvailableAgain"
      },
      "status": "compliant",
      "project": "Incursa.Platform.TestUtilities"
    }
  ]
}
